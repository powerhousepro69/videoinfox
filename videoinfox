#!/bin/bash
#  file : videoinfox v3.9.00
#  github and reddit: powerhousepro69
#  GNU General Public License v2.0
#  reddit:  /videoinfox

# This is where Videoinfox's Version Number is set.
# Version Number: no blinking dot
ver="Videoinfox v3.9.00"
# Version Number: with blinking dot
der=$(echo -e "Videoinfox v3\033[5m.\033m\033[0m\033[5m\033[5m\033[0m9.00")

# YT-DLP is not on the dependency list becuase Videoinfox will download it to:   ${base_dir}   All calls to yt-dlp are pointed to:   
# ${base_dir}/yt-dlp   There is an update option in:   <Set>  Settings to update yt-dlp   (just the copy in ${base_dir})
# I didn't want to overwrite anyones copy of:   /user/local/bin/yt-dlp     Also, I wanted to make sure all new Videoinfox script installs
# included the most recent version of Yt-dlp
dependencies='notify-send bc ffmpeg ffprobe ffplay xclip'
dependency_failmsg=''

base_url="https://raw.githubusercontent.com/powerhousepro69/videoinfox/main"
ytdlp_url="https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp"

ffprobe_opts=(
    "-v error"
    "-show_entries stream=codec_name"
    "-of default=noprint_wrappers=1:nokey=1"
    "-select_streams v:0"
    "-show_entries stream=width,height"
    "-of default=nw=1"
)

base_dir="${HOME}/.config/videoinfox"
playlist_dir="${base_dir}/playlists"
tmp_dir="${base_dir}/tmp"
readonly base_url ytdlp_url base_dir playlist_dir tmp_dir

# Get the top level PID and setup a trap so that we can call die() within subshells
trap "exit 1" TERM
_self_pid="${$}"
export _self_pid

die() {
    if [ -t 0 ]; then
        printf '\e[31;1m====>%s\e[0m\n' "${0}:(${LINENO}): ${*}" >&2
    else
        printf -- '====>%s\n' "${0}:(${LINENO}): ${*}" >&2
    fi
    # Send a TERM signal to the top level PID, this is trapped and exit 1 is forced
    kill -s TERM "${_self_pid}"
}

init() {
    # Check for dependencies and output anything missing to stderr
    for dependency in ${dependencies}; do
        if ! command -v "${dependency}" >/dev/null 2>&1; then
            dependency_failmsg="${dependency_failmsg},${dependency}" 
        fi
    done

    if (( "${#dependency_failmsg}" > 0 )); then
        printf -- '\n%s\n%s\n' \
            "The following dependencies were not found in PATH:" \
            "${dependency_failmsg/,/}" >&2
        exit 1
    fi

    # Disallow usage in /
    [[ "${PWD}" = "/" ]] && die "Videoinfox must not be run within /"

    # Create our required directories
    mkdir -p "${base_dir}" || die "Could not create ${base_dir}"
    mkdir -p "${tmp_dir}" || die "Could not create ${tmp_dir}"
    mkdir -p "${playlist_dir}" || die "Could not create ${playlist_dir}"

    # Define names to be used in the loop below
    filenames=(
        videoinfo.findwork
        videoinfo.findwork2
        videoinfo.findwork3
        videoinfo.lastfindtime
        videoinfo.lastsearchtotal
        videoinfo.lastsearchtotal2
        videoinfo.playedlist
        videoinfo.keptsearch
        videoinfo.tv-dir
        videoinfo.movies-dir
        videoinfo.parent-dir
        videoinfo.lastdownload
        videoinfo.lastfindstring
        videoinfo.lastfinddir
        videoinfo.lastsearchtotal
        videoinfox.set-user-list
    )

    # Create blank files
    for filename in ${filenames[@]}; do
        touch "${base_dir}/${filename}"
    done

    # Create empty Default Download List if one doesn't already exist.
    if [[ ! -f "${base_dir}/videoinfox-dl-Default" ]]; then
        touch "${base_dir}/videoinfox-dl-Default"
        printf -- '%s\n' "Default Download List Empty" >> "${base_dir}/videoinfox-dl-Default"
    fi

    # Check for an updated version of videoinfox
    videoinfox_update
}

file_contains() {
    grep -q "${1:?No search parameters given}" "${2:?No file to search defined}"
}

find_supported_files() {
    case "${1}" in
        (--count)
            find "${PWD}" -maxdepth 1 -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) |
                wc -l
        ;;
        (*)
            find "${PWD}" -maxdepth 1 -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) |
                sort -u
        ;;
    esac
}

# Get codec, width, height & duration
get_file_stats() {
    local target_file
    target_file="${1:?No target specified}"
    printf -- 'Video Info: %s Duration: %s\n' \
        "$(ffprobe "${ffprobe_opts[@]}" "${target_file}")" \ 
        "$(ffmpeg -i "${target_file}" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)"
}

# This pauses the execution.  It displays and counts down the seconds set in <$sec>
noisy_timeout() {
    local sec msg
    noisy_timeout "${1:?No timeout defined}"
    shift 1
    msg="${*}"
    for (( i=sec; i>=0; i-- )); do
        tput sc
        printf -- '%s' "${msg:-Timeout} in: ${i}"
        tput rc
        sleep 1
    done
    printf -- '%s\n' ""
}

retrieve_url() {
    local remote_source local_destination
    remote_source="${1:?No url defined}"
    local_destination="${2:?No output path defined}"
    if command -v curl >/dev/null 2>&1; then
        printf -- '%s' "Downloading with curl..."
        curl -s -L "${remote_source}" > "${local_destination}"
    elif command -v wget >/dev/null 2>&1; then
        printf -- '%s' "Downloading with wget..."
        wget "${remote_source}" > "${local_destination}"
    else
        die "This function requires 'wget' or 'curl', but neither were found in PATH"
    fi
}

# Remove empty lines from a given file
squash() {
    sed -i '/^$/d' "${1:?No file specified}"
}

write_supported_list() {
    while read -r line; do
        case "${line}" in
            (*.mp4|*.webm|*.mkv|*.avi|*.divx)
                printf -- '%s\n' "${line}" >> "${2?No output file defined}"
            ;;
        esac
    done < "${1:?No input file defined}"
}

# Retrieve the latest available version number for yt-dlp
ytdlp_get_latest_version_number() {
    # If we have 'jq' present, then our life is a lot easier
    if command -v jq >/dev/null 2>&1; then
        curl -s -L "https://api.github.com/repos/yt-dlp/yt-dlp/releases/latest" | jq -r '.tag_name'
    # Manually parsing JSON in shell is a fool's game.
    # Fortunately this is a case we can get away with.
    else
        local raw_version
        raw_version="$(
            curl -s -L "https://api.github.com/repos/yt-dlp/yt-dlp/releases/latest" | awk -F ': ' '/tag_name/{print $2}'
        )"
        # Remove surrounding speech marks e.g. "2022.08.19", ==> 2022.08.19,
        raw_version="${raw_version//\"/}"
        # Remove trailing comma e.g. 2022.08.19, ==> 2022.08.19
        raw_version="${raw_version/,/}"
        # Output the cleaned up result
        printf -- '%s\n' "${raw_version}"
    fi
}

ytdlp_check_version() {
    # If it doesn't exist at all in PATH, then download it
    if ! command -v yt-dlp >/dev/null 2>&1; then
        ytdlp_install
        return 0
    fi

    # If it does exist in path, then get its version number
    ytdlp_cur_version="$(yt-dlp --version)"

    # And get the latest available version number
    ytdlp_latest_version="$(ytdlp_get_latest_version_number)"

    # If the versions match, then there's nothing to do here
    [[ "${ytdlp_cur_version}" = "${ytdlp_latest_version}" ]] && return 0

    # If we're at this point, then we need to update ytdlp
    ytdlp_install --update
}



#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -v     DISPLAY VERSION NUMBER THEN EXIT  
#-------------------------------------------------------------------------------------------------------------------------------------------------
print_version() {
    printf -- '%s\n' "${ver}"
    exit 0
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -l     ADD CLIPBOARD CONTENT ON THE FLY TO:   USER SET LIST   THEN EXIT
#-------------------------------------------------------------------------------------------------------------------------------------------------

# Create a gui keyboard shortcut for:   videoinfox -l
# It isn't necessary to have the Videoinfox running while using this feature.
# Build your set user list on the fly without leaving the gui
# COPY THE URL TO THE BROWSER. THEN USE YOUR SHORTCUT TO WRITE URL TO THE USER SET LIST. Rinse and repeat to keep adding to the list.

# -l  Write clipboard content to the User Set List. For instructions on use: Yt-dlp >>> Download List >>> Help
write_user_set_list() {
    read -r grabuserlist < "${base_dir}/videoinfox.set-user-list"
    if [[ -f "$grabuserlist" ]]; then
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
        echo "$pasteclip" >> "$grabuserlist"  # write url to the user set list
        notify-send "Videoinfox Message: Added link to List ${grabuserlist}  . . ." "${pasteclip}" # GUI Notification.
    
        cat -n "$grabuserlist" | sort -uk2 | sort -n | cut -f2- > "${base_dir}/videoinfox.ulistfly.tmp"  # REMOVE DUPLICATES
        squash "${base_dir}/videoinfox.ulistfly.tmp"  # remove any blank lines in the list
        sed -i '/http/!d' "${base_dir}/videoinfox.ulistfly.tmp"  # remove all lines not starting with  http
    
        mv "${base_dir}/videoinfox.ulistfly.tmp" "${grabuserlist}"

        echo "" | xclip -sel clip  # clearing out the clipboard
        exit
    else
        notify-send "Videoinfox -l Error . . ." "No user list has been set for this feature.  Set User List in Videoinfox first."
        exit
    fi
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -a     ADD CLIPBOARD CONTENT  ON THE FLY TO:   DEFAULT LIST   THEN EXIT
#-------------------------------------------------------------------------------------------------------------------------------------------------

# Create a gui keyboard shortcut for:   videoinfox -a
# It isn't necessary to have the Videoinfox running while using this feature.
# Build your default list on the fly without leaving the gui
# COPY THE URL TO THE BROWSER. THEN USE YOUR SHORTCUT TO WRITE URL TO THE DEFAULT DOWNLOAD LIST. Rinse and repeat to keep adding to the Default List. 

# -a  Write clipboard content to the Default List. For instructions on use: Yt-dlp >>> Download List >>> Help
write_default_list() {
    # This file should always exist:   ${base_dir}/videoinfox-dl-Default   if it doesn't, it will be created
    if [[ ! -f "${base_dir}/videoinfox-dl-Default" ]]; then
        # CREATING EMPTY DEFAULT DOWNLOAD LIST WITH LIST EMPTY MESSAGE
        touch "${base_dir}/videoinfox-dl-Default"
        echo "Default Download List Empty" >> "${base_dir}/videoinfox-dl-Default"
    fi
    # ADD TO DEFAULT LIST  <DEFAULT LIST>
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    echo "$pasteclip" >> "${base_dir}/videoinfox-dl-Default"  # write url to the default download list
    notify-send "Videoinfox added link to the Default Download List . . ." "${pasteclip}" # GUI Notification.

    # REMOVE DUPLICATES
    cat -n "${base_dir}/videoinfox-dl-Default" | sort -uk2 | sort -n | cut -f2- > "${base_dir}/videoinfox-dl-Default.tmp"
    mv "${base_dir}/videoinfox-dl-Default.tmp" "${base_dir}/videoinfox-dl-Default"

    squash "${base_dir}/videoinfox-dl-Default" 2>/dev/null  # remove any blank lines in the list
    sed -i '/http/!d' "${base_dir}/videoinfox-dl-Default"  # remove all lines not starting with  http

    echo "" | xclip -sel clip  # clearing out the clipboard

    exit
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -h     DISPLAY HELP THEN EXIT  
#-------------------------------------------------------------------------------------------------------------------------------------------------
print_help() {
cat << EOF
___________________________________________________________________________________________________________________
       echo  
 "${ver}" >>> COMMAND LINE OPTIONS >>> HELP              Where Video Play is a Clipboard Copy Away . . .
___________________________________________________________________________________________________________________ 

 Note: Videoinfox won't accept multiple options. Only one option per instance.

   -h  This help screen.

   -v  Display the version number.

   -a  Write clipboard content to the Default List. For instructions on use: Yt-dlp >>> Download List >>> Help

   -l  Write clipboard content to the User Set List. For instructions on use: Yt-dlp >>> Download List >>> Help

   -u  This option can be used with your own ready to download url list that can be any name and location.
       There is no need to use the Videoinfox interface with this option. Videos will be downloaded to the
       directory of the list location.  Example: videoinfox -u mylist  Only enter the list filename.
       The list must be recursively reachable from the current directory.
       The first line in the list must begin with http to be processed.

   -d  Autoplay video files in the current directory.

EOF
exit 0
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -u     DOWNLOAD ANY LIST THAT IS RECURSIVELY REACHABLE FROM THE CURRENT DIRECORY. ENTER FULL FILENAME ONLY. NO WILDCARD
#-------------------------------------------------------------------------------------------------------------------------------------------------

# -u  This option can be used with your own ready to download url list that can be any name and location
use_custom_list() {
    clear
    echo
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$ver"" >>> Load a recursively reachable Download List for processing . . ."
    echo "___________________________________________________________________________________________________________________"    
    if echo "$2" | grep "/" > /dev/null; then
        echo
        echo " error: No directories. Only a filename. List must be recursively reachable from the current directory."
        echo
        exit
    fi
    if echo "$2" | grep "*" > /dev/null; then
        echo
        echo " error: No wildcards. Only a filename. List must be recursively reachable from the current directory."
        echo 
        exit
    fi
    filecount=$(find "$PWD" -type f \( -iname "$2" \) | wc -l)
       
    if [[ "$filecount" = 1 ]]; then
        chkforhttp=$(find "$PWD" -type f \( -iname "$2" \))  # getting list name to check the first line for http
        read chkforhttp2 < "$chkforhttp"  # reading first line into varible $chkforhhtp2
        chkforhttp=$(echo "$chkforhttp2" | cut -c-4)   # cut everything after the 4th character

        if [[ ! "$chkforhttp" = "http" ]]; then
            echo
            echo -e "\033[5m error\033m\033[0m:   The first 4 characters on the first line don't start with http"
            echo "          This is a safety feature to prevent accidental deletion of a file that is not a Download List."
            echo
            echo "          If this file was processed, The following lines would have been removed:"
            echo
            echo "          - All lines that don't begin with: http"
            echo "          - All duplicate lines"
            echo "          - All blank lines"
            echo
            echo "          ** The first line of all Download Lists must begin with http to be processed with: videoinfox -u"
            echo 
            exit
        fi
        ##### GRAB THE PATH FROM THE DOWNLOAD LIST TO CHANGE THE WORKING DIRECTORY TO THAT PATH #####

        find "$PWD" -type f \( -iname "$2" \) > videoinfox-u-option-grabdir.tmp #2> /dev/null # find the list to grab the full path with filename
        sed -i 's%/[^/]*$%%' videoinfox-u-option-grabdir.tmp  # remove last slash and filename from the path for the cd command
        read -r < videoinfox-u-option-grabdir.tmp whatsthepath  # read the path into the varible: $whatsthepath 
        rm videoinfox-u-option-grabdir.tmp  # download list location is no longer needed. so it will be removed
        cd "$whatsthepath"  # cd to the download list location.


        #####  ERROR CORRECTION FOR THE USER'S LIST BEFORE DOWNLOAD.  #####

        cat -n "$2" | sort -uk2 | sort -n | cut -f2- > videoinfox-u-option.tmp  # remove duplicates from the user's list
        squash videoinfox-u-option.tmp  # remove all blank lines from the user's list
        sed -i '/http/!d' videoinfox-u-option.tmp  # remove all lines not starting with: http from the user's list
        mv videoinfox-u-option.tmp "$2"  
        #####  TAGGING .log ONTO THE USER'S LIST FILENAME TO CREATE A LOG FILE OF THE DOWNLOAD  #####
    
        ulogfile="$2".log  # tag  .log  onto the filename for log creation
        echo "$ver" ">>> videoinfox -u" "$2" ">>> Logfile" > "$ulogfile"  # create the log file header Line 1
        echo >> "$ulogfile"
        echo "Download list:" "$PWD/""$2" >> "$ulogfile"  # create the log file header Line 2
        echo >> "$ulogfile"  # create the log file header Line 3 (blank line)
        echo >> "$ulogfile"  # create the log file header Line 4 (blank line)

        echo
        echo "Processing list:" "$PWD/""$2"
        
            
        #####  DOWNLOAD LIST  #####
        
        input="$2"  # INPUT FOR THE DOWNLOAD LOOP (the download list)
        #####  DOWNLOAD LOOP START  #####

        while read -r line; do

            echo
            ${base_dir}/yt-dlp "$line"  # download url
            echo
            echo "Logging URL and Filename to:" "$PWD/""$ulogfile" 

            # logging yt-dlp output to the log file

            echo "$line" >> "$ulogfile" 
            ${base_dir}/yt-dlp "$line" | tee >> "$PWD/""$ulogfile"
            echo >> "$ulogfile" 

        done < "$input"

        #####  DOWNLOAD LOOP END  #####
        #####  REMOVE UNWANTED LOG INFO  ##### 

        sed -i '/\[youtube\]/d' "$2".log &> /dev/null  # removing lines that start with  [youtube]
        sed -i '/\[info\]/d' "$2".log &> /dev/null  # removing lines that start with  [info]
        sed -i 's/\[download\]//' "$2".log &> /dev/null  # remove   [download]   from the end of the line.
        sed -i 's/has already been downloaded//' "$2".log &> /dev/null  # remove   has already been downloaded   from the end of the line.
        sed -i -e 's/^[ \t]*//' "$2".log &> /dev/null  # remove spaces at beginning of line.
        #####  DISPLAY AFTER THE LIST IS DONE DOWNLOADING  #####

        echo
        echo
        echo -e "$ver" "\033[5mdone processing download list . . .\033m\033[0m"                 
        echo
        echo "List:" "$PWD/""$2"  # display list filename with full path
        echo "Log :" "$PWD/""$ulogfile"  # display log filename with full path
        echo
        
        notify-send "Videoinfox -u messsage: Done Processing Download List . . ." "$PWD/""$2"
        exit  # exit videoinfox

    else
        echo
        echo " Videoinfox Error: List not found. List must be recursively reachable from the current directory."
        echo
        exit
    fi    
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -d     PLAY DIRECTORY.  AUTOPLAY VIDEO FILES IN THE CURRENT DIRECTORY
#-------------------------------------------------------------------------------------------------------------------------------------------------

# -d  Autoplay video files in the current directory
play_directory() {
    # WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
    find_supported_files > "${tmp_dir}/videoinfox.optiond-play-directory-apa"

    #  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
    if ! file_contains '^/' "${tmp_dir}/videoinfox.optiond-play-directory-apa"; then
        rm "${tmp_dir}/videoinfox.optiond-play-directory-apa" 2>/dev/null
        rm "${tmp_dir}/videoinfox.optiond-play-directory-apa2" 2>/dev/null
        rm "${tmp_dir}/videoinfox.numbered-optiond-play-directory-list" 2>/dev/null
        return
    fi

    #  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
    moddedplayedlist="${HOME}/.config/videoinfox/tmp/videoinfox.optiond-play-directory-apa"

    #  CREATE TEMP FILE NEEDED FOR LOOP 
    touch "${tmp_dir}/videoinfox.optiond-play-directory-apa2"

    #  #  START WRITING
    while read -r line; do
        if [[ ! -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
            printf -- '%s\n' "$line" >> "${tmp_dir}/videoinfox.optiond-play-directory-apa2"
        fi
    done < "${moddedplayedlist}"

    #  REMOVE BLANK LINES
    squash "${tmp_dir}/videoinfox.optiond-play-directory-apa2" 2>/dev/null

    #  MOVE apa2 BACK TO apa
    mv "${tmp_dir}/videoinfox.optiond-play-directory-apa2" "${tmp_dir}/videoinfox.optiond-play-directory-apa" 2>/dev/null

    #  CREATE FILE NEEDED FOR LOOP 
    touch "${tmp_dir}/videoinfox.optiond-play-directory-apa2"

    #  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
    while read -r line; do
        case "${line}" in
            (*.mp4|*.webm|*.mkv|*.avi|*.divx)
                printf -- '%s\n' "${line}" >> "${tmp_dir}/videoinfox.optiond-play-directory-apa2"
            ;;
        esac
    done < "${moddedplayedlist}"

    #  REMOVE BLANK LINES
    squash "${tmp_dir}/videoinfox.optiond-play-directory-apa2" 2>/dev/null

    #  MOVE apa2 BACK TO apa
    cp "${tmp_dir}/videoinfox.optiond-play-directory-apa2" "${tmp_dir}/videoinfox.optiond-play-directory-apa" 2>/dev/null

    # REMOVE PATH ONLY LEAVING FILENAME
    sed -i 's/.*\///' "${tmp_dir}/videoinfox.optiond-play-directory-apa2"

    # NUMBER THE LIST
    sed '/./=' "${tmp_dir}/videoinfox.optiond-play-directory-apa2" |
        sed '/./N; s/\n/ /' > "${tmp_dir}/videoinfox.numbered-optiond-play-directory-list" 2>/dev/null

    clear

    if [[ -f "${tmp_dir}/videoinfox.numbered-optiond-play-directory-list" ]]; then
        cat "${tmp_dir}/videoinfox.numbered-optiond-play-directory-list" 2>/dev/null
    else
        echo
        echo
        echo "$der  No playable content in the current directory . . ."
        echo
    fi
    linenumber=1

    tail -n +"$linenumber" "${tmp_dir}/videoinfox.optiond-play-directory-apa" > "${tmp_dir}/videoinfox.optiond-play-directory-apa.tmp" 2>/dev/null
    mv "${tmp_dir}/videoinfox.optiond-play-directory-apa.tmp" "${tmp_dir}/videoinfox.optiond-play-directory-apa" 2>/dev/null

    OLDIFS=$IFS
    IFS=$'\n'

    for line in $(cat "$input" 2>/dev/null); do
        clear
        echo
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " ""$der"" >>> Command Line Option -d >>> PLAY DIRECTORY" 
        echo
        echo " [PLAY]>" "$line"
        echo "___________________________________________________________________________________________________________________"
        echo

        get_file_stats "${line}"
        
        echo
        echo
        echo " Video Player Controls:"
        echo                             
        echo " - Fullscreen Toggle: f"
        echo
        echo " - Play/Pause Toggle: space bar"
        echo
        echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
        echo
        echo " - Quit: q"      
        echo -e "\n"

        ffplay -fs -autoexit "$line" 2> /dev/null

        echo " To bypass the 3 second wait press enter with no entry"
        echo
        echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
        echo 
        read -t 3 -p " Press any key then press enter to quit : " playdir
            
        # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
        if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
            clear
            break                                                   # if enter is pressed without any input the next video will play
        else                                                        
            clear                                                   # press any key then enter within 3 seconds to quit Play Played List
        fi
    done
    
    IFS=$OLDIFS

    rm ${tmp_dir}/videoinfox.optiond-play-directory-apa 2>/dev/null
    rm ${tmp_dir}/videoinfox.optiond-play-directory-apa2 2>/dev/null
    rm ${tmp_dir}/videoinfox.numbered-optiond-play-directory-list 2>/dev/null

    exit
}

##################################################################################################################################################
#  END COMMAND LINE OPTIONS  #####################################################################################################################
##################################################################################################################################################

##################################################################################################################################################
#####  3. DIRECTORY CHECK & FILE CREATION  ####################################################################################################### 
##################################################################################################################################################

# The below check: Does the directory <${base_dir}> exist ?
# If it doesn't exist, directory is created. Empty files are created to avoid error when running Videoinfo for the first time.

direxist="$HOME/.config/videoinfox"

if [[ ! -d "$direxist" ]]; then
    clear
    echo
    echo "___________________________________________________________________________________________________________________"
    echo  
    echo " $ver >>> FIRST RUN >>> SETUP"
    echo
    echo " Directory and file creation"
    echo "___________________________________________________________________________________________________________________"
    echo "___________________________________________________________________________________________________________________"
    echo         
    echo " Created config directory: "$HOME"/.config/videoinfox and required files "
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " NOTE: Do not randomly paste in Videoinfox.  It will cause unwanted code to run producing"  
    echo " undesired results and can corrupt Videoinfox's data integrity and retention."
    echo
    echo " Everywhere the dot is blinking in the version number, don't paste and Videoinfox will function as intended."
    echo
    echo " ""$der"
    echo "__________________________________________________________________________________________________________________"
    echo
    echo " Yt-dlp will be downloaded to: "$HOME"/.config/videoinfox  "
    echo "__________________________________________________________________________________________________________________"
    echo
    echo -e " A sample video url was copied to the clipboard to show how the \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m feature works."
    echo
    echo " Video playing:  [ f - toggle fullscreen ]   [ spacebar - play/pause ]   [ l/r arrows - fwd/rew ]   [ q -quit ]"
    echo
    echo " Press  p  when Videoinfox starts up. That will download the video url that is in the clipboard and auto play it."
    echo "__________________________________________________________________________________________________________________"
    echo -e "\n" 
    echo " Setup for the first run or if the videoinfox directory gets deleted anytime after the first run."
    
                                    

    #####################
    # CREATE DIRECTORIES
    ####################
    # SET DEFAULT  LAST SEARCH  to <2> Never Save
    printf -- '%d\n' "2" > "${base_dir}/videoinfo.lastsearch-set"

    # Ensure that ~/Downloads exists 
    mkdir -p "${HOME}/Downloads"

    # SET DEFAULT  yt-dlp  DOWNLOAD DIRECTORY TO  ~/Downloads    It can be changed in the <set> menu
    printf -- '%s\n' "${HOME}/Downloads" > "${base_dir}/videoinfo.yt-download-dir"

    # SET DIR AT EXIT TO THE DEFAULT DOWNLOAD DIRECTORY SO DEFAULT DIR DISPLAY #3 LIGHTS UP ON FIRST RUN 
    printf -- '%s\n' "${HOME}/Downloads" > "${base_dir}/videoinfo.dir-at-exit"
    read -r diratexit < "${base_dir}/videoinfo.dir-at-exit"
    cd "$diratexit" 2>/dev/null 

    # Writing header for new blank Saved Search  playlist  ++++++++ this was added to get around a bug until the bug gets squashed.       
    touch ${base_dir}/videoinfo.keptsearch
    echo "PLAYlIST" >> ${base_dir}/videoinfo.keptsearch
    echo >> ${base_dir}/videoinfo.keptsearch
    echo "This File was Created: $(date) by" "$USER" >> ${base_dir}/videoinfo.keptsearch
    echo >> ${base_dir}/videoinfo.keptsearch

   
    # SAMPLE URL DOWLOAD LIST BEING CREATED WITH 3 VIDEO URL'S
    echo "https://www.youtube.com/watch?v=d59H0UxhyaY" > $HOME/Downloads/videoinfox-dl-sample-list
    echo "https://www.youtube.com/watch?v=5tSAKS8LRj0" >> $HOME/Downloads/videoinfox-dl-sample-list
    echo "https://www.youtube.com/watch?v=DAPkOxRnh4c" >> $HOME/Downloads/videoinfox-dl-sample-list

    echo
    
    noisy_timeout 36 "Downloading Yt-dlp"
fi

##################################################################################################################################################
##### CHECK FOR YT-DLP UPDATE ####################################################################################################################
ytdlp_update() {
    # Yt-dlp initial download attempt on the first run. If it fails, download will be re-attempted when you select the Yt-dlp Menu.
    clear
    echo
    echo 
    echo 
    echo "___________________________________________________________________________________________________________________"
    echo  
    echo " $der >>> Attempting to download the most recent version of Yt-dlp"
    echo "___________________________________________________________________________________________________________________" 
    echo
    echo " If Yt-dlp can't be downloaded, the download attempt will be aborted."
    echo
    echo " If the download fails, it is most likely due to at least 1 of the following reasons:"
    echo
    echo "    - Your internet connection is down."
    echo
    echo "    - Github isn't reachable due to technical issues on their end."
    echo
    echo "    - There is no Yt-dlp release available in:  https://github.com/yt-dlp/yt-dlp/releases/latest/download"
    echo
    echo
    echo " If this download fails, the download attempt will be tried again when you select the Yt-dlp Menu in Videoinfox."
    echo
    echo
    echo " Note: The Yt-dlp Menu will not work until there is a copy of yt-dlp in:"
    echo
    echo " "$HOME"/.config/videoinfox"
    echo
    echo

    dirtemp="$PWD"  # save dir for restore after ty-dlp download
    cd ${base_dir}
  
    retrieve_url "${ytdlp_url}" "${base_dir}/yt-dlp" 2>/dev/null
    
    if [[ -f ${base_dir}/yt-dlp ]]; then
        chmod a+rx ${base_dir}/yt-dlp  # set <yt-dlp-fetched> execute bit
        ${base_dir}/yt-dlp --version > ${base_dir}/videoinfo.yt-dlp.version # write yt-dlp ver number to file: yt-dlp.version 
        echo
        echo " Yt-dlp Downloaded . . ."
        echo
        # SAMPLE VIDEO URL BEING COPIED TO CLIPBOARD
        echo "https://www.youtube.com/watch?v=rNWPqfCJDnc" | xclip -sel clip

        noisy_timeout 5 " $ver starting"
        
        rm ${base_dir}/wget-* 2> /dev/null          
    else
        echo
        echo " Yt-dlp Download Failure . . ."
        echo

        noisy_timeout 15 " $ver starting"

        rm ${base_dir}/wget-* 2> /dev/null    

        cd "$dirtemp"  # restore directory
    fi
}

##################################################################################################################################################
##### CHECK FOR VIDEOINFOX UPDATE ################################################################################################################
videoinfox_update() {
    clear
    printf -- '%s\n' "" "" "" \
        "___________________________________________________________________________________________________________________" \
        " ${ver} >>> Checking for update . . ." \
        "___________________________________________________________________________________________________________________" \
        ""
    # Start a subshell, which will return us from whence we came when it closes
    # (i.e. no need for pushd/popd or other 'take me back' logic)
    (
        cd "${tmp_dir}" || die "Unable to enter ${tmp_dir}"
        # Try to retrieve the latest version from the web, quietly return on failure
        retrieve_url "${base_url}/videoinfox" "${tmp_dir}/videoinfox" 2>/dev/null || return

        # If the latest downloaded file differs from the one on-disk, then there's an update available
        if cmp -s "${tmp_dir}/videoinfox" /usr/local/bin/videoinfox; then
            printf -- '%s\n' "videoinfox is up to date."
        else
            videoinfox_latest_version="$(bash "${tmp_dir}"/videoinfox -v)"
            # send gui notification with update ver number
            notify-send "Videoinfox messsage: Update Available (${videoinfox_latest_version})"
        fi

        # Update to latest
        sudo mv "${tmp_dir}/videoinfox" /usr/local/bin/videoinfox 2> /dev/null
        # Remove our temporary file
        rm "${tmp_dir}/videoinfox"

        #####  CREATE DOWNLOAD LIST HELP FILE  ########################################################
        retrieve_url "${base_url}/docs/download-list-help" "${base_dir}/videoinfox.download-list-help"

        #####  CREATE HELP FILE  ######################################################################
        retrieve_url "${base_url}/docs/videoinfo-help" "${base_dir}/videoinfo.help"

        #####  CREATE VERSION HISTORY FILE  ###########################################################
        retrieve_url "${base_url}/docs/version-history" "${base_dir}/videoinfo-ver-history"

        printf -- '%s\n' "Latest version of videoinfox (${videoinfox_latest_version}) installed into /usr/local/bin"
        printf -- '%s\n' "Restart to use updated version.  Exiting..."
        exit 0
    )
}

read -r diratexit < "${base_dir}/videoinfo.dir-at-exit"
cd "$diratexit" 2>/dev/null 

if [[ ! -f ${base_dir}/videoinfo.playlist.current ]]; then
    echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current
fi
##################################################################################################################################################
###########################  HOME LOOP START #####################################################################################################
##################################################################################################################################################

menuf() {
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

    grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

    if [[ "$grabclip" != "http" ]]; then
        if [[ ! -f "$pasteclip" ]]; then
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
        fi
    fi
    # playedlist sort routine removed here

    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

    dirinhome="$PWD" 

    #  Load directory from last exit
    echo "$dirinhome" > ${base_dir}/videoinfo.home.dir

    grabdirfornav="$PWD"  # Save tree top before entering  NAVIGATE TREE  loop
    echo "$grabdirfornav" > ${base_dir}/videoinfo.navigate-dir-dat
    read -r grabdirfornav2 < ${base_dir}/videoinfo.navigate-dir-dat

    clear

    #  read last find total file count
    read -r searchtotal < ${base_dir}/videoinfo.lastsearchtotal

    # save date and time of last find
    stat -c '%y' ${base_dir}/videoinfo.findwork > ${base_dir}/videoinfo.lastfindtime

    # line below  strip tha last 17 characters from <stat> time of file: ${base_dir}/videoinfo.lastfindtime
    cat ${base_dir}/videoinfo.lastfindtime | awk '{ print substr( $0, 1, length($0)-17 ) }' | cut -c 4- > ${base_dir}/videoinfo.time
    mv ${base_dir}/videoinfo.time ${base_dir}/videoinfo.lastfindtime

    #  if search total is any number
    if [[ "$searchtotal" = "" ]]; then
        dashj=$(echo "-")  # don't blink dash on home screen @ Play Number
        rm ${tmp_dir}/videoinfo-findwork.tmp 2>/dev/null
        rm ${tmp_dir}/videoinfo-number-findwork.tmp 2>/dev/null

        # clear search results
        echo "" > ${base_dir}/videoinfo.lastsearchtotal
        echo "" > ${base_dir}/videoinfo.lastfindstring
        echo "" > ${base_dir}/videoinfo.lastfinddir

    else
        #####dashj=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")  # blink dash on home screen @ Play Number
        dashj=$(echo "~")

        # cat ${base_dir}/videoinfo.findwork

        #  REMOVE BLANK LINES
        sed '/^$/d' ${base_dir}/videoinfo.findwork > ${tmp_dir}/videoinfo-findwork.tmp 2>/dev/null

        # REMOVE PATH ONLY LEAVING FILENAME
        sed 's/.*\///' ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-number-findwork.tmp2 2>/dev/null

        # CREATE NUMBERED lIST
        sed '/./=' ${tmp_dir}/videoinfo-number-findwork.tmp2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo-number-findwork.tmp 2>/dev/null
        rm ${tmp_dir}/videoinfo-number-findwork.tmp2 2>/dev/null
        cat ${tmp_dir}/videoinfo-number-findwork.tmp  # display numbered find results    

        echo      
        echo "Dir: "$(cat ${base_dir}/videoinfo.lastfinddir 2>/dev/null) # display last directory that last find was run from
        echo "Date: "$(cat ${base_dir}/videoinfo.lastfindtime 2>/dev/null) # display last find time
        echo "Search: "$(cat ${base_dir}/videoinfo.lastfindstring 2>/dev/null)  # display last find string that was used
        echo "Results: ""$searchtotal"  # number of files found
    fi
    # LOAD DEFAULT DIRECTORIES
    read -r dir1 < ${base_dir}/videoinfo.tv-dir 2> /dev/null
    read -r dir2 < ${base_dir}/videoinfo.movies-dir 2> /dev/null
    read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null
    read -r dir4 < ${base_dir}/videoinfo.parent-dir 2> /dev/null
    read -r dir5 < ${base_dir}/videoinfo.dir-at-exit 2> /dev/null

    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

    ##################################################################################
    ##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
    ################################################################################## 

    # DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

    # DEFAULT DIR NUMBER 1 FORMAT
    dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
    # DEFAULT DIR NUMBER 2 FORMAT
    dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
    # DEFAULT DIR NUMBER 3 FORMAT
    dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
    # DEFAULT DIR NUMBER 4 FORMAT
    dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
    # DEFAULT DIR NUMBER 5 FORMAT
    dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
    # NO MATCH ALL LESS BOLD
    dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
    # FORMAT PWD NAME FOR COMPARISON
    echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
    cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
    rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

    # FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
    echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
    cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
    rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

    # FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
    echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
    cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
    rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

    # FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
    echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
    cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
    rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

    # FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
    echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
    cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
    rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

    # FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
    echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
    cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
    rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
    # LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

    read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
    read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
    read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
    read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
    read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
    read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
    # DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

    if [[ "$controldir" = "$dir5display" ]]; then 
        [[ "$dir5display" = "$dir1display" ]] && dirdisp="$dirdisplay1"
        [[ "$dir5display" = "$dir2display" ]] && dirdisp="$dirdisplay2"
        [[ "$dir5display" = "$dir3display" ]] && dirdisp="$dirdisplay3"
        [[ "$dir5display" = "$dir4display" ]] && dirdisp="$dirdisplay4"
    fi

    # DEFAULT DIR 5 DISPLAY
    if [[ "$controldir" = "$dir5display" ]]; then
        # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
        dirdisp="$dirdisplay5"
    else
        # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
        dirdisp="$dirdisplayno"
    fi 

    # DEFAULT DIR 1  DISPLAY
    [[ "$controldir" = "$dir1display" ]] && dirdisp="$dirdisplay1"
    # DEFAULT DIR 2  DISPLAY
    [[ "$controldir" = "$dir2display" ]] && dirdisp="$dirdisplay2"
    # DEFAULT DIR 3  DISPLAY
    [[ "$controldir" = "$dir3display" ]] && dirdisp="$dirdisplay3"
    # DEFAULT DIR 4  DISPLAY
    # if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
    [[ "$controldir" = "$dir4display" ]] && dirdisp="$dirdisplay4"

    ################################################################################
    ##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
    ################################################################################
    # CHECKING FOR VIDEOS IN CURRENT DIRECTORY.  if video(s) exist:  the dash @ Play Directory will blink on the home screen
    dovideosexist=$(find_supported_files --count)

    if [[ $dovideosexist -ne 0 ]]; then 
        dash=$(echo "~")  
    else
        dash=$(echo "-")  
    fi
    # if [[ "$searchtotal" = "" ]]; then
    #      :
    #  else
    #      echo
    #      echo "Copy 1 above result to clipboard then press enter"
    # fi

    echo
    echo "Directory: ""$PWD"
    #echo "Clipboard: ""$pasteclip"

    ##################################################################################################################################################

    #                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

    ##################################################################################################################################################

    # the 2 lines of below code are creating two new variables for the following loop.
    # 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
    # 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

    # for main if loop - to look for <http>
    grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

    # for nested if loop - to look for </>
    grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

    # the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
    # If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
    # If it isn't <http>  the ytdlp loop will be skipped

    if [[ "$grabpaste" = "http" ]]; then
        echo "Clipboard: ""$pasteclip"
    fi
    if [[ "$grabpaste" = "http" ]]; then
        read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
        ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

        if [[ "$ytdlpconfirm" = "" ]]; then

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
            #________________x________________________________________ _________________________________________________________
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " $der $viv4      Enter - Update Clipboard Display                "$dirdisp" - Default Dirs"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " f - Find              n - Navigate Tree     p - Play Clipboard     d "$dash" Play Directory     y - Yt-dlp     e - Exit"
            echo " a - Show All          l - Last Download     s - View Playlist      o "$dashj" Autoplay Line      i "$dashj" Info       z - Set" 
            echo " c - Clear Results     v - Played List       k "$dashj" Playlist Add       j "$dashj" Play Line          x - Clrclp     h - Help"
            echo " m - More Options"
            echo         
        else  # yt-dlp extracted a filename
            echo
            echo "YT-DLP Confirmed: "$ytdlpconfirm""
            echo
            echo "Download Directory: $dirsaved"  # dislpay default download directory
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " $der $viv4      Enter - Update Clipboard Display                "$dirdisp" - Default Dirs"
            echo "___________________________________________________________________________________________________________________"
            echo

            echo -e " f - Find              n - Navigate Tree     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m     d "$dash" Play Directory     y - Yt-dlp     e - Exit"

            echo " a - Show All          l - Last Download     s - View Playlist      o "$dashj" Autoplay Line      i "$dashj" Info       z - Set" 
            echo " c - Clear Results     v - Played List       k "$dashj" Playlist Add       j "$dashj" Play Line          x - Clrclp     h - Help"
            echo " m - More Options"
            echo                                                             
        fi
    else

        if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " $der $viv4      Enter - Update Clipboard Display                "$dirdisp" - Default Dirs"
            echo "___________________________________________________________________________________________________________________"
            echo

            echo -e " f - Find              n - Navigate Tree     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m     d "$dash" Play Directory     y - Yt-dlp     e - Exit"

            echo " a - Show All          l - Last Download     s - View Playlist      o "$dashj" Autoplay Line      i "$dashj" Info       z - Set" 
            echo " c - Clear Results     v - Played List       k "$dashj" Playlist Add       j "$dashj" Play Line          x - Clrclp     h - Help"
            echo " m - More Options"
            echo                                                             

        else  # file does not exist

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo 
            echo " $der $viv4      Enter - Update Clipboard Display                "$dirdisp" - Default Dirs"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " f - Find              n - Navigate Tree     p - Play Clipboard     d "$dash" Play Directory     y - Yt-dlp     e - Exit"
            echo " a - Show All          l - Last Download     s - View Playlist      o "$dashj" Autoplay Line      i "$dashj" Info       z - Set" 
            echo " c - Clear Results     v - Played List       k "$dashj" Playlist Add       j "$dashj" Play Line          x - Clrclp     h - Help"
            echo " m - More Options"
            echo         
        fi
    fi

    echo -en " Enter Option: "
    read -r -n1 optionf
}

while true; do
    menuf
    case $optionf in
        h)  # HELP
            #clear
            less ${base_dir}/videoinfo.help  # This help file is recreated on every start
        ;;    
        e)   # EXIT  
            echo "$PWD" > ${base_dir}/videoinfo.dir-at-exit  # SAVE DIRECTORY AT EXIT
        
            read -r lsearch < ${base_dir}/videoinfo.lastsearch-set  # load last search setting

            if [[ "$lsearch" = 1 ]]; then
                :
            fi

            if [[ "$lsearch" = 2 ]]; then
                
                ######### CLEAR FIND RESULTS ##########
                echo " " > ${base_dir}/videoinfo.lastsearchtotal
                echo " " > ${base_dir}/videoinfo.lastfindstring
                echo " " > ${base_dir}/videoinfo.lastfinddir

                # CREATE FIND RESULT MESSAGE THAT THERE ARE NO STORED FINDS
                #echo "                                                                                                                 " > ${base_dir}/videoinfo.findwork
                #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                #echo "Select find to search for files.                                                                                 " >> ${base_dir}/videoinfo.findwork
                #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork     
                touch ${base_dir}/videoinfo.findwork
            fi
            if [[ "$lsearch" = 3 ]]; then
                menuq() {
                    clear
                    echo -e "\n"
                    echo
                    echo "___________________________________________________________________________________________________________________"  
                    echo
                    echo " $der >>> LAST SEARCH"
                    echo "___________________________________________________________________________________________________________________" 
                    echo        
                    echo -en " 1 - Save Search Results     2 - Clear Search Results "
                    read -r -n1 optionq
                    echo
                }

                while true; do
                    menuq
                    case $optionq in
                        1)  # DO NOTHING SEARCH IS ALREADY SAVED
                            break
                        ;;
                        2)
                            ######### CLEAR FIND RESULTS ##########
                            echo " " > ${base_dir}/videoinfo.lastsearchtotal
                            echo " " > ${base_dir}/videoinfo.lastfindstring
                            echo " " > ${base_dir}/videoinfo.lastfinddir

                            # CREATE FIND RESULT MESSAGE THAT THERE ARE NO STORED FINDS
                            #echo "                                                                                                                 " > ${base_dir}/videoinfo.findwork
                            #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                            #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                            #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                            #echo "Select find to search for files.                                                                                 " >> ${base_dir}/videoinfo.findwork
                            #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork     

                            touch ${base_dir}/videoinfo.findwork
                            break;;

                        *)

                    esac
                done
            fi

            clear
            echo -e "\n"
            echo
            echo "___________________________________________________________________________________________________________________"  
            echo
            echo " $der >>> EXIT"
            echo "___________________________________________________________________________________________________________________" 
            echo
            echo
            echo " Directory state SAVED for next run:" "$PWD"
            sleep .7

            break
        ;;
        o)
            ##################################################################################################################################################
            ###########################   AUTOPLAY LINE  o   <HOME>  #########################################################################################
            ##################################################################################################################################################

            if [[ -f ${tmp_dir}/videoinfo-findwork.tmp ]]; then
                echo
                echo
                read -r -p " Autoplay Line: " linenumber  # waiting fot user input

                tail -n +"$linenumber" ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-home-autoplay.tmp 2>/dev/null
                input="$HOME""/.config/videoinfox/tmp/videoinfo-home-autoplay.tmp"

                OLDIFS=$IFS
                IFS=$'\n'

                for line in $(cat "$input" 2>/dev/null); do
                    clear
                    echo
                    echo "___________________________________________________________________________________________________________________"
                    echo
                    echo " ""$der"" >>> SEARCH RESULTS >>> AUTOPLAY LINE" 
                    echo
                    echo " [PLAY]>" "$line"
                    echo "___________________________________________________________________________________________________________________"
                    echo

                    get_file_stats "${line}"
                    
                    echo
                    echo
                    echo " Video Player Controls:"
                    echo                             
                    echo " - Fullscreen Toggle: f"
                    echo
                    echo " - Play/Pause Toggle: space bar"
                    echo
                    echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
                    echo
                    echo " - Quit: q"      
                    echo -e "\n"

                    ffplay -fs -autoexit "$line" 2> /dev/null

                    echo " To bypass the 3 second wait press enter with no entry"
                    echo
                    echo -e "\033[5m 3 seconds remaining to quit Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
                    echo 
                    read -t 3 -p " Press any key then press enter to quit : " playdir
                        
                    # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
                    if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                            break                                                   # if enter is pressed without any input the next video will play
                    fi
                done
 
                rm ${tmp_dir}/videoinfo-home-autoplay.tmp 2> /dev/null
                IFS=$OLDIFS

                else
                    echo
                    echo
                    echo " Select Show All or use Find to acess this feature . . ."
                    sleep 1.7
                fi

            ;;
            j)
                ##################################################################################################################################################
                ###########################   PLAY LINE  j   <HOME>  #############################################################################################
                ##################################################################################################################################################

                if [[ -f ${tmp_dir}/videoinfo-findwork.tmp ]]; then
                    echo
                    echo
                    read -r -p " Play Line: " linenumber  # waiting fot user input

                    # create file moving selected line number to the top
                    tail -n +"$linenumber" ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null
                    
                    # read first line of file for play
                    read playnumber < ${tmp_dir}/videoinfo-findwork-playnumber.tmp

                    if [[ ! -z "$playnumber" ]]; then
                        clear
                        echo
                        echo "___________________________________________________________________________________________________________________"
                        echo
                        echo " ""$der"" >>> SEARCH RESULTS >>> PLAY LINE" 
                        echo
                        echo " [PLAY]>" "$playnumber"
                        echo "___________________________________________________________________________________________________________________"
                        echo

                        get_file_stats "${playnumber}"
                        echo
                        echo
                        echo " Video Player Controls:"
                        echo                             
                        echo " - Fullscreen Toggle: f"
                        echo
                        echo " - Play/Pause Toggle: space bar"
                        echo
                        echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
                        echo
                        echo " - Quit: q"      
                        echo -e "\n"
                        echo " This screen will exit when the video player is closed."
                        echo

                        # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
                        getfilenameonly=$(echo "$playnumber" |  awk -F '/' '{print $NF}')  

                        notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"      

                        echo "$playnumber" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
                        ffplay -fs -autoexit "$playnumber" 2>/dev/null  # play video
                        rm ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null

                    fi
                else
                    echo
                    echo
                    echo " Select Show All or use Find to acess this feature . . ."
                    sleep 1.7
                fi
            ;;
            n)
                ##################################################################################################################################################
                ###########################   (@NAVIGATE TREE)  n  ###############################################################################################
                ##################################################################################################################################################

                pasteclip2=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content   save to restore on option quit
                echo "" | xclip -sel clip  # clearing the clipboard
                navtree() {
                    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                    if [[ ! -d "$pasteclip" ]]; then
                        echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
                        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
                    fi
                    clear

                    # recursive list of directories for the user: enter line number to change to that directory
                    ####find "$PWD" -type d -iname "*" | sort -u 2>/dev/null

                    find "$PWD" -type d -iname "*" | sort -u > ${tmp_dir}/nt-list.tmp 2>/dev/null
                    # NUMBER THE LIST
                    sed '/./='  ${tmp_dir}/nt-list.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/nt-list-number.tmp 2>/dev/null

                    cat ${tmp_dir}/nt-list-number.tmp
                    # recursive number of directories found
                    ttotal=$(find  "$PWD" -type d -iname "*" 2>/dev/null | wc -l)   

                    notify-send "Videoinfox is done processing: Directory Tree" "Total Directories Found: "$ttotal" " # GUI Notification.

                    # recursive number of files found
                    ttotalnum=$(find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) 2>/dev/null | wc -l)
                    ##################################################################################
                    ##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
                    ################################################################################## 

                    # DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

                    # DEFAULT DIR NUMBER 1 FORMAT
                    dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
                    # DEFAULT DIR NUMBER 2 FORMAT
                    dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
                    # DEFAULT DIR NUMBER 3 FORMAT
                    dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
                    # DEFAULT DIR NUMBER 4 FORMAT
                    dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
                    # DEFAULT DIR NUMBER 5 FORMAT
                    dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
                    # NO MATCH ALL LESS BOLD
                    dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
                    # FORMAT PWD NAME FOR COMPARISON
                    echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
                    cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
                    rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

                    # FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
                    echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
                    cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
                    rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

                    # FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
                    echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
                    cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
                    rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

                    # FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
                    echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
                    cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
                    rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

                    # FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
                    echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
                    cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
                    rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

                    # FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
                    echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
                    cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
                    rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
                    # LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

                    read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
                    read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
                    read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
                    read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
                    read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
                    read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
                    # DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

                    if [[ "$controldir" = "$dir5display" ]]; then 
                        [[ "$dir5display" = "$dir1display" ]] && dirdisp="$dirdisplay1"
                        [[ "$dir5display" = "$dir2display" ]] && dirdisp="$dirdisplay2"
                        [[ "$dir5display" = "$dir3display" ]] && dirdisp="$dirdisplay3"
                        [[ "$dir5display" = "$dir4display" ]] && dirdisp="$dirdisplay4"
                    fi

                    # DEFAULT DIR 5 DISPLAY
                    if [[ "$controldir" = "$dir5display" ]]; then
                        # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
                        dirdisp="$dirdisplay5"
                    else
                        # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
                        dirdisp="$dirdisplayno"
                    fi 

                    # DEFAULT DIR 1  DISPLAY
                    [[ "$controldir" = "$dir1display" ]] && dirdisp="$dirdisplay1"
                    # DEFAULT DIR 2  DISPLAY
                    [[ "$controldir" = "$dir2display" ]] && dirdisp="$dirdisplay2"
                    # DEFAULT DIR 3  DISPLAY
                    [[ "$controldir" = "$dir3display" ]] && dirdisp="$dirdisplay3"
                    # DEFAULT DIR 4  DISPLAY
                    # if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
                    [[ "$controldir" = "$dir4display" ]] && dirdisp="$dirdisplay4"

                    ################################################################################
                    ##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
                    ################################################################################
                    ########## blinking routines for display ##########

                    # not blinking Play Directory
                    playdir1=$(echo "Play Directory")
                    # blinking Play Directory
                    playdir2=$(echo -e "\033[5mPlay Directory\033m\033[0m\033[5m\033[5m\033[0m")

                    # not blinking dash
                    dash0=$(echo "-")
                    # blinking dash
                    dash1=$(echo "~")
                    # get file count of videos one directory deep for blinking   Play Directory
                    blinkit=$(find_supported_files --count)

                    # if find results are zero goto then
                    if [[ "$blinkit" = 0 ]]; then
                        blinkit2="$playdir1"  # zero files. non bliking  Playdirectory
                        bdash="$dash0"
                    else
                        blinkit2="$playdir2" # not zero files. blinking  Play Directory
                        bdash="$dash1"
                    fi
                    # not blinking
                    changedir1=$(echo "Change Directory")
                    # blinking
                    changedir2=$(echo -e "\033[5mChange Directory\033m\033[0m\033[5m\033[5m\033[0m")

                    # if directory exists goto then
                    if [[ -d "$pasteclip" ]]; then
                        changedir3="$changedir2"  # if the directory exists, blinking  Change Directory
                    else
                        changedir3="$changedir1"  # if the directory doesn't exist, non blinking  Change Directory
                    fi
                    ########## end blinking routines ################## 
                    echo
                    echo "Treetop:" "$grabdirfornav2"
                    echo "Total Directories: "$ttotal" "
                    echo "Total Video Files:" "$ttotalnum"                                                                                                            
                    echo
                    echo "Current Directory:" "$PWD"
                    echo "Video Files:" "$blinkit"
                    # echo
                    # echo "Clipboard:" "$pasteclip"
                    echo "___________________________________________________________________________________________________________________"
                    echo  
                    echo " ""$der"" >>> NAVIGATE TREE                                                     "$dirdisp" - Default Dirs"
                    echo "___________________________________________________________________________________________________________________" 
                    echo
                    #echo " c - "$changedir3"     a "$bdash" Show All     d "$bdash" Play Directory     n - Change Treetop                     q - Quit"
                    echo " c - Change Directory     a "$bdash" Show All     d "$bdash" Play Directory     n - Change Treetop                      q - Quit"
                    echo " u - Up One Level"
                    echo " t - Treetop"
                    echo   
                    echo -en " Enter Option: "
                    read -r -n1 option
                    echo
                }
  
                while true; do
                    navtree
                    case $option in
                        q)  # QUIT
                            ##############################     cd "$grabdirfornav2" &>/dev/null   # restore directory
                            echo "" | xclip -sel clip  # clearing the clipboard
                            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
                            break
                        ;;
                        1)  # CD DIRECTORY TO TV    
                            grabdirfornav2="$dir1"
                            cd "$dir1"
                        ;;
                        2)  # CD DIRECTORY TO MOVIES
                            grabdirfornav2="$dir2"
                            cd "$dir2" 
                        ;;
                        3)  # CHANGE DIRECTORY TO DOWNLOADS
                            grabdirfornav2="$dirsaved"
                            cd "$dirsaved" 
                        ;;
                        4)  # CHANGE DIRECTORY TO EXTRA   
                            grabdirfornav2="$dir4"
                            cd "$dir4" 
                        ;;
                        5)  # CHANGE DIRECTORY TO LAST EXIT
                            grabdirfornav2="$dir5"
                            cd "$dir5" 
                        ;;
                        u)  # UP ONE LEVEL 
                            if [[ "$grabdirfornav2" = "$PWD" ]]; then
                                echo
                                echo " At treetop. Can't go any higher . . ."
                                sleep .50
                            else
                                cd .. &>/dev/null
                            fi 
                        ;;
                        t)  # TREE TOP
                            cd "$grabdirfornav2" &>/dev/null
                        ;;
                        c)  # CHANGE DIRECTORY
                            # GETTING LINECOUNT
                            linecount=$(wc -l ${tmp_dir}/nt-list.tmp | cut -d' ' -f1)

                            echo
                            read -r -p " Enter line number to change directory: " linenumber  # waiting fot user input
                            if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                                :
                            else  # ENTRY IS A NUMBER
                                if [[ $linenumber -gt $linecount ]]; then 
                                    echo
                                    echo " Number out of range . . ."
                                    sleep .9
                                else
                                    tail -n +"$linenumber" ${tmp_dir}/nt-list.tmp > ${tmp_dir}/nt-list.tmp2 2>/dev/null
                                    OLDIFS=$IFS
                                    IFS=$'\n'
                                    read line < ${tmp_dir}/nt-list.tmp2
                                    cd "$line" 2> /dev/null
                                    IFS=$OLDIFS
                                fi
                            fi
                        ;;
                        d)
                            ####################################################################################################################################
                            # (@PLAY DIRECTORY) NAVIGATE TREE  #################################################################################################
                            ####################################################################################################################################

                            # WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
                            find_supported_files "${tmp_dir}/videoinfox.navtree-play-directory-apa"

                            #  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
                            if file_contains '^/' ${tmp_dir}/videoinfox.navtree-play-directory-apa; then
                                #  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
                                moddedplayedlist="${HOME}/.config/videoinfox/tmp/videoinfox.navtree-play-directory-apa"

                                #  CREATE TEMP FILE NEEDED FOR LOOP 
                                touch "${tmp_dir}/videoinfox.navtree-play-directory-apa2"

                                #  #  START WRITING
                                while read -r line; do
                                    if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
                                        echo "$line" >> "${tmp_dir}/videoinfox.navtree-play-directory-apa2"
                                    fi
                                done < "${moddedplayedlist}"
                                #  DONE WRITING ONLY VALID FILES

                                #  REMOVE BLANK LINES
                                squash "${tmp_dir}/videoinfox.navtree-play-directory-apa2" 2>/dev/null

                                #  MOVE apa2 BACK TO apa
                                mv "${tmp_dir}/videoinfox.navtree-play-directory-apa2" "${tmp_dir}/videoinfox.navtree-play-directory-apa" 2>/dev/null

                                #  CREATE FILE NEEDED FOR LOOP 
                                touch "${tmp_dir}/videoinfox.navtree-play-directory-apa2"

                                #  WRITE FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
                                write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfox.navtree-play-directory-apa2"

                                #  REMOVE BLANK LINES
                                squash "${tmp_dir}/videoinfox.navtree-play-directory-apa2" 2>/dev/null

                                #  MOVE apa2 BACK TO apa
                                cp ${tmp_dir}/videoinfox.navtree-play-directory-apa2 ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

                                # REMOVE PATH ONLY LEAVING FILENAME
                                sed -i 's/.*\///' ${tmp_dir}/videoinfox.navtree-play-directory-apa2

                                # NUMBER THE LIST
                                sed '/./='  ${tmp_dir}/videoinfox.navtree-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null

                            
                            else #  NO LINES START WITH A SLASH /   remove empty files
                                rm ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null
                                rm ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null
                                rm ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
                                rm ${tmp_dir}/videoinfox.navtree-play-directory-apa-work 2>/dev/null    
                            fi
                            ################clear

                            if [[ -f ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list ]]; then
                                cat ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
                            else
                                echo
                                echo " No video files in the current directory . . ."
                                sleep 1.7
                            fi
                            linenumber=1

                            tail -n +"$linenumber" ${tmp_dir}/videoinfox.navtree-play-directory-apa > ${tmp_dir}/videoinfox.navtree-play-directory-apa.tmp 2>/dev/null
                            mv ${tmp_dir}/videoinfox.navtree-play-directory-apa.tmp ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

                            OLDIFS=$IFS
                            IFS=$'\n'

                            for line in $(cat "$input" 2>/dev/null); do
                                clear
                                echo
                                echo "___________________________________________________________________________________________________________________"
                                echo
                                echo " ""$der"" >>> NAVIGATE TREE >>> PLAY DIRECTORY" 
                                echo
                                echo " [PLAY]>" "$line"
                                echo "___________________________________________________________________________________________________________________"
                                echo

                                get_file_stats "${line}"
                                
                                echo
                                echo
                                echo " Video Player Controls:"
                                echo                             
                                echo " - Fullscreen Toggle: f"
                                echo
                                echo " - Play/Pause Toggle: space bar"
                                echo
                                echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
                                echo
                                echo " - Quit: q"      
                                echo -e "\n"

                                ffplay -fs -autoexit "$line" 2> /dev/null

                                echo " To bypass the 3 second wait press enter with no entry"
                                echo
                                echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
                                echo 
                                read -t 3 -p " Press any key then press enter to quit : " playdir
                                    
                                    # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
                                    if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                                            break                                                   # if enter is pressed without any input the next video will play
                                    fi
                            done
                            
                            IFS=$OLDIFS

                            rm ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null
                            rm ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null
                            rm ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
                            rm ${tmp_dir}/videoinfox.navtree-play-directory-apa-work 2>/dev/null 

                        ;;
                        n)
                            ####################################################################################################################################
                            # CHANGE TREETOP (NAVIGATE TREE)  ##################################################################################################
                            ####################################################################################################################################

                            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
                            clear
                            echo
                            echo "Directory: ""$PWD"
                            echo "Clipboard: ""$pasteclip"
                            echo "___________________________________________________________________________________________________________________"
                            echo
                            echo " $ver >>> CHANGE TREETOP"
                            echo "___________________________________________________________________________________________________________________"
                            echo
                            echo " No quotations needed for paths with spaces. Case sensative."
                            echo 
                            echo " Enter directory or paste directory if in clipboard."
                            echo
                            read -r -p " " specifydir  # waiting fot user input - the directory you want to chang to 
                                
                                if [[ -z "$specifydir" ]]; then
                                    echo " Nothing was entered . . ."
                                    sleep .75
                                else
                                    if [[ -d "$specifydir" ]]; then
                                        echo
                                        grabdirfornav2="$specifydir"
                                        cd "$specifydir"   # change the directory
                                        echo " Treetop changed to: $PWD"  # <pwd>  print current working directory to the screen
                                        sleep 1.5                   
                                    else
                                        echo
                                        echo " No such directory . . ."
                                        sleep 1.5                   
                                    fi
                                fi       
                            echo
                        ;;
         
         a)
            ####################################################################################################################################
            # SHOW ALL (NAVIGATE TREE)  ########################################################################################################
            ####################################################################################################################################

            #checking for videos in the current directory.  if no videos exist,   Play Directory   won't execute
            dovideosexist=$(find_supported_files --count)
            if [[ $dovideosexist -ne 0 ]]; then RUN PLAY LINE

                ntplaynum() {
                    # WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
                    find_supported_files > "${tmp_dir}/videoinfox.nt-play-directory-apa"

                    #  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
                    if file_contains '^/' ${tmp_dir}/videoinfox.nt-play-directory-apa; then

                        #  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
                        moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfox.nt-play-directory-apa"

                        #  CREATE TEMP FILE NEEDED FOR LOOP 
                        touch ${tmp_dir}/videoinfox.nt-play-directory-apa2

                        #  #  START WRITING
                        while read -r line; do
                            if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
                                    echo "$line" >> ${tmp_dir}/videoinfox.nt-play-directory-apa2  
                            fi        
                        done < "${moddedplayedlist}"

                        #  REMOVE BLANK LINES
                        squash ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null

                        #  MOVE apa2 BACK TO apa
                        mv ${tmp_dir}/videoinfox.nt-play-directory-apa2 ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                        #  CREATE FILE NEEDED FOR LOOP 
                        touch ${tmp_dir}/videoinfox.nt-play-directory-apa2  

                        #  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
                        write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfox.nt-play-directory-apa2"

                        #  REMOVE BLANK LINES
                        squash ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null

                        #  MOVE apa2 BACK TO apa
                        cp ${tmp_dir}/videoinfox.nt-play-directory-apa2 ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                        # REMOVE PATH ONLY LEAVING FILENAME
                        sed -i 's/.*\///' ${tmp_dir}/videoinfox.nt-play-directory-apa2

                        # NUMBER THE LIST
                        sed '/./='  ${tmp_dir}/videoinfox.nt-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null

        
                    else #  NO LINES START WITH A SLASH /   remove empty files
                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null
                        rm ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa-work 2>/dev/null
                    fi
                    clear

                    if [[ -f ${tmp_dir}/videoinfox.numbered-nt-play-directory-list ]]; then
                        cat ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
                    else
                        echo
                        echo " No video files in the current directory . . ."
                    fi

                    echo
                    echo "Directory: ""$PWD"
                    echo "___________________________________________________________________________________________________________________"
                    echo  
                    echo " $der >>> NAVIGATE TREE >>> SHOW ALL"
                    echo "___________________________________________________________________________________________________________________" 
                    echo
                    echo " o - Autoplay Line     s - View Playlist                                                                  q - Quit"
                    echo " j - Play Line         k - Playlist Add"
                    echo " i - Info              z - Directory To Playlist"
                    echo
                    echo -en " Enter Option: "
                    read -r -n1 optionaplist
                }

                while true; do
                    ntplaynum
                    case $optionaplist in
                        q) # QUIT
                            rm ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
                            rm ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null
                            rm ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
                            rm ${tmp_dir}/videoinfox.nt-play-directory-apa-work 2>/dev/null 
                            break
                        ;;
                        z) # DIRECTORY TO PAYLIST

                            echo
                            echo
                            echo " If any dots are entered, they will be stripped from the playlist name."
                            echo " If a space is used as the first character, it will be stripped from the playlist name."
                            echo " Spaces can be used after the first character of the playlist name."
                            echo
                            read -r -p " Create Playlist: " createpl1  # waiting fot user input. grabbing new filename

                            # Strip out any dots from user entry
                            echo "$createpl1" > ${tmp_dir}/plremovedot.tmp
                            sed -i -e 's/\.//g' ${tmp_dir}/plremovedot.tmp
                            read createpl < ${tmp_dir}/plremovedot.tmp
                            rm ${tmp_dir}/plremovedot.tmp

                            if [[ -z "$createpl" ]]; then
                                echo
                                echo " Nothing was entered . . ."
                                sleep .75
                            else
                                if [[ -f ${base_dir}/playlists/vplaylist."$createpl" ]]; then
                                        echo
                                        echo " File already exists . . ."
                                        sleep .75
                                else

                                    plname="$HOME/.config/videoinfox/playlists/vplaylist.""$createpl"  # add user input as file extension

                                    # WRITE DIRECTORY TO ENTERED PLAYLIST
                                    cat ${tmp_dir}/videoinfox.nt-play-directory-apa > "$plname"

                                    touch "$HOME"/.config/videoinfox/playlists/"$createpl1".last-autoplay

                                    echo
                                    echo " Playlist Created: "$plname""
                                    echo
                                    sleep 1.7

                                fi
                            fi
                        ;; 
                        i)  # INFO - <HOME>
                    
                            if [[ -f "$pasteclip" ]]; then
                                pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
                                echo
                                echo
                                echo " ""$pasteclip"
                                echo  

                                get_file_stats "${pasteclip}"

                                echo
                                read -r -p " Press enter to Continue" 

                            else

                                if [[ -f ${tmp_dir}/videoinfox.nt-play-directory-apa ]]; then
                                echo
                                echo
                                read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

                                # create file moving selected line number to the top
                                tail -n +"$linenumber" ${tmp_dir}/videoinfox.nt-play-directory-apa > ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp 2>/dev/null
                                mv ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
                                # read first line of file for play
                                read playnumber < ${tmp_dir}/videoinfox.nt-play-directory-apa

                                    if [[ ! -z "$playnumber" ]]; then
                                        echo
                                        echo "$playnumber"
                                        echo
            
                                        get_file_stats "${playnumber}"

                                        echo
                                        read -r -p " Press enter to Continue" 
                                        ######rm ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null

                                    fi

                                else
                                    echo
                                    echo
                                    echo " Select Show All or use Find to acess this feature . . ."
                                    sleep 1.7
                                    fi

                             fi

                        ;;
                        j)
                            ###########################################################################################################################
                            # PLAY LINE - SHOW ALL (NAVIGATE TREE)  ###################################################################################
                            ###########################################################################################################################

                            #checking for videos in the current directory.  if no videos exist,   Play Directory   won't execute
                            dovideosexist=$(find_supported_files --count)
                            if [[ $dovideosexist -ne 0 ]]; then RUN PLAY LINE

                                # WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
                                find_supported_files > "${tmp_dir}/videoinfox.nt-play-directory-apa"

                                #  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
                                if ! file_contains '^/' "${tmp_dir}/videoinfox.nt-play-directory-apa"; then
                                    {
                                        rm "${tmp_dir}/videoinfox.nt-play-directory-apa"
                                        rm "${tmp_dir}/videoinfox.nt-play-directory-apa2"
                                        rm "${tmp_dir}/videoinfox.numbered-nt-play-directory-list"
                                        rm "${tmp_dir}/videoinfox.nt-play-directory-apa-work"
                                    } 2>/dev/null
                                    return
                                fi
                                #  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
                                moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfox.nt-play-directory-apa"

                                #  CREATE TEMP FILE NEEDED FOR LOOP 
                                touch ${tmp_dir}/videoinfox.nt-play-directory-apa2

                                #  #  START WRITING
                                while read -r line; do
                                    if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
                                        printf -- '%s\n' "$line" >> "${tmp_dir}/videoinfox.nt-play-directory-apa2"
                                    fi
                                done < "${moddedplayedlist}"

                                #  REMOVE BLANK LINES
                                squash ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null

                                #  MOVE apa2 BACK TO apa
                                mv ${tmp_dir}/videoinfox.nt-play-directory-apa2 ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                                #  CREATE FILE NEEDED FOR LOOP 
                                touch "${tmp_dir}/videoinfox.nt-play-directory-apa2"

                                #  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
                                write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfox.nt-play-directory-apa2"

                                #  REMOVE BLANK LINES
                                squash ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null

                                #  MOVE apa2 BACK TO apa
                                cp ${tmp_dir}/videoinfox.nt-play-directory-apa2 ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                                # REMOVE PATH ONLY LEAVING FILENAME
                                sed -i 's/.*\///' ${tmp_dir}/videoinfox.nt-play-directory-apa2

                                # NUMBER THE LIST
                                sed '/./='  ${tmp_dir}/videoinfox.nt-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null

                                # clear

                                if [[ ! -f ${tmp_dir}/videoinfox.numbered-nt-play-directory-list ]]; then
                                    echo
                                    echo " No videos in the current directory . . ."
                                fi
                                # GETTING LINECOUNT
                                linecount=$(wc -l ${tmp_dir}/videoinfox.nt-play-directory-apa | cut -d' ' -f1)

                                echo
                                echo
                                read -r -p " Play Line: " linenumber  # waiting fot user input
                                if [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                                    if [[ $linenumber -gt $linecount ]]; then 
                                        echo
                                        echo " Number out of range . . ."
                                        sleep .9
                                    else

                                        tail -n +"$linenumber" ${tmp_dir}/videoinfox.nt-play-directory-apa > ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp 2>/dev/null
                                        mv ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                                        OLDIFS=$IFS
                                        IFS=$'\n'

                                        read line < ${tmp_dir}/videoinfox.nt-play-directory-apa

                                        clear
                                        echo
                                        echo "___________________________________________________________________________________________________________________"
                                        echo
                                        echo " ""$der"" >>> NAVIGATE TREE >>> PLAY LINE" 
                                        echo
                                        echo " [PLAY]>" "$line"
                                        echo "___________________________________________________________________________________________________________________"
                                        echo

                                        get_file_stats "${line}"
                                        
                                        echo
                                        echo
                                        echo " Video Player Controls:"
                                        echo                             
                                        echo " - Fullscreen Toggle: f"
                                        echo
                                        echo " - Play/Pause Toggle: space bar"
                                        echo
                                        echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
                                        echo
                                        echo " - Quit: q"      
                                        echo -e "\n"

                                        echo "$line" >> ${base_dir}/videoinfo.playedlist  # write to the played list 
                                        ffplay -fs -autoexit "$line" 2> /dev/null
                                    
                                        IFS=$OLDIFS

                                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
                                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null
                                        rm ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
                                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa-work 2>/dev/null 
                                    fi
                                fi
                                ######esac
                                ######done

                            else
                                echo
                                echo " No video files in the current directory . . ."
                                sleep 1.7

                            fi

                        ;;
                        k)
                            ########################################################################################################################################
                            # SHOW ALL - PLAYLIST ADD (NAVIGATE TREE)  ############################################################################################
                            ########################################################################################################################################

                            #checking for videos in the current directory.  if no videos exist,   playlistaddnav Directory   won't execute
                            dovideosexist=$(find_supported_files --count)
                            if [[ $dovideosexist -ne 0 ]]; then  # IF VIDEOS EXIST IN THE CURRENT DIRECTORY 

                            ########################################################################################################################function ntplaylistaddnavnum {

                            # WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-playlistaddnav-directory-apa 
                            find_supported_files > "${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa"

                            #  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
                            if file_contains '^/' "${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa"; then
                                #  ASSIGN playlistaddnavED LIST TO VARIABLE: $moddedplaylistaddnavedlist 
                                moddedplaylistaddnavedlist="${HOME}/.config/videoinfox/tmp/videoinfox.nt-playlistaddnav-directory-apa"

                                #  playlistaddnavED LIST INPUT FOR LOOP
                                input="$moddedplaylistaddnavedlist"  

                                #  CREATE TEMP FILE NEEDED FOR LOOP 
                                touch ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2

                                #  #  START WRITING
                                while read -r line; do

                                if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
                                    echo "$line" >> ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2  
                                fi

                                done < "$input"
                                #  DONE WRITING ONLY VALID FILES
                                #  REMOVE BLANK LINES
                                squash ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 2>/dev/null

                                #  MOVE apa2 BACK TO apa
                                mv ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null

                                #  CREATE FILE NEEDED FOR LOOP 
                                touch ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2  

                                #  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
                                write_supported_list "${moddedplaylistaddnavedlist}" "${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2"

                                #  REMOVE BLANK LINES
                                squash ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 2>/dev/null

                                #  MOVE apa2 BACK TO apa
                                cp ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null

                                # REMOVE PATH ONLY LEAVING FILENAME
                                sed -i 's/.*\///' ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2

                                # NUMBER THE LIST
                                sed '/./='  ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 |
                                    sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list 2>/dev/null

                            
                            else #  NO LINES START WITH A SLASH /   remove empty files
                                rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null
                                rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 2>/dev/null
                                rm ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list 2>/dev/null
                                rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa-work 2>/dev/null    
                            fi
                            clear

                            if [[ -f ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list ]]; then
                                cat ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list 2>/dev/null
                            else
                                echo
                                echo " No videos in the current directory . . ."
                            fi
                            # REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
                            cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplnt.tmp 
                            read -r whatplnt < ${tmp_dir}/whatplnt.tmp
                            rm ${tmp_dir}/whatplnt.tmp

                            echo
                            read -r -p "Enter line number to add video to playlist $whatplnt: " linenumber  # waiting fot user input

                            tail -n +"$linenumber" ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa > ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa.tmp 2>/dev/null

                            #####
                            # GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
                            linecount=$(wc -l ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa | cut -d' ' -f1)
                            #####

                            mv ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa.tmp ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null

                            if [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                                if [[ ! -z "$linenumber" ]]; then
                                    if [[ $linenumber -gt $linecount ]]; then 
                                        echo
                                        echo "Number out of range . . ."
                                        sleep .9

                                    else

                                        OLDIFS=$IFS
                                        IFS=$'\n'

                                        read line < ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa

                                        if [[ ! -z "$linenumber" ]]; then
                                            echo "$line" >> ${base_dir}/videoinfo.playlist
                                            echo
                                            echo " ""$line" 
                                            echo
                                            echo " Added to Playlist . . ."
                                            sleep .25
                                        fi

                                    fi
                                fi
                            fi
                            
                            IFS=$OLDIFS

                            rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null
                            rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 2>/dev/null
                            rm ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list 2>/dev/null
                            rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa-work 2>/dev/null 
                                    
                            else
                                echo
                                echo " No video files in the current directory . . ."
                                sleep 1.7

                            fi

                            ;;
##################################################################################################################################################
s) #######################  @PLAYLIST - SHOW ALL (NAVIGATE TREE)  ################################################################################
##################################################################################################################################################

grabdir="$PWD"  # SAVE CURRENT DIRECTORY FOR RESTORE ON EXIT

cd ${base_dir}/playlists
menuvhome() {

squash ${base_dir}/videoinfo.playlist  # remove all blank lines

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if ! [[ "$grabclip" = "http" ]]; then
      if ! [[ -f "$pasteclip" ]]; then
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      # REMOVE DUPLICATES
      cat -n ${base_dir}/videoinfo.playlist | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist.tmp
      mv ${tmp_dir}/videoinfo.playlist.tmp ${base_dir}/videoinfo.playlist
  else
      touch ${base_dir}/videoinfo.playlist
fi


clear

cp ${base_dir}/videoinfo.playlist ${tmp_dir}/videoinfo.playlist-apa
#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
if file_contains '^/' "${tmp_dir}/videoinfo.playlist-apa"; then

#  ASSIGN PLAYLIST TO VARIABLE: $moddedplaylist 
moddedplaylist="$HOME""/.config/videoinfox/tmp/videoinfo.playlist-apa"

#  PLAYLIST INPUT FOR LOOP
input="$moddedplaylist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfo.playlist-apa2

#  #  START WRITING
while read -r line; do
   if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
           echo "$line" >> ${tmp_dir}/videoinfo.playlist-apa2  
   fi
done < "$input"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

# REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist-apa3

mv ${tmp_dir}/videoinfo.playlist-apa3 ${tmp_dir}/videoinfo.playlist-apa2

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfo.playlist-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplaylist}" "${tmp_dir}/videoinfox.playlist-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfo.playlist-apa2

# NUMBER THE LIST
sed '/./=' ${tmp_dir}/videoinfo.playlist-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
     rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null     
fi
clear
if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then
        cat ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        #dashit=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
        dashit=$(echo "~") #
   else
        dashit=$(echo "-") # 
        echo
        echo "Playlist Empty . . ."
fi

#cat ${base_dir}/videoinfo.playlist 

# check if directory ${base_dir}/playlists is empty.  if it is, set playlist to Default 
searchtotal=$(find "$PWD" -type f \( -iname "vplaylist.*" \) 2>/dev/null | wc -l)

if [[ "$searchtotal" = 0 ]]; then
      echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current             
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      read -r setplaylist < ${tmp_dir}/plread.tmp
      rm ${tmp_dir}/plread.tmp
      # GET CURRENT PLAYLIST
      read -r activeplaylist < ${base_dir}/videoinfo.playlist.current
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      # SAVE CURRENT PLAYLIST
      cp ${base_dir}/videoinfo.playlist "$activeplaylist"
     
  else
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      read -r setplaylist < ${tmp_dir}/plread.tmp

      rm ${tmp_dir}/plread.tmp
fi
##################################################################################################################################################

#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

#echo "Directory: ""$PWD"

if [[ "$grabpaste" = "http" ]]; then
      echo
      echo "Clipboard: ""$pasteclip"
fi
if [[ "$grabpaste" = "http" ]]; then
    read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
    ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

    if [[ "$ytdlpconfirm" = "" ]]; then

        echo "" | xclip -sel clip  # clearing out the clipboard
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

        # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
        #________________x________________________________________ _________________________________________________________
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " o "$dashit" Autoplay Line     l - Last Autoplay      c - Change Playlist     p - Play Clipboard                  q - Quit"
        echo " j "$dashit" Play Line"
        echo " i "$dashit" Info                                     d - Clear Playlist"
        echo           

    else 
        echo
        echo "YT-DLP Confirmed: "$ytdlpconfirm""
        echo
        echo "Download Directory: $dirsaved"  # dislpay default download directory
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
        echo " j "$dashit" Play Line"
        echo " i "$dashit" Info                                    d - Clear Playlist"
        echo                                                                                    
    fi
  else

    if [[ -f "$pasteclip" ]]; then
        echo      
        echo "Valid file in clipboard"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
        echo " j "$dashit" Play Line"
        echo " i "$dashit" Info                                    d - Clear Playlist"
        echo                                                                     

    else 

        echo "" | xclip -sel clip  # clearing out the clipboard
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " j - Play Line     o - Start Autoplay      c - Change Playlist     p - Play Clipboard                     q - Quit"
        echo " i - Info          l - Resume Autoplay     r - Remove Line"
        echo "                                           d - Clear Playlist                                             h - Help"
        echo                                                             
    fi
fi

echo -en " Enter Option: "
read -r -n1 optionv
}

        while true
        do
        menuvhome
        case $optionv in
    
        q)  # QUIT
        rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
        rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
        rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        cd "$grabdir"
        break;;

       
        h)
        echo
        echo
        echo " PLAYLIST LIST >>> HELP"        
        echo
        echo " Everytime Start Autoplay is used, it will write a new file for Resume Autoplay."
        echo " Run Start Autoplay first. Then use Resume Autoplay to continue watching where you left off."
        echo " Resume Autoplay will start with the last video that was playing when the play loop was quit."
        echo
        echo " Note: If the playlist is changed with Playlist Add or Remove Line after running Start Autoplay,"
        echo "       Resume Autoplay won't get updated with the changes until Start Autoplay is run again."
        echo
        read -p " Press enter to Continue"
        ;;
        o) # AUTOPLAY LINE  (HOME >>> PLAYLIST)

# SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Start Autoplay from line: " linenumber  # waiting fot user input

# 
tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      # COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done

# WRITE 2nd PLAYLIST FOR LAST AUTOPLAY OPTION . File: ${base_dir}/playlists/$playlistname.last-autoplay
tail -n +"$i" ${tmp_dir}/videoinfo.playlist-apa > "$setplaylist".last-autoplay

IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;

########################################
r)  # REMOVE LINE  (HOME >>> PLAYLIST)
########################################

# delete a line example to remove by pattern
#sed '\?^/mnt/MEDIA1/MOVIES/identity thief.mp4?d' videoinfo.playlist
# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplpld.tmp 
read -r whatplpld < ${tmp_dir}/whatplpld.tmp
rm ${tmp_dir}/whatplpld.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      :
  else
      touch ${base_dir}/videoinfo.playlist
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then

      clear
      cat ${tmp_dir}/videoinfo.number.play-list 2> /dev/null

      echo
      read -r -p "Enter line number to remove video from the playlist $whatplpld: " linenumber  # waiting fot user input

      # REMOVE BLANK LINES
      ######squash ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

      # GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
      linecount=$(wc -l ${tmp_dir}/videoinfo.playlist-apa 2> /dev/null | cut -d' ' -f1) # 

          if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                :

            else  # ENTRY IS A NUMBER

                if [[ -z "$linenumber" ]]; then
                      :

                  else

                      if [[ "$linenumber" = 0 ]]; then
                            :

                        else
      
                            if [[ $linenumber -gt $linecount ]]; then 
                                  echo
                                  echo "Number out of range . . ."
                                  sleep .9

                              else

                                  if [[ -z "$linenumber" ]]; then
                                        :

                                    else
                                        # DELETE LINE NUMBER
                                        sed -i "${linenumber}d" ${base_dir}/videoinfo.playlist 2> /dev/null 
                                        echo
                                        echo "Line deleted from the playlist . . ."
                                        sleep .25
                                  fi
                            fi
                      fi
               fi
         fi
fi

;;
###########################################################
l) # LAST AUTOPLAY - RESUME AUOTOPLAY (HOME >>> PLAYLIST)
###########################################################

# READ FIRST LINE TO DISPLAY VIDEO NAME BEFORE PLAY
read < $HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay resumedisplay
echo
echo
echo " Resume: ""$resumedisplay"
sleep 3

###### SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

OLDIFS=$IFS
IFS=$'\n'

input2=$HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay
for line in $(cat "$input2" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      ###### COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING FOR WRITE ON EXIT.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
tail -n +"$i" ${base_dir}/playlists/"$setplaylist".last-autoplay > ${base_dir}/playlists/pl-tmp
mv ${base_dir}/playlists/pl-tmp ${base_dir}/playlists/"$setplaylist".last-autoplay
IFS=$OLDIFS

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
        j) # PLAY LINE  (HOME >>> PLAYLIST)

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Play Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

read line < ${tmp_dir}/videoinfo.playlist-apa

if [[ -z "$line" ]

  then
      :

  else

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> PLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      echo " Screen will close after video player is quit."

      ffplay -fs -autoexit "$line" 2> /dev/null
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

fi

else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
       i)  # INFO - <PLAYLIST>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

get_file_stats "${pasteclip}"

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo.playlist-apa ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo.playlist-apa.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
get_file_stats "${playnumber}"

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null

                 fi

        else
            :

            fi

      fi

;;       

########################################################################################################################################################
          c)
          # CHANGE PLAYLIST
########################################################################################################################################################

function changepl {

#read -r savepl < ${base_dir}/videoinfo.playlist.current
#cp ${base_dir}/videoinfo.playlist "$savepl"

# cd ${base_dir}/playlists

# FIND PLAYLISTS
find "$PWD" -type f \( -iname "vplaylist.*" \) > ${base_dir}/videoinfo.playlist.dirlist

# SORT BACK INTO ORDER
sort -u ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist 

#  REMOVE BLANK LINES
sed '/^$/d' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist

# REMOVE PATH
sed 's/.*\///' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp

# REMOVE FILENAME AND LEAVE EXTENSION
cat ${tmp_dir}/playlist.dirlist.tmp | sed 's/.*\.//' > ${tmp_dir}/playlist.dirlist.tmp2 
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp
# CREATE NUMBERED lIST
sed '/./=' ${tmp_dir}/playlist.dirlist.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/playlist.dirlist.tmp2
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp 
clear
cat ${tmp_dir}/playlist.dirlist.tmp
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$der"" >>> CHANGE PLAYLIST >>>" "$setplaylist"        
echo "___________________________________________________________________________________________________________________"
echo
echo " c - Change Playlist     a - Create Playlist     d - Delete Playlist                                      q - Quit"
echo 
echo -en " Enter Option: "
read -r -n1 optioncpl
echo
}
while true; do
changepl
case $optioncpl in
        q)  # QUIT
        ###cd "$grabdir"
        break ;;

    
        c)  # CHANGE PLAYLIST

# GET CURRENT PLAYLIST
read -r activeplaylistm < ${base_dir}/videoinfo.playlist.current

# SAVE CURRENT PLAYLIST
cp ${base_dir}/videoinfo.playlist "$activeplaylistm" 2>/dev/null

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# LOAD A PLAYLIST
echo
read -r -p " Enter line number: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
if [[ -z "$linenumber" ]]; then
      :

  else
      if [[ $linenumber -gt $linecount ]]

        then 
            echo
            echo " Number out of range . . ."
            sleep .9

        else

            # CREATE FILE MOVING SELECTION TO THE TOP
            tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp3

            # READ FIRST LINE OF FILE
            read plselected < ${tmp_dir}/playlist.dirlist.tmp3

            # WRITE SELECTED PLAYLIST
            echo "$plselected" > ${base_dir}/videoinfo.playlist.current

            # LOAD SELECTED PLAY LIST
            cp "$plselected" ${base_dir}/videoinfo.playlist 2>/dev/null
    
   fi
      fi

fi
break

;;
         d)  # DELETE PLAYLIST

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# SELECT A PLAYLIST TO DELETE
echo
read -r -p " Enter line number to delete: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo " Number out of range . . ."
                  sleep .9

              else
                  echo
                      # CREATE FILE MOVING SELECTION TO THE TOP
                      tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.playlist.delete.tmp

                      # READ FIRST LINE OF FILE
                      read plselected < ${tmp_dir}/playlist.playlist.delete.tmp

                      function menucpl {
                  
                      clear
                      echo
                      echo
                      echo " Delete Playlist . . ."
                      echo
                      echo " $plselected"
                      echo
                      echo " y - Yes     n - No"  
                      echo 
                      echo -en " Enter Option: "
                      read -r -n1 optioncpl
                      echo
                      }

                      while true
                      do
                    menucpl
                    case $optioncpl in

                    y)  # YES

                      rm "$plselected" 2> /dev/null

                      echo "$plselected"| sed 's/.*\.//' > ${tmp_dir}/plread.tmp  # REMOVE FULL PATH ONLY LEAVING PLAYLIST NAME
                      read -r plselectedla < ${tmp_dir}/plread.tmp  # READING PLAYLIST NAME ONLY INTO VARIABLE  $pselecteda
                      rm ${tmp_dir}/plread.tmp  # remove temp file
                      rm ${base_dir}/playlists/"$plselectedla".last-autoplay  # REMOVE PLAYLIST.last.autoplay  file
 
                      echo
                      echo  " Playlist Deleted . . ."

                      if [[ "$setplaylistfull" = "$plselected" ]]; then # SET DEFAULT PLAYLIST TO ACTIVE PLAYLIST
                            echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current
                            cp ${base_dir}/playlists/vplaylist.Default ${base_dir}/videoinfo.playlist 2> /dev/null
                            setplaylist="Default"
                        else
                            :
                      fi

                      sleep 1.7  
                      break
                      ;;
                      n)  # NO
                      break;;

                      *)
        
                      esac
                      done
        
            fi
      fi
fi
            
;;        
         a)
         # CREATE PLAYLIST
echo
echo " If any dots are entered, they will be stripped from the playlist name."
echo " If a space is used as the first character, it will be stripped from the playlist name."
echo " Spaces can be used after the first character of the playlist name."
echo
read -r -p " Create Playlist: " createpl1  # waiting fot user input. grabbing new filename

# Strip out any dots from user entry
echo "$createpl1" > ${tmp_dir}/plremovedot.tmp
sed -i -e 's/\.//g' ${tmp_dir}/plremovedot.tmp
read createpl < ${tmp_dir}/plremovedot.tmp
rm ${tmp_dir}/plremovedot.tmp

if [[ -z "$createpl" ]]; then
      echo
      echo " Nothing was entered . . ."
      sleep .75

  else

      if [[ -f ${base_dir}/playlists/vplaylist."$createpl" ]]; then
            echo
            echo " File already exists . . ."
            sleep .75

        else

plname="$HOME/.config/videoinfox/playlists/vplaylist.""$createpl"  # add user input as file extension
touch "$plname"  #  create user list with full path and filename

touch "$HOME"/.config/videoinfox/playlists/"$createpl1".last-autoplay

echo
echo " Playlist Created: "$plname""
echo
sleep 1.7

      fi
fi
;; 
esac
done
;;
          p) 
          #  @PLAY CLIPBOARD - <PLAYLIST>        

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdirz="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload  
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            touch ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
      get_file_stats "${ytdlplast}"

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
              :
          else     
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST File  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdirz"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${pasteclip}"
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      echo " PLAYLIST Closed"
  
        else
            
            echo
            echo
            echo " No playable content in the clipboard . . ."
            sleep 1.2
      fi   
  fi
  ;;  
         d)  # CLEAR PLAYLIST (VIEW PLAYLIST)

        function menucpl {
        
        clear
        echo
        echo
        echo " Clear current playlist: ""$setplaylist""?"
        echo
        echo " y - Yes     n - No"  
        echo 
        echo -en " Enter Option: "
        read -r -n1 optioncpl
        echo
        }

        while true
        do
      menucpl
      case $optioncpl in

      y)  # YES
        rm ${base_dir}/videoinfo.playlist 2> /dev/null
        touch ${base_dir}/videoinfo.playlist
        touch ${base_dir}/playlists/"$setplaylist".last-autoplay 
        echo
        echo " ""$setplaylist"" Playlist Cleared . . ."
        sleep 1.7  
        break
        ;;
        n)  # NO
        break;;

        *)
        
        esac
        done
        ;;
*)

esac
done
;;
o) # AUTOPLAY (NAVIGATE TREE)
echo
echo
read -r -p " Autoplay Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfox.nt-play-directory-apa > ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> NAVIGATE TREE >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
rm ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null
rm ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
rm ${tmp_dir}/videoinfox.nt-play-directory-apa-work 2>/dev/null 
          
esac
done
else
    echo
    echo " No video files in the current directory . . ."
    sleep 1.7

fi
;;
esac
done
;;
##################################################################################################################################################
d)  # (@PLAY DIRECTORY) HOME   ###################################################################################################################
##################################################################################################################################################

# WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
find_supported_files > "${tmp_dir}/videoinfox.home-play-directory-apa"

#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
if file_contains '^/' "${tmp_dir}/videoinfox.home-play-directory-apa"; then

#  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfox.home-play-directory-apa"

#  PLAYED LIST INPUT FOR LOOP
input="$moddedplayedlist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfox.home-play-directory-apa2

#  #  START WRITING
while read -r line; do

   if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
           echo "$line" >> ${tmp_dir}/videoinfox.home-play-directory-apa2  
      else
           :
   fi        

done < "$input"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.home-play-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfox.home-play-directory-apa2 ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfox.home-play-directory-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfox.home-play-directory-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.home-play-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfox.home-play-directory-apa2 ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfox.home-play-directory-apa2

# NUMBER THE LIST
sed '/./='  ${tmp_dir}/videoinfox.home-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-home-play-directory-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null
     rm ${tmp_dir}/videoinfox.home-play-directory-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfox.numbered-home-play-directory-list 2>/dev/null
     rm ${tmp_dir}/videoinfox.home-play-directory-apa-work 2>/dev/null    
fi
##################clear

if [[ -f ${tmp_dir}/videoinfox.numbered-home-play-directory-list ]]; then
        cat ${tmp_dir}/videoinfox.numbered-home-play-directory-list 2>/dev/null
   else
        echo
        echo
        echo " No video files in the current directory . . ."
        sleep 1.7
fi
linenumber=1

tail -n +"$linenumber" ${tmp_dir}/videoinfox.home-play-directory-apa > ${tmp_dir}/videoinfox.home-play-directory-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfox.home-play-directory-apa.tmp ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> HOME >>> PLAY DIRECTORY" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null
rm ${tmp_dir}/videoinfox.home-play-directory-apa2 2>/dev/null
rm ${tmp_dir}/videoinfox.numbered-home-play-directory-list 2>/dev/null
rm ${tmp_dir}/videoinfox.home-play-directory-apa-work 2>/dev/null 

;;           
#####################################################################################################################################################
l)  # PLAY LAST DOWNLOAD >>> HOME    ################################################################################################################
#####################################################################################################################################################

              grabdir="$PWD"  # storing directory to restore at the end of this function
               
              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"   # change to download directory

                 if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
                        read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt         
                        ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))
                        echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file
                        read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file

                    else
                        read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download
                        ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownloadbak*" \))
                        echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file
                        read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                 fi   

          
              clear
              echo
              echo "___________________________________________________________________________________________________________________"
              echo
              echo " ""$der"" >>> PLAY LAST DOWNLOAD"
              echo
              echo " [PLAY]> ""$ytdlplast"""
              echo "___________________________________________________________________________________________________________________"         
              echo
              
get_file_stats "${ytdlplast}"

              echo
              echo " Video Player Controls:"
              echo                             
              echo " - Fullscreen Toggle: f"
              echo
              echo " - Play/Pause Toggle: space bar"
              echo
              echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
              echo
              echo " - Quit: q"      
              echo -e "\n"
              echo " This screen will exit when the video player is closed."
              echo
         
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
                       
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to file  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
              cd "$grabdir"   # restore dir prior to entering yt-dlp menu
              ;;  
a)  # SHOW ALL VIDEOS

searchtotal=$(find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) 2>/dev/null | wc -l)    
                                                                              
                     if [[ "$searchtotal" = 0 ]  # if find returned no results goto <then>
      
                       then
                           echo
                           echo
                           echo " No video files recursively reachable from the current directory . . ."
                           sleep 1
                           #cp ${base_dir}/videoinfo.findwork3 ${base_dir}/videoinfo.findwork
                           #cp ${base_dir}/videoinfo.lastsearchtotal2  ${base_dir}/videoinfo.lastsearchtotal
                        
                       else
                           echo "*" > ${base_dir}/videoinfo.lastfindstring   # save last find string used                          
                           read -r fterm < ${base_dir}/videoinfo.lastfindstring
                           # save find results
find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) | sort -u > ${base_dir}/videoinfo.findwork
                           echo "$PWD" > ${base_dir}/videoinfo.lastfinddir  # save last directory that last find was run in 
                           # write last search total file count
                           echo "$searchtotal" > ${base_dir}/videoinfo.lastsearchtotal
                           # read last search total file count
                           read -r searchtotal < ${base_dir}/videoinfo.lastsearchtotal    
                           cp ${base_dir}/videoinfo.findwork ${base_dir}/videoinfo.findwork3
                           cp ${base_dir}/videoinfo.lastsearchtotal ${base_dir}/videoinfo.lastsearchtotal2                 

                           notify-send  "Videoinfox messsage: Find results in $PWD" "$searchtotal files found using search term: $fterm"
                         
     fi
     ;;

     1)  # CD DIRECTORY TO TV    
     cd "$dir1" 
     ;;
    
     2)  # CD DIRECTORY TO MOVIES
     cd "$dir2" 
     ;;
     3)  # CHANGE DIRECTORY TO DOWNLOADS
     cd "$dirsaved" 
     ;;
     4)  # CHANGE DIRECTORY TO EXTRA   
     cd "$dir4" 
     ;;
     5)  # CHANGE DIRECTORY TO LAST EXIT
     cd "$dir5" 
     ;;
     c)  # CLEAR FIND RESULTS
     # CREATE FIND RESULT MESSAGE THAT THERE ARE NO STORED FINDS
     touch ${base_dir}/videoinfo.lastsearchtotal
     touch ${base_dir}/videoinfo.lastfindstring
     touch ${base_dir}/videoinfo.lastfinddir

     rm ${tmp_dir}/videoinfo-number-findwork.tmp 2> /dev/null
     rm ${tmp_dir}/videoinfo-findwork.tmp 2> /dev/null

     touch ${base_dir}/videoinfo.findwork
     
     ;;
     x) 
       #CLEAR CLIPBOARD - <HOME> 
       echo "" | xclip -sel clip  # copy message in quotes to the clipboard. clearing out the clipboard
       pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
       ;;

#############################################################################################################################################    
#############################################################################################################################################
     p) 
     #  @PLAY CLIPBOARD - <HOME> !!!!!    MASTER TEMPLATE  This is the one that gets the edits then copied to other places in the code.

#############################################################################################################################################
#############################################################################################################################################
     
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdir="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"    

      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            touch ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
get_file_stats "${ytdlplast}"

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo

      if [[ -z "$ytdlplast" ]]; then
             :
         else     
             notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
             echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List File  
             ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdir"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
     
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${pasteclip}"
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
      # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      
      #notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"      

      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

      echo " Played List Closed"

         else
             echo
             echo
             echo " No playable content in the clipboard . . ."
             sleep 1.2

fi
fi
;;  
      i)  # INFO - <HOME>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

get_file_stats "${pasteclip}"

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo-findwork.tmp ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo-findwork-playnumber.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
get_file_stats "${playnumber}"

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null

                 fi

        else
            echo
            echo
            echo " Select Show All or use Find to acess this feature . . ."
            sleep 1.7
            fi

      fi

;;
##################################################################################################################################################
v)                                  ##############################################################################################################    
     #  VIEW/PLAYED LIST - <HOME>   ##############################################################################################################
     
function menuvv {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$grabclip" = "http" ]]; then
      :

  else      
      if [[ -f "$pasteclip" ]]; then
            :
        else
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi

########################### removed sort routine #########################

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content                  
clear

#  REMOVE PLAYED LIST HEADER AND WRITE NEW FILE FOR PROCESSING: ${tmp_dir}/videoinfo.playedlist-auto-play-all
#awk 'NR>5' ${base_dir}/videoinfo.playedlist > ${tmp_dir}/videoinfo.playedlist-apa

cp ${base_dir}/videoinfo.playedlist ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

#  REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playedlist-apa | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playedlist-apa3 2>/dev/null
mv ${tmp_dir}/videoinfo.playedlist-apa3 cat -n ${tmp_dir}/videoinfo.playedlist 2>/dev/null

#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
if file_contains '^/' "${tmp_dir}/videoinfo.playedlist-apa"; then

#  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfo.playedlist-apa"

#  PLAYED LIST INPUT FOR LOOP
input="$moddedplayedlist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfo.playedlist-apa2

#  #  START WRITING
while read -r line; do
    if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
        echo "$line" >> ${tmp_dir}/videoinfo.playedlist-apa2  
    fi
done < "$input"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
###############################################################################squash ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null

# REMOVE DUPLICATES
#############cat -n ${tmp_dir}/videoinfo.playedlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playedlist-apa3
####################################################mv ${tmp_dir}/videoinfo.playedlist-apa3 ${tmp_dir}/videoinfo.playedlist-apa2

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfo.playedlist-apa2 ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfo.playedlist-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfo.playedlist-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null

#  REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playedlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playedlist-apa3 2>/dev/null
mv ${tmp_dir}/videoinfo.playedlist-apa3 ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfo.playedlist-apa2 ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfo.playedlist-apa2

# NUMBER THE LIST
sed '/./=' ${tmp_dir}/videoinfo.playedlist-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo.number.played-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
     rm ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfo.number.played-list 2>/dev/null     
fi
clear
if [[ -f ${tmp_dir}/videoinfo.number.played-list ]]; then
        cat ${tmp_dir}/videoinfo.number.played-list 2>/dev/null
        dashit=$(echo -e "~")
   else
        dashit=$(echo "-") 
        echo
        echo "Played List Empty . . ."
fi

#cat ${base_dir}/videoinfo.playedlist 

if [[ "$grabpaste" = "http" ]]; then
      echo
      echo "Clipboard: ""$pasteclip"
  else
      :
fi

######echo
######echo "Directory: ""$PWD"
######echo "Clipboard: ""$pasteclip"

##################################################################################################################################################

#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

if [[ "$grabpaste" = "http" ]]; then
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
      ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

            if [[ "$ytdlpconfirm" = "" ]]; then

                      echo "" | xclip -sel clip  # clearing out the clipboard
                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                           # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
                           #________________x________________________________________ _________________________________________________________
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYED LIST"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " o "$dashit" Autoplay Line     s - View Playlist     D - Delete Played List     p - Play Clipboard                q - Quit"
                      echo " j "$dashit" Play Line         k "$dashit" Playlist Add"
                      echo " i "$dashit" Info"
                      echo   

                  else 
                      echo
                      echo "YT-DLP Confirmed: "$ytdlpconfirm""
                      echo
                      echo "Download Directory: $dirsaved"  # dislpay default download directory
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYED LIST"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo -e " o "$dashit" Autoplay Line     s - View Playlist     D - Delete Played List     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                q - Quit"                     
                      echo " j "$dashit" Play Line         k "$dashit" Playlist Add      "
                      echo " i "$dashit" Info"
                      echo                                                                                        
            fi
  else

      if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYED LIST"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo -e " o "$dashit" Autoplay Line     s - View Playlist     D - Delete Played List     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                q - Quit"                     
            echo " j "$dashit" Play Line         k "$dashit" Playlist Add      "
            echo " i "$dashit" Info"
            echo                                                            

        else 

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYED LIST"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " o "$dashit" Autoplay Line     s - View Playlist     D - Delete Played List     p - Play Clipboard                q - Quit"
            echo " j "$dashit" Play Line         k "$dashit" Playlist Add"
            echo " i "$dashit" Info"
            echo
fi
fi

echo -en " Enter Option: "
read -r -n1 optionv
}

        while true
        do
        menuvv
        case $optionv in
    
        q)  # QUIT
        rm ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
        rm ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null
        rm ${tmp_dir}/videoinfo.number.played-list 2>/dev/null
        break;;
        o) # AUTOPLAY LINE  (PLAYED LIST)

if [[ -f ${tmp_dir}/videoinfo.number.played-list ]]; then

echo
echo
read -r -p " Autoplay Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo.playedlist-apa > ${tmp_dir}/videoinfo.playedlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playedlist-apa.tmp ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYED LIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.played-list 2>/dev/null

   else
       echo
       echo
       echo " Played List Empty . . ."
       sleep 1.7
fi

;;
        j) # PLAY LINE  (PLAYED LIST)

# GETTING LINE COUNT
linecount=$(wc -l ${tmp_dir}/videoinfo.number.played-list | cut -d' ' -f1)

if [[ -f ${tmp_dir}/videoinfo.number.played-list ]]; then
       echo
       echo
       read -r -p " Play Line: " linenumber  # waiting fot user input

if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]

              then 
                  echo
                  echo " Number out of range . . ."
                  sleep .9

              else

       tail -n +"$linenumber" ${tmp_dir}/videoinfo.playedlist-apa > ${tmp_dir}/videoinfo.playedlist-apa.tmp 2>/dev/null
       mv ${tmp_dir}/videoinfo.playedlist-apa.tmp ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

       OLDIFS=$IFS
       IFS=$'\n'

       read line < ${tmp_dir}/videoinfo.playedlist-apa
fi
      fi
            fi

        if [[ -z "$line" ]

         then
             :

         else

             clear
             echo
             echo "___________________________________________________________________________________________________________________"
             echo
             echo " ""$der"" >>> PLAYED LIST >>> PLAY LINE" 
             echo
             echo " [PLAY]>" "$line"
             echo "___________________________________________________________________________________________________________________"
             echo

      get_file_stats "${line}"
      
             echo
             echo
             echo " Video Player Controls:"
             echo                             
             echo " - Fullscreen Toggle: f"
             echo
             echo " - Play/Pause Toggle: space bar"
             echo
             echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
             echo
             echo " - Quit: q"      
             echo -e "\n"

             echo " Screen will close after video player is quit."

             ffplay -fs -autoexit "$line" 2> /dev/null
 
             IFS=$OLDIFS

             rm ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
             rm ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null
             rm ${tmp_dir}/videoinfo.number.played-list 2>/dev/null

        fi
    else  # FILE IS EMPTY"
        echo
        echo
        echo " Played List Empty . . ."
        sleep 1.7
fi

;;
       i)  # INFO - <PLAYED LIST>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

get_file_stats "${pasteclip}"

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo.playedlist-apa ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo.playedlist-apa > ${tmp_dir}/videoinfo.playedlist-apa.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo.playedlist-apa.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
get_file_stats "${playnumber}"

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo.playedlist-apa.tmp 2>/dev/null

                 fi

        else
            echo
            echo
            echo " Play List Empty . . ."
            sleep 1.7            
            fi

      fi

;;       
#####################################################################################################################################
s) # @PLAYLIST PLAYED LIST
#####################################################################################################################################

grabdir="$PWD"  # SAVE CURRENT DIRECTORY FOR RESTORE ON EXIT

cd ${base_dir}/playlists
function menuvhome {

squash ${base_dir}/videoinfo.playlist  # remove all blank lines

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$grabclip" = "http" ]]; then
      :

  else      
      if [[ -f "$pasteclip" ]]; then
            :
        else
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      # REMOVE DUPLICATES
      cat -n ${base_dir}/videoinfo.playlist | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist.tmp
      mv ${tmp_dir}/videoinfo.playlist.tmp ${base_dir}/videoinfo.playlist

  else
      touch ${base_dir}/videoinfo.playlist
fi

                
clear

cp ${base_dir}/videoinfo.playlist ${tmp_dir}/videoinfo.playlist-apa
#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
if file_contains '^/' "${tmp_dir}/videoinfo.playlist-apa"; then

#  ASSIGN PLAYLIST TO VARIABLE: $moddedplaylist 
moddedplaylist="$HOME""/.config/videoinfox/tmp/videoinfo.playlist-apa"

#  PLAYLIST INPUT FOR LOOP
input="$moddedplaylist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfo.playlist-apa2

#  #  START WRITING
while read -r line; do

   if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
           echo "$line" >> ${tmp_dir}/videoinfo.playlist-apa2  
      else
           :
   fi        

done < "$input"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

# REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist-apa3

mv ${tmp_dir}/videoinfo.playlist-apa3 ${tmp_dir}/videoinfo.playlist-apa2

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfo.playlist-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplaylist}" "${tmp_dir}/videoinfo.playlist-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfo.playlist-apa2

# NUMBER THE LIST
sed '/./=' ${tmp_dir}/videoinfo.playlist-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
     rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null     
fi
clear
if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then
        cat ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        #dashit=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
        dashit=$(echo "~") #
   else
        dashit=$(echo "-") # 
        echo
        echo "Playlist Empty . . ."
fi

#cat ${base_dir}/videoinfo.playlist 

# check if directory ${base_dir}/playlists is empty.  if it is, set playlist to Default 
searchtotal=$(find "$PWD" -type f \( -iname "vplaylist.*" \) 2>/dev/null | wc -l)

if [[ "$searchtotal" = 0 ]]; then
      echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current             
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      read -r setplaylist < ${tmp_dir}/plread.tmp
      rm ${tmp_dir}/plread.tmp
      # GET CURRENT PLAYLIST
      read -r activeplaylist < ${base_dir}/videoinfo.playlist.current
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      # SAVE CURRENT PLAYLIST
      cp ${base_dir}/videoinfo.playlist "$activeplaylist"
     
  else
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      read -r setplaylist < ${tmp_dir}/plread.tmp

      rm ${tmp_dir}/plread.tmp
fi
##################################################################################################################################################

#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

#echo "Directory: ""$PWD"

if [[ "$grabpaste" = "http" ]]; then
      echo
      echo "Clipboard: ""$pasteclip"
  else
      :
fi
if [[ "$grabpaste" = "http" ]]; then
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
      ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

            if [[ "$ytdlpconfirm" = "" ]]; then

                      echo "" | xclip -sel clip  # clearing out the clipboard
                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                           # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
                           #________________x________________________________________ _________________________________________________________
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " o "$dashit" Autoplay Line     l - Last Autoplay      c - Change Playlist     p - Play Clipboard                  q - Quit"
                      echo " j "$dashit" Play Line"
                      echo " i "$dashit" Info                                     d - Clear Playlist"
                      echo           

                  else 
                      echo
                      echo "YT-DLP Confirmed: "$ytdlpconfirm""
                      echo
                      echo "Download Directory: $dirsaved"  # dislpay default download directory
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
                      echo " j "$dashit" Play Line"
                      echo " i "$dashit" Info                                    d - Clear Playlist"
                      echo                                                                                    
            fi
  else

      if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
            echo " j "$dashit" Play Line"
            echo " i "$dashit" Info                                    d - Clear Playlist"
            echo                                                                     

        else 

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " j - Play Line     o - Start Autoplay      c - Change Playlist     p - Play Clipboard                     q - Quit"
            echo " i - Info          l - Resume Autoplay     r - Remove Line"
            echo "                                           d - Clear Playlist                                             h - Help"
            echo                                                             
fi
fi

echo -en " Enter Option: "
read -r -n1 optionv
}

        while true
        do
        menuvhome
        case $optionv in
    
        q)  # QUIT
        rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
        rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
        rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        cd "$grabdir"
        break;;

       
        h)
        echo
        echo
        echo " PLAYLIST LIST >>> HELP"        
        echo
        echo " Everytime Start Autoplay is used, it will write a new file for Resume Autoplay."
        echo " Run Start Autoplay first. Then use Resume Autoplay to continue watching where you left off."
        echo " Resume Autoplay will start with the last video that was playing when the play loop was quit."
        echo
        echo " Note: If the playlist is changed with Playlist Add or Remove Line after running Start Autoplay,"
        echo "       Resume Autoplay won't get updated with the changes until Start Autoplay is run again."
        echo
        read -p " Press enter to Continue"
        ;;
        o) # AUTOPLAY LINE  (HOME >>> PLAYLIST)

# SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Start Autoplay from line: " linenumber  # waiting fot user input

# 
tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      # COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done

# WRITE 2nd PLAYLIST FOR LAST AUTOPLAY OPTION . File: ${base_dir}/playlists/$playlistname.last-autoplay
tail -n +"$i" ${tmp_dir}/videoinfo.playlist-apa > "$setplaylist".last-autoplay

IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;

########################################
r)  # REMOVE LINE  (HOME >>> PLAYLIST)
########################################

# delete a line example to remove by pattern
#sed '\?^/mnt/MEDIA1/MOVIES/identity thief.mp4?d' videoinfo.playlist
# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplpld.tmp 
read -r whatplpld < ${tmp_dir}/whatplpld.tmp
rm ${tmp_dir}/whatplpld.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      :
  else
      touch ${base_dir}/videoinfo.playlist
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then

      clear
      cat ${tmp_dir}/videoinfo.number.play-list 2> /dev/null

      echo
      read -r -p "Enter line number to remove video from the playlist $whatplpld: " linenumber  # waiting fot user input

      # REMOVE BLANK LINES
      ######squash ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

      # GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
      linecount=$(wc -l ${tmp_dir}/videoinfo.playlist-apa 2> /dev/null | cut -d' ' -f1) # 

          if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                :

            else  # ENTRY IS A NUMBER

                if [[ -z "$linenumber" ]]; then
                      :

                  else

                      if [[ "$linenumber" = 0 ]]; then
                            :

                        else
      
                            if [[ $linenumber -gt $linecount ]]; then 
                                  echo
                                  echo "Number out of range . . ."
                                  sleep .9

                              else

                                  if [[ -z "$linenumber" ]]; then
                                        :

                                    else
                                        # DELETE LINE NUMBER
                                        sed -i "${linenumber}d" ${base_dir}/videoinfo.playlist 2> /dev/null 
                                        echo
                                        echo "Line deleted from the playlist . . ."
                                        sleep .25
                                  fi
                            fi
                      fi
               fi
         fi
fi

;;
###########################################################
l) # LAST AUTOPLAY - RESUME AUOTOPLAY (HOME >>> PLAYLIST)
###########################################################

# READ FIRST LINE TO DISPLAY VIDEO NAME BEFORE PLAY
read < $HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay resumedisplay
echo
echo
echo " Resume: ""$resumedisplay"
sleep 3

###### SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

OLDIFS=$IFS
IFS=$'\n'

input2=$HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay
for line in $(cat "$input2" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      ###### COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING FOR WRITE ON EXIT.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
tail -n +"$i" ${base_dir}/playlists/"$setplaylist".last-autoplay > ${base_dir}/playlists/pl-tmp
mv ${base_dir}/playlists/pl-tmp ${base_dir}/playlists/"$setplaylist".last-autoplay
IFS=$OLDIFS

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
        j) # PLAY LINE  (HOME >>> PLAYLIST)

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Play Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

read line < ${tmp_dir}/videoinfo.playlist-apa

if [[ -z "$line" ]

  then
      :

  else

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> PLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      echo " Screen will close after video player is quit."

      ffplay -fs -autoexit "$line" 2> /dev/null
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

fi

else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
       i)  # INFO - <PLAYLIST>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

get_file_stats "${pasteclip}"

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo.playlist-apa ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo.playlist-apa.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
get_file_stats "${playnumber}"

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null

                 fi

        else
            :

            fi

      fi

;;       

########################################################################################################################################################
          c)
          # CHANGE PLAYLIST
########################################################################################################################################################

function changepl {

#read -r savepl < ${base_dir}/videoinfo.playlist.current
#cp ${base_dir}/videoinfo.playlist "$savepl"

# cd ${base_dir}/playlists

# FIND PLAYLISTS
find "$PWD" -type f \( -iname "vplaylist.*" \) > ${base_dir}/videoinfo.playlist.dirlist

# SORT BACK INTO ORDER
sort -u ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist 

#  REMOVE BLANK LINES
sed '/^$/d' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist

# REMOVE PATH
sed 's/.*\///' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp

# REMOVE FILENAME AND LEAVE EXTENSION
cat ${tmp_dir}/playlist.dirlist.tmp | sed 's/.*\.//' > ${tmp_dir}/playlist.dirlist.tmp2 
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp
# CREATE NUMBERED lIST
sed '/./=' ${tmp_dir}/playlist.dirlist.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/playlist.dirlist.tmp2
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp 
clear
cat ${tmp_dir}/playlist.dirlist.tmp
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$der"" >>> CHANGE PLAYLIST >>>" "$setplaylist"        
echo "___________________________________________________________________________________________________________________"
echo
echo " c - Change Playlist     a - Create Playlist     d - Delete Playlist                                      q - Quit"
echo 
echo -en " Enter Option: "
read -r -n1 optioncpl
echo
}
while true; do
changepl
case $optioncpl in
        q)  # QUIT
        ###cd "$grabdir"
        break ;;

    
        c)  # CHANGE PLAYLIST

# GET CURRENT PLAYLIST
read -r activeplaylistm < ${base_dir}/videoinfo.playlist.current

# SAVE CURRENT PLAYLIST
cp ${base_dir}/videoinfo.playlist "$activeplaylistm" 2>/dev/null

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# LOAD A PLAYLIST
echo
read -r -p " Enter line number: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
if [[ -z "$linenumber" ]]; then
      :

  else
      if [[ $linenumber -gt $linecount ]]

        then 
            echo
            echo " Number out of range . . ."
            sleep .9

        else

            # CREATE FILE MOVING SELECTION TO THE TOP
            tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp3

            # READ FIRST LINE OF FILE
            read plselected < ${tmp_dir}/playlist.dirlist.tmp3

            # WRITE SELECTED PLAYLIST
            echo "$plselected" > ${base_dir}/videoinfo.playlist.current

            # LOAD SELECTED PLAY LIST
            cp "$plselected" ${base_dir}/videoinfo.playlist 2>/dev/null
    
   fi
      fi

fi
break

;;
         d)  # DELETE PLAYLIST

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# SELECT A PLAYLIST TO DELETE
echo
read -r -p " Enter line number to delete: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo " Number out of range . . ."
                  sleep .9

              else
                  echo
                      # CREATE FILE MOVING SELECTION TO THE TOP
                      tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.playlist.delete.tmp

                      # READ FIRST LINE OF FILE
                      read plselected < ${tmp_dir}/playlist.playlist.delete.tmp

                      function menucpl {
                  
                      clear
                      echo
                      echo
                      echo " Delete Playlist . . ."
                      echo
                      echo " $plselected"
                      echo
                      echo " y - Yes     n - No"  
                      echo 
                      echo -en " Enter Option: "
                      read -r -n1 optioncpl
                      echo
                      }

                      while true
                      do
                    menucpl
                    case $optioncpl in

                    y)  # YES

                      rm "$plselected" 2> /dev/null

                      echo "$plselected"| sed 's/.*\.//' > ${tmp_dir}/plread.tmp  # REMOVE FULL PATH ONLY LEAVING PLAYLIST NAME
                      read -r plselectedla < ${tmp_dir}/plread.tmp  # READING PLAYLIST NAME ONLY INTO VARIABLE  $pselecteda
                      rm ${tmp_dir}/plread.tmp  # remove temp file
                      rm ${base_dir}/playlists/"$plselectedla".last-autoplay  # REMOVE PLAYLIST.last.autoplay  file
 
                      echo
                      echo  " Playlist Deleted . . ."

                      if [[ "$setplaylistfull" = "$plselected" ]]; then # SET DEFAULT PLAYLIST TO ACTIVE PLAYLIST
                            echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current
                            cp ${base_dir}/playlists/vplaylist.Default ${base_dir}/videoinfo.playlist 2> /dev/null
                            setplaylist="Default"
                        else
                            :
                      fi

                      sleep 1.7  
                      break
                      ;;
                      n)  # NO
                      break;;

                      *)
        
                      esac
                      done
        
            fi
      fi
fi
            
;;        
         a)
         # CREATE PLAYLIST
echo
echo " If any dots are entered, they will be stripped from the playlist name."
echo " If a space is used as the first character, it will be stripped from the playlist name."
echo " Spaces can be used after the first character of the playlist name."
echo
read -r -p " Create Playlist: " createpl1  # waiting fot user input. grabbing new filename

# Strip out any dots from user entry
echo "$createpl1" > ${tmp_dir}/plremovedot.tmp
sed -i -e 's/\.//g' ${tmp_dir}/plremovedot.tmp
read createpl < ${tmp_dir}/plremovedot.tmp
rm ${tmp_dir}/plremovedot.tmp

if [[ -z "$createpl" ]]; then
      echo
      echo " Nothing was entered . . ."
      sleep .75

  else

      if [[ -f ${base_dir}/playlists/vplaylist."$createpl" ]]; then
            echo
            echo " File already exists . . ."
            sleep .75

        else

plname="$HOME/.config/videoinfox/playlists/vplaylist.""$createpl"  # add user input as file extension
touch "$plname"  #  create user list with full path and filename

touch "$HOME"/.config/videoinfox/playlists/"$createpl1".last-autoplay

echo
echo " Playlist Created: "$plname""
echo
sleep 1.7

      fi
fi
;; 
esac
done
;;
          p) 
          #  @PLAY CLIPBOARD - <PLAYLIST>        

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdirz="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload  
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            touch ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
get_file_stats "${ytdlplast}"

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
              :
          else     
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST File  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdirz"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${pasteclip}"
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      echo " PLAYLIST Closed"
  
        else
            
            echo
            echo
            echo " No playable content in the clipboard . . ."
            sleep 1.2
      fi   
  fi
  ;;  
         d)  # CLEAR PLAYLIST (VIEW PLAYLIST)

        function menucpl {
        
        clear
        echo
        echo
        echo " Clear current playlist: ""$setplaylist""?"
        echo
        echo " y - Yes     n - No"  
        echo 
        echo -en " Enter Option: "
        read -r -n1 optioncpl
        echo
        }

        while true
        do
      menucpl
      case $optioncpl in

      y)  # YES
        rm ${base_dir}/videoinfo.playlist 2> /dev/null
        touch ${base_dir}/videoinfo.playlist
        touch ${base_dir}/playlists/"$setplaylist".last-autoplay 
        echo
        echo " ""$setplaylist"" Playlist Cleared . . ."
        sleep 1.7  
        break
        ;;
        n)  # NO
        break;;

        *)
        
        esac
        done
        ;;
*)

esac
done
;;
k)
##################################################################################################################################################
###########################   ADD TO PLAYLIST  k   (PLAYED LIST)  ################################################################################
##################################################################################################################################################

# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplpld.tmp 
read -r whatplpld < ${tmp_dir}/whatplpld.tmp
rm ${tmp_dir}/whatplpld.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      :
  else
      touch ${base_dir}/videoinfo.playlist
fi
if [[ -f ${base_dir}/videoinfo.playedlist ]]; then

      clear
      cat ${tmp_dir}/videoinfo.number.played-list

      echo
      read -r -p "Enter line number to add video to playlist $whatplpld: " linenumber  # waiting fot user input

      # REMOVE BLANK LINES
      squash ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
      # create file moving selected line number to the top
      tail -n +"$linenumber" ${tmp_dir}/videoinfo.playedlist-apa > ${tmp_dir}/videoinfo.playedlist-playnumber.tmp 2>/dev/null
# GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
linecount=$(wc -l ${tmp_dir}/videoinfo.playedlist-apa | cut -d' ' -f1)

if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER

      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo "Number out of range . . ."
                  sleep .9

              else
      # read first line of file for play
      read playnumber < ${tmp_dir}/videoinfo.playedlist-playnumber.tmp

      if [[ -z "$playnumber" ]]; then
              :

          else
              echo "$playnumber" >> ${base_dir}/videoinfo.playlist   
              echo
              echo " ""$playnumber" 
              echo
              echo " Added to Playlist . . ."
              sleep .25
      fi

fi
fi
fi
else
    echo
    echo
    echo " Select Show All or use Find to acess this feature . . ."
    sleep 1.7

fi
;;

      
          p) 
          #  @PLAY CLIPBOARD - <PLAYED LIST>        

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdir="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload  
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            touch ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
get_file_stats "${ytdlplast}"

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
              :
          else     
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List File  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdir"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${pasteclip}"
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      echo " Played List Closed"
  
        else
            
            echo
            echo
            echo " No playable content in the clipboard . . ."
            sleep 1.2
      fi   
  fi
  ;;  
                D)  # DELETE PLAYED LIST - <find menu>
                rm ${base_dir}/videoinfo.playedlist
                # writing header for new Played List because new file wouldn't be created until return to main HOME
                touch ${base_dir}/videoinfo.playedlist
                #echo "PLAYED LIST" >> ${base_dir}/videoinfo.playedlist
                #echo >> ${base_dir}/videoinfo.playedlist
                #echo "This File was Created: $(date) by" "$USER" >> ${base_dir}/videoinfo.playedlist
                #echo >> ${base_dir}/videoinfo.playedlist      
                echo
                echo
                echo " Played List DELETED . . ."
                echo
                #read -p " Press enter to Continue"    
                sleep .7
                ;;

                *)

                esac
                done
                ;; 
##################################################################################################################################################
s) #######################  @PLAYLIST - (HOME)  ################################################################################################### 
##################################################################################################################################################

grabdir="$PWD"  # SAVE CURRENT DIRECTORY FOR RESTORE ON EXIT

cd ${base_dir}/playlists
menuvhome() {

squash "${base_dir}/videoinfo.playlist"  # remove all blank lines

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ ! "$grabclip" = "http" ]]; then
    if [[ ! -f "$pasteclip" ]]; then
        echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    fi
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
    # REMOVE DUPLICATES
    cat -n ${base_dir}/videoinfo.playlist | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist.tmp
    mv ${tmp_dir}/videoinfo.playlist.tmp ${base_dir}/videoinfo.playlist

else
    touch ${base_dir}/videoinfo.playlist
fi

clear

cp ${base_dir}/videoinfo.playlist ${tmp_dir}/videoinfo.playlist-apa

#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
if ! file_contains '^/' "${tmp_dir}/videoinfo.playlist-apa"; then
    {
        rm "${tmp_dir}/videoinfo.playlist-apa"
        rm "${tmp_dir}/videoinfo.playlist-apa2"
        rm "${tmp_dir}/videoinfo.number.play-list"
    } 2>/dev/null
    return
fi

#  ASSIGN PLAYLIST TO VARIABLE: $moddedplaylist 
moddedplaylist="$HOME""/.config/videoinfox/tmp/videoinfo.playlist-apa"

#  PLAYLIST INPUT FOR LOOP
input="$moddedplaylist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfo.playlist-apa2

#  #  START WRITING
while read -r line; do
    if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
        echo "$line" >> ${tmp_dir}/videoinfo.playlist-apa2  
    fi
done < "$input"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

# REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist-apa3

mv ${tmp_dir}/videoinfo.playlist-apa3 ${tmp_dir}/videoinfo.playlist-apa2

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfo.playlist-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplaylist}" "${tmp_dir}/videoinfo.playlist-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfo.playlist-apa2

# NUMBER THE LIST
sed '/./=' ${tmp_dir}/videoinfo.playlist-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

clear
if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then
    cat ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
    #dashit=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
    dashit=$(echo "~") #
else
    dashit=$(echo "-") # 
    echo
    echo "Playlist Empty . . ."
fi

#cat ${base_dir}/videoinfo.playlist 

# check if directory ${base_dir}/playlists is empty.  if it is, set playlist to Default 
searchtotal=$(find "$PWD" -type f \( -iname "vplaylist.*" \) 2>/dev/null | wc -l)

if [[ "$searchtotal" = 0 ]]; then
      echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current             
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      read -r setplaylist < ${tmp_dir}/plread.tmp
      rm ${tmp_dir}/plread.tmp
      # GET CURRENT PLAYLIST
      read -r activeplaylist < ${base_dir}/videoinfo.playlist.current
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      # SAVE CURRENT PLAYLIST
      cp ${base_dir}/videoinfo.playlist "$activeplaylist"
     
  else
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      read -r setplaylist < ${tmp_dir}/plread.tmp

      rm ${tmp_dir}/plread.tmp
fi
##################################################################################################################################################

#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

#echo "Directory: ""$PWD"

if [[ "$grabpaste" = "http" ]]; then
      echo
      echo "Clipboard: ""$pasteclip"
fi
if [[ "$grabpaste" = "http" ]]; then
    read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
    ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

    if [[ "$ytdlpconfirm" = "" ]]; then

        echo "" | xclip -sel clip  # clearing out the clipboard
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

        # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
        #________________x________________________________________ _________________________________________________________
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " o "$dashit" Autoplay Line     l - Last Autoplay      c - Change Playlist     p - Play Clipboard                  q - Quit"
        echo " j "$dashit" Play Line"
        echo " i "$dashit" Info                                     d - Clear Playlist"
        echo           

    else 
        echo
        echo "YT-DLP Confirmed: "$ytdlpconfirm""
        echo
        echo "Download Directory: $dirsaved"  # dislpay default download directory
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
        echo " j "$dashit" Play Line"
        echo " i "$dashit" Info                                    d - Clear Playlist"
        echo                                                                                    
    fi
else

    if [[ -f "$pasteclip" ]]; then
        echo      
        echo "Valid file in clipboard"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
        echo " j "$dashit" Play Line"
        echo " i "$dashit" Info                                    d - Clear Playlist"
        echo                                                                     

    else

        echo "" | xclip -sel clip  # clearing out the clipboard
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " j - Play Line     o - Start Autoplay      c - Change Playlist     p - Play Clipboard                     q - Quit"
        echo " i - Info          l - Resume Autoplay     r - Remove Line"
        echo "                                           d - Clear Playlist                                             h - Help"
        echo
    fi
fi

echo -en " Enter Option: "
read -r -n1 optionv
}

        while true; do
        menuvhome
        case $optionv in
    
        q)  # QUIT
        rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
        rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
        rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        cd "$grabdir"
        break;;

       
        h)
        echo
        echo
        echo " PLAYLIST LIST >>> HELP"        
        echo
        echo " Everytime Start Autoplay is used, it will write a new file for Resume Autoplay."
        echo " Run Start Autoplay first. Then use Resume Autoplay to continue watching where you left off."
        echo " Resume Autoplay will start with the last video that was playing when the play loop was quit."
        echo
        echo " Note: If the playlist is changed with Playlist Add or Remove Line after running Start Autoplay,"
        echo "       Resume Autoplay won't get updated with the changes until Start Autoplay is run again."
        echo
        read -p " Press enter to Continue"
        ;;
        o) # AUTOPLAY LINE  (HOME >>> PLAYLIST)

# SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Start Autoplay from line: " linenumber  # waiting fot user input

# 
tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null); do
    clear
    echo
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
    echo
    echo " [PLAY]>" "$line"
    echo "___________________________________________________________________________________________________________________"
    echo

    get_file_stats "${line}"
    
    echo
    echo
    echo " Video Player Controls:"
    echo                             
    echo " - Fullscreen Toggle: f"
    echo
    echo " - Play/Pause Toggle: space bar"
    echo
    echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
    echo
    echo " - Quit: q"      
    echo -e "\n"

    ffplay -fs -autoexit "$line" 2> /dev/null

    # COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING.
    i=$((i+1))

    echo " To bypass the 3 second wait press enter with no entry"
    echo
    echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
    echo 
    read -t 3 -p " Press any key then press enter to quit : " playdir
           
    # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
    if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
            break                                                   # if enter is pressed without any input the next video will play
    fi
done

# WRITE 2nd PLAYLIST FOR LAST AUTOPLAY OPTION . File: ${base_dir}/playlists/$playlistname.last-autoplay
tail -n +"$i" ${tmp_dir}/videoinfo.playlist-apa > "$setplaylist".last-autoplay

IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;

########################################
r)  # REMOVE LINE  (HOME >>> PLAYLIST)
########################################

# delete a line example to remove by pattern
#sed '\?^/mnt/MEDIA1/MOVIES/identity thief.mp4?d' videoinfo.playlist
# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplpld.tmp 
read -r whatplpld < ${tmp_dir}/whatplpld.tmp
rm ${tmp_dir}/whatplpld.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
    touch ${base_dir}/videoinfo.playlist
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
    clear
    cat ${tmp_dir}/videoinfo.number.play-list 2> /dev/null

    echo
    read -r -p "Enter line number to remove video from the playlist $whatplpld: " linenumber  # waiting fot user input

    # REMOVE BLANK LINES
    ######squash ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

    # GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
    linecount=$(wc -l ${tmp_dir}/videoinfo.playlist-apa 2> /dev/null | cut -d' ' -f1) # 

    if [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
        if [[ -z "$linenumber" ]]; then
            :
        else
            if [[ "$linenumber" = 0 ]]; then
                :
            else
                if [[ $linenumber -gt $linecount ]]; then 
                    echo
                    echo "Number out of range . . ."
                    sleep .9
                else
                    if [[ -z "$linenumber" ]]; then
                        :
                    else
                        # DELETE LINE NUMBER
                        sed -i "${linenumber}d" ${base_dir}/videoinfo.playlist 2> /dev/null 
                        echo
                        echo "Line deleted from the playlist . . ."
                        sleep .25
                    fi
                fi
            fi
        fi
    fi
fi

;;
###########################################################
l) # LAST AUTOPLAY - RESUME AUOTOPLAY (HOME >>> PLAYLIST)
###########################################################

# READ FIRST LINE TO DISPLAY VIDEO NAME BEFORE PLAY
read < $HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay resumedisplay
echo
echo
echo " Resume: ""$resumedisplay"
sleep 3

###### SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

OLDIFS=$IFS
IFS=$'\n'

input2=$HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay
for line in $(cat "$input2" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      ###### COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING FOR WRITE ON EXIT.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
tail -n +"$i" ${base_dir}/playlists/"$setplaylist".last-autoplay > ${base_dir}/playlists/pl-tmp
mv ${base_dir}/playlists/pl-tmp ${base_dir}/playlists/"$setplaylist".last-autoplay
IFS=$OLDIFS

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
        j) # PLAY LINE  (HOME >>> PLAYLIST)

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Play Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

read line < ${tmp_dir}/videoinfo.playlist-apa

if [[ -z "$line" ]]; then
      :

  else

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> PLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      echo " Screen will close after video player is quit."

      ffplay -fs -autoexit "$line" 2> /dev/null
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

fi

else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
       i)  # INFO - <PLAYLIST>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

            get_file_stats "${pasteclip}"

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo.playlist-apa ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo.playlist-apa.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
                        get_file_stats "${playnumber}"

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null

                 fi

        else
            :

            fi

      fi

;;       

########################################################################################################################################################
          c)
          # CHANGE PLAYLIST
########################################################################################################################################################

changepl() {
    #read -r savepl < ${base_dir}/videoinfo.playlist.current
    #cp ${base_dir}/videoinfo.playlist "$savepl"

    # cd ${base_dir}/playlists

    # FIND PLAYLISTS
    find "$PWD" -type f \( -iname "vplaylist.*" \) > ${base_dir}/videoinfo.playlist.dirlist

    # SORT BACK INTO ORDER
    sort -u ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
    mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist 

    #  REMOVE BLANK LINES
    sed '/^$/d' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
    mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist

    # REMOVE PATH
    sed 's/.*\///' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp

    # REMOVE FILENAME AND LEAVE EXTENSION
    cat ${tmp_dir}/playlist.dirlist.tmp | sed 's/.*\.//' > ${tmp_dir}/playlist.dirlist.tmp2 
    mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp
    # CREATE NUMBERED lIST
    sed '/./=' ${tmp_dir}/playlist.dirlist.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/playlist.dirlist.tmp2
    mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp 
    clear
    cat ${tmp_dir}/playlist.dirlist.tmp
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$der"" >>> CHANGE PLAYLIST >>>" "$setplaylist"        
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " c - Change Playlist     a - Create Playlist     d - Delete Playlist                                      q - Quit"
    echo 
    echo -en " Enter Option: "
    read -r -n1 optioncpl
    echo
}

while true; do
changepl
case $optioncpl in
        q)  # QUIT
        ###cd "$grabdir"
        break ;;

    
        c)  # CHANGE PLAYLIST

# GET CURRENT PLAYLIST
read -r activeplaylistm < ${base_dir}/videoinfo.playlist.current

# SAVE CURRENT PLAYLIST
cp ${base_dir}/videoinfo.playlist "$activeplaylistm" 2>/dev/null

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# LOAD A PLAYLIST
echo
read -r -p " Enter line number: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
if [[ -z "$linenumber" ]]; then
      :

  else
      if [[ $linenumber -gt $linecount ]]

        then 
            echo
            echo " Number out of range . . ."
            sleep .9

        else

            # CREATE FILE MOVING SELECTION TO THE TOP
            tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp3

            # READ FIRST LINE OF FILE
            read plselected < ${tmp_dir}/playlist.dirlist.tmp3

            # WRITE SELECTED PLAYLIST
            echo "$plselected" > ${base_dir}/videoinfo.playlist.current

            # LOAD SELECTED PLAY LIST
            cp "$plselected" ${base_dir}/videoinfo.playlist 2>/dev/null
    
   fi
      fi

fi
break

;;
         d)  # DELETE PLAYLIST

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# SELECT A PLAYLIST TO DELETE
echo
read -r -p " Enter line number to delete: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo " Number out of range . . ."
                  sleep .9

              else
                  echo
                      # CREATE FILE MOVING SELECTION TO THE TOP
                      tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.playlist.delete.tmp

                      # READ FIRST LINE OF FILE
                      read plselected < ${tmp_dir}/playlist.playlist.delete.tmp

                      function menucpl {
                  
                      clear
                      echo
                      echo
                      echo " Delete Playlist . . ."
                      echo
                      echo " $plselected"
                      echo
                      echo " y - Yes     n - No"  
                      echo 
                      echo -en " Enter Option: "
                      read -r -n1 optioncpl
                      echo
                      }

                      while true
                      do
                    menucpl
                    case $optioncpl in

                    y)  # YES

                      rm "$plselected" 2> /dev/null

                      echo "$plselected"| sed 's/.*\.//' > ${tmp_dir}/plread.tmp  # REMOVE FULL PATH ONLY LEAVING PLAYLIST NAME
                      read -r plselectedla < ${tmp_dir}/plread.tmp  # READING PLAYLIST NAME ONLY INTO VARIABLE  $pselecteda
                      rm ${tmp_dir}/plread.tmp  # remove temp file
                      rm ${base_dir}/playlists/"$plselectedla".last-autoplay  # REMOVE PLAYLIST.last.autoplay  file
 
                      echo
                      echo  " Playlist Deleted . . ."

                      if [[ "$setplaylistfull" = "$plselected" ]]; then # SET DEFAULT PLAYLIST TO ACTIVE PLAYLIST
                            echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current
                            cp ${base_dir}/playlists/vplaylist.Default ${base_dir}/videoinfo.playlist 2> /dev/null
                            setplaylist="Default"
                        else
                            :
                      fi

                      sleep 1.7  
                      break
                      ;;
                      n)  # NO
                      break;;

                      *)
        
                      esac
                      done
        
            fi
      fi
fi
            
;;        
         a)
         # CREATE PLAYLIST
echo
echo " If any dots are entered, they will be stripped from the playlist name."
echo " If a space is used as the first character, it will be stripped from the playlist name."
echo " Spaces can be used after the first character of the playlist name."
echo
read -r -p " Create Playlist: " createpl1  # waiting fot user input. grabbing new filename

# Strip out any dots from user entry
echo "$createpl1" > ${tmp_dir}/plremovedot.tmp
sed -i -e 's/\.//g' ${tmp_dir}/plremovedot.tmp
read createpl < ${tmp_dir}/plremovedot.tmp
rm ${tmp_dir}/plremovedot.tmp

if [[ -z "$createpl" ]]; then
      echo
      echo " Nothing was entered . . ."
      sleep .75

  else

      if [[ -f ${base_dir}/playlists/vplaylist."$createpl" ]]; then
            echo
            echo " File already exists . . ."
            sleep .75

        else

plname="$HOME/.config/videoinfox/playlists/vplaylist.""$createpl"  # add user input as file extension
touch "$plname"  #  create user list with full path and filename

touch "$HOME"/.config/videoinfox/playlists/"$createpl1".last-autoplay

echo
echo " Playlist Created: "$plname""
echo
sleep 1.7

      fi
fi
;; 
esac
done
;;
          p) 
          #  @PLAY CLIPBOARD - <PLAYLIST>        

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdirz="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload  
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            touch ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
get_file_stats "${ytdlplast}"

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
              :
          else     
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST File  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdirz"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${pasteclip}"
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      echo " PLAYLIST Closed"
  
        else
            
            echo
            echo
            echo " No playable content in the clipboard . . ."
            sleep 1.2
      fi   
  fi
  ;;  
         d)  # CLEAR PLAYLIST (VIEW PLAYLIST)

        function menucpl {
        
        clear
        echo
        echo
        echo " Clear current playlist: ""$setplaylist""?"
        echo
        echo " y - Yes     n - No"  
        echo 
        echo -en " Enter Option: "
        read -r -n1 optioncpl
        echo
        }

        while true
        do
      menucpl
      case $optioncpl in

      y)  # YES
        rm ${base_dir}/videoinfo.playlist 2> /dev/null
        touch ${base_dir}/videoinfo.playlist
        touch ${base_dir}/playlists/"$setplaylist".last-autoplay 
        echo
        echo " ""$setplaylist"" Playlist Cleared . . ."
        sleep 1.7  
        break
        ;;
        n)  # NO
        break;;

        *)
        
        esac
        done
        ;;
*)

esac
done
;;
k)
##################################################################################################################################################
###########################   ADD TO PLAYLIST  k   <HOME>  #######################################################################################
##################################################################################################################################################

# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplhome.tmp 
read -r whatplhome < ${tmp_dir}/whatplhome.tmp
rm ${tmp_dir}/whatplhome.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      :
  else
      touch ${base_dir}/videoinfo.playlist
fi
if [[ -f ${tmp_dir}/videoinfo-findwork.tmp ]]; then

      clear
      cat ${tmp_dir}/videoinfo-number-findwork.tmp

      echo
      read -r -p "Enter line number to add video to playlist $whatplhome: " linenumber  # waiting fot user input

      # create file moving selected line number to the top
      tail -n +"$linenumber" ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null

# GETTING NUMBER OF VIDEO FILES FROM FIND RESULTS
linecount=$(wc -l ${tmp_dir}/videoinfo-findwork.tmp | cut -d' ' -f1)

if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER

      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo "Number out of range . . ."
                  sleep .9

              else
     
      # read first line of file for play
      read playnumber < ${tmp_dir}/videoinfo-findwork-playnumber.tmp

      if [[ -z "$playnumber" ]]; then
              :

          else
              echo "$playnumber" >> ${base_dir}/videoinfo.playlist
              echo
              echo " ""$playnumber" 
              echo
              echo " Added to Playlist . . ."
              sleep .25
      fi
fi
fi
fi

else
    echo
    echo
    echo " Select Show All or use Find to acess this feature . . ."
    sleep 1.7

fi
;;
##################################################################################################################################################
    f)  ################  FIND ROUTINE - <HOME>  #################################################################################################
##################################################################################################################################################

    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard Content: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$ver"" >>> Find Video File(s) - Recursive                                               wildcard * ok"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " Find a video file to play, add it to the playlist or get info.  No file extensions." 
    echo
    read -r -p " File Name: " videofind  # waiting fot user input - video file that you want to find

    searchtotal=$(find "$PWD" -type f \( -iname "$videofind.mp4" -o -iname "$videofind.mkv" -o -iname "$videofind.avi" -o -iname "$videofind.webm" -o -iname "$videofind.divx" \) 2>/dev/null | wc -l)    
                                                                                                      
    if [[ -z "$videofind" ]]; then
               echo
               echo " error: Nothing was entered."
               echo
               sleep .7        
          else
                
              if echo "$videofind" | grep "/" > /dev/null  # if any slashehes were entered goto <then>
                then
                    echo
                    echo " error: No directories only filenames."
                    echo
                    sleep .7 
                else
                                
                     if [[ "$searchtotal" = 0 ]  # if find returned no results goto <then>
      
                       then
                           #cp ${base_dir}/videoinfo.findwork3 ${base_dir}/videoinfo.findwork
                           #cp ${base_dir}/videoinfo.lastsearchtotal2  ${base_dir}/videoinfo.lastsearchtotal
                           echo
                           echo " No files found"
                           echo
                           sleep .7 
                          
                       else
                           echo "$videofind" > ${base_dir}/videoinfo.lastfindstring   # save last find string used                          
                           read -r fterm < ${base_dir}/videoinfo.lastfindstring

                           # save find results
find "$PWD" -type f \( -iname "$videofind.mp4" -o -iname "$videofind.mkv" -o -iname "$videofind.avi" -o -iname "$videofind.webm" -o -iname "$videofind.divx" \) | sort -u > ${base_dir}/videoinfo.findwork
                           echo "$PWD" > ${base_dir}/videoinfo.lastfinddir  # save last directory that last find was run in 
                           # write last search total file count
                           echo "$searchtotal" > ${base_dir}/videoinfo.lastsearchtotal
                           # read last search total file count
                           read -r searchtotal < ${base_dir}/videoinfo.lastsearchtotal    
                           cp ${base_dir}/videoinfo.findwork ${base_dir}/videoinfo.findwork3
                           cp ${base_dir}/videoinfo.lastsearchtotal ${base_dir}/videoinfo.lastsearchtotal2                 
                           echo
                           echo " Total files found: " "$searchtotal"  # number of files found
                           notify-send  "Videoinfox messsage: Find results in $PWD" "$searchtotal files found using search term: $fterm"
                           sleep 1.5
    fi
    fi              
    fi
    ;;
##################################################################################################################################################
z)  # SETTINGS - <HOME>  #########################################################################################################################
##################################################################################################################################################

function menusettings {
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
# LOAD STORED DIRECTORIES
read -r dir1 < ${base_dir}/videoinfo.tv-dir 2> /dev/null
read -r dir2 < ${base_dir}/videoinfo.movies-dir 2> /dev/null
read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null
read -r dir4 < ${base_dir}/videoinfo.parent-dir 2> /dev/null
read -r dir5 < ${base_dir}/videoinfo.dir-at-exit 2> /dev/null

clear
echo
echo "Directory:" "$PWD"
echo "Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> SETTINGS                                                  Enter - Update Clipboard Display"
echo "___________________________________________________________________________________________________________________" 
echo
echo " Set Default Directories                                                                     q - Quit"
echo
echo "                                                                                             v - Videoinfox Update"
echo " 1 - TV:" "$dir1"
echo "                                                                                             y - Yt-dlp Update"
echo " 2 - Movies:" "$dir2"
echo "                                                                                             l - Last Search"
echo " 3 - Download:" "$dirsaved"
echo "                                                                                             h - Version History"
echo " 4 - Extra:" "$dir4"
echo "                                                                                             c - Code Stats"
echo
echo "                                                                                             x - Clear Clipboard"
echo " Last Exit Dir 5:" "$dir5"
echo
echo
echo -en " Enter Option: "
read -r -n1 optionsettings
}

while true; do
menusettings
case $optionsettings in

    q)  # QUIT
    break;;
    x) #  CLEAR CLIPBOARD  <DOWNLOAD LIST> 
    echo "" | xclip -sel clip  # clearing out the clipboard
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    ;;
    c)  # CODE STATS

function codestats {

clear
echo
echo #"Directory:" "$PWD"
echo #"Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> SETTINGS >>> CODE STATS                                                           q - Quit"
echo "___________________________________________________________________________________________________________________" 
echo
echo

a=$(grep -c "^$" /usr/local/bin/videoinfox 2> /dev/null)  # NUMBER OF BLANK LINES
b=$(sed -n -e '/#/p' /usr/local/bin/videoinfox | wc -l 2> /dev/null)  # NUMBER OF COMMENT ONLY LINES
c=$(sed -n '$=' /usr/local/bin/videoinfox 2> /dev/null)  # TOTAL LINES

d=$((c - a - b))  # CODE LINES = TOTAL LINES - BLANK LINES - COMMENT ONLY LINES
# GET VIDEOINFOX FILE SIZE AND LOCATION AND WRITE TO FILE:  ${base_dir}/videoinfox.code-stats.tmp
du -h /usr/local/bin/videoinfox > ${base_dir}/videoinfox.code-stats.tmp 2> /dev/null

# READ FILE SIZE
vsize=$(sed 's:/.*::' ${base_dir}/videoinfox.code-stats.tmp)

# READ FILE LOCATION
vlocat=$(cat ${base_dir}/videoinfox.code-stats.tmp | cut -c 6-)
printf " Code Lines .......  %s\n" "$d"

echo
printf " Comment Lines ....  %s\n" "$b"

echo
printf " Blank Lines ......  %s\n" "$a"

echo " _________________________"

echo
printf " Total Lines ...... %s\n" "$c"
echo
echo
echo " File Size:" "$vsize"
echo
echo " File Location:" "$vlocat"
#echo " White Spaces ....." $(wc -w < /usr/local/bin/videoinfox 2> /dev/null)  # White Space COUNT
echo
echo
echo -en " Enter Option: "
read -r -n1 optionstats
}
while true; do
codestats
case $optionstats in

    q)  # QUIT
    break;;

*)

esac
done
;;

    
    h)  # VERSION HISTORY
    clear
    less ${base_dir}/videoinfo-ver-history
    ;;

    l)
    
     function lastsearch {
         read -r lsearch < ${base_dir}/videoinfo.lastsearch-set
         clear
         echo
         echo "___________________________________________________________________________________________________________________"
         echo
         echo " "$der"  >>> SETTINGS >>> LAST SEARCH                                               Current Setting: "$lsearch" "
         echo "___________________________________________________________________________________________________________________"
         echo
         echo
         echo " If there are search results on the the home screen on exit, the below always applies to the next run."
         echo
         echo
         echo " 1 - Always Save                                                                                          q - Quit"  
         echo
         echo " 2 - Never Save"
         echo
         echo " 3 - Ask on Exit"
         echo
         echo
         echo -en " Enter Option: "
         read -r -n1 optionz
         echo
         }
        
              
         while true
         do
         lastsearch
        case $optionz in

         q)
         break;;
  
         1)
         
         echo "1" > ${base_dir}/videoinfo.lastsearch-set
         echo
         echo " Always Save . . ."
         sleep .7
         ;;
         2)
         echo "2" > ${base_dir}/videoinfo.lastsearch-set
         echo
         echo " Never Save . . . "
         sleep .7
         ;;

        
         3)
         echo "3" > ${base_dir}/videoinfo.lastsearch-set
         echo
         echo " Ask on Exit . . ."
         sleep .7
         ;;

         *)

         esac
         done

         ;;
    1)
    # SET TV DIRECTORY
    grabdir="$PWD"  # grab working directory 
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " $ver >>> SET TV DIRECTORY"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " No quotations needed for paths with spaces. Case sensative."
    echo
    read -r -p " Enter Directory: " specifydir2  # waiting fot user input - the directory you want to chang to 
    
         if [[ -z "$specifydir2" ]]; then
                echo
                echo " error: Nothing was entered"
            else
                if [[ -d "$specifydir2" ]]; then
                      echo
                      echo "$specifydir2" > ${base_dir}/videoinfo.tv-dir
                      read -r dir1 < ${base_dir}/videoinfo.tv-dir
                      echo " TV Directory Set to:" "$dir1"                  
                      else
                      echo
                      echo " error: Directory doesn't exist"                    
                fi
          fi       
          
          #read -p "     Press enter to Continue" 
          cd "$grabdir"  # restore working directory
          sleep 1.5
          ;;
    2)
    # SET MOVIES DIRECTORY
    grabdir="$PWD"  # grab working directory 
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content 
    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo 
    echo " ""$ver"" >>> SET MOVIE DIRECTORY"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " No quotations needed for paths with spaces. Case sensative."
    echo
    read -r -p " Enter Directory: " specifydir2  # waiting fot user input - the directory you want to chang to 
    
         if [[ -z "$specifydir2" ]]; then
                echo
                echo " error: Nothing was entered"
            else
                if [[ -d "$specifydir2" ]]; then
                      echo
                      echo "$specifydir2" > ${base_dir}/videoinfo.movies-dir
                      read -r dir2 < ${base_dir}/videoinfo.movies-dir
                      echo " Movie Directory Set to:" "$dir2"                  
                      else
                      echo
                      echo " error: Directory doesn't exist"                    
                fi
          fi       
          
          #read -p "     Press enter to Continue" 
          cd "$grabdir"  # restore working directory
          sleep 1.5
          ;;
    3)
    # SET <yt-dlp> DOWNLOAD DIRECTORY
    grabdir="$PWD"  # grab working directory 
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " $ver >>> SET YT-DLP DOWNLOAD DIRECTORY"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " No quotations needed for paths with spaces. Case sensative."
    echo
    read -r -p " Enter Directory: " specifydir2  # waiting fot user input - the directory you want to chang to 
    
         if [[ -z "$specifydir2" ]]; then
                echo
                echo " error: Nothing was entered"
            else
                if [[ -d "$specifydir2" ]]; then
                      echo
                      echo "$specifydir2" > ${base_dir}/videoinfo.yt-download-dir
                      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir
                      echo " Download Directory Set to:" "$dirsaved"                  
                      else
                      echo
                      echo " error: Directory doesn't exist"                   
                fi
          fi       
          
          #read -p "     Press enter to Continue" 
          cd "$grabdir"  # restore working directory
          sleep 1.5
          ;;
 4)
    # SET PARENT DIRECTORY
    grabdir="$PWD"  # grab working directory 
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " $ver >>> SET EXTRA DIRECTORY"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " No quotations needed for paths with spaces. Case sensative."
    echo
    read -r -p " Enter Directory: " specifydir2  # waiting fot user input - the directory you want to chang to 
    
         if [[ -z "$specifydir2" ]]; then
                echo
                echo " error: Nothing was entered"
            else
                if [[ -d "$specifydir2" ]]; then
                      echo
                      echo "$specifydir2" > ${base_dir}/videoinfo.parent-dir
                      read -r dir4 < ${base_dir}/videoinfo.parent-dir
                      echo " Extra Directory Set to:" "$dir4"                  
                      else
                      echo
                      echo " error: Directory doesn't exist"                    
                fi
          fi       
          
          #read -p "     Press enter to Continue" 
          cd "$grabdir"  # restore working directory
          sleep 1.5
          ;;
        
         y)  # CHECK FOR YT-DLP UPDATE

dirtemp="$PWD"  # save dir for restore after yt-dlp download      

# Yt-dlp download attempt.
clear
echo
echo 
echo 
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> Attempting to download the most recent version of Yt-dlp"
echo "___________________________________________________________________________________________________________________" 
echo
echo " If Yt-dlp can't be downloaded, the download attempt will be aborted."
echo
echo " If the download fails, it is most likely due to at least 1 of the following reasons:"
echo
echo "    - Your internet connection is down."
echo
echo "    - Github isn't reachable due to technical issues on their end."
echo
echo "    - There is no Yt-dlp release available in:  https://github.com/yt-dlp/yt-dlp/releases/latest/download"
echo
echo
echo " If this download fails, the download attempt will be tried again when you select the Yt-dlp Menu in Videoinfox."
echo
echo
echo " Note: The Yt-dlp Menu will not work until there is a copy of yt-dlp in:"
echo
echo " "$HOME"/.config/videoinfox"
echo
echo

cd ${tmp_dir}
 
wget https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp 2>/dev/null  # download yt-dlp 
if [[ -f ${tmp_dir}/yt-dlp ]]; then
    chmod a+rx ${tmp_dir}/yt-dlp  # set <yt-dlp-fetched> execute bit
    noisy_timeout 5 " Yt-dlp Downloaded . . ."
   
chkytdlp() {

    if [[ -f ${tmp_dir}/yt-dlp ]]; then
        ytexist=$(${base_dir}/yt-dlp --version)
    else
        ytexist="Not installed"
    fi

    clear 
    echo
    echo
    echo
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$der"" >>> CHECK YT-DLP UPDATE"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " Yt-dlp Home: https://github.com/yt-dlp/yt-dlp"
    echo
    echo " Downloaded From: https://github.com/yt-dlp/yt-dlp/releases/latest/download"
    echo
    echo
    echo " Version Check Complete"
    echo
    echo " Downloaded:" $(${tmp_dir}/yt-dlp --version)
    echo
    echo " Installed: " "$ytexist"
    echo
    echo
    echo " u - Update     d - Don't Update"  
    echo
    echo -en " Enter Option: "
    read -r -n1 optionytdlp
    echo         
}        
              
         while true; do
             chkytdlp
            case $optionytdlp in
                d)
                    #  DON'T UPDATE
                    rm ${tmp_dir}/* 2>/dev/null
                    cd "$dirtemp"  # restore directory
                    echo
                    echo " Yt-dlp Not Updated . . ."
                    sleep .7
                    break
                ;;
                u)
                    # UPDATE
                    rm ${base_dir}/yt-dlp 2> /dev/null
                    mv ${tmp_dir}/yt-dlp ${base_dir} 2> /dev/null       
                    ${base_dir}/yt-dlp --version > ${base_dir}/videoinfo.yt-dlp.version
                    rm ${tmp_dir}/* 2>/dev/null
                    cd "$dirtemp"  # restore directory
                    echo
                            
                    noisy_timeout 3 " Yt-dlp UPDATED . . ."
                    break
                ;;
            esac
         done
    else
         rm ${tmp_dir}/* 2>/dev/null     
         cd "$dirtemp"  # restore directory

         noisy_timeout 20 " Yt-dlp Download Failure . . ."
    fi
;;         
esac
done

rm ${tmp_dir}/* 2>/dev/null
;;

##################################################################################################################################################
###########################  HOME OPTION  y  Yt-dlp Menu  ########################################################################################
##################################################################################################################################################

y)       

grabdir="$PWD"  # grab working directory
pasteclip3=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content to restore to before this function was run
if ! command -v ${base_dir}/yt-dlp > /dev/null 2>&1; then  # if <yt-dlp> isnt found goto then

    # Yt-dlp download attempt.  Yt-dlp Menu won't start untl Yt-dlp is downloaded to: ${base_dir}/yt-dlp
    [[ -x "${base_dir}/yt-dlp" ]] && ytdlp_update

    if [[ -f ${base_dir}/yt-dlp ]]; then
        chmod a+rx ${base_dir}/yt-dlp  # set <yt-dlp-fetched> execute bit
        ${base_dir}/yt-dlp --version > ${base_dir}/videoinfo.yt-dlp.version # write yt-dlp ver number to file: yt-dlp.version 
        echo
        echo " Yt-dlp Downloaded . . ."
        echo
        # SAMPLE VIDEO URL BEING COPIED TO CLIPBOARD
        echo "https://www.youtube.com/watch?v=rNWPqfCJDnc" | xclip -sel clip 

        noisy_timeout 5 " $ver starting"

        cd "$dirtemp"  # restore directory
        rm ${base_dir}/wget-* 2> /dev/null  
    else
        echo
        echo " Yt-dlp Download Failure . . ."
        echo

        noisy_timeout 20 " $ver starting"

        cd "$dirtemp"  # restore directory
        rm ${base_dir}/wget-* 2> /dev/null
    fi
############################

else  # IF YT-DLP IS FOUND    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

###########################

read -r ytdlpver < ${base_dir}/videoinfo.yt-dlp.version

function menuy {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if ! [[ "$grabclip" = "http" ]]; then
    if ! [[ -f "$pasteclip" ]]; then
        echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    fi
fi
read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir
#######################  cd "$dirsaved" 

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

clear
echo
echo "Directory: ""$PWD"
echo "Clipboard:" "$pasteclip"
##################################################################################################################################################
#=================================================================================================================================================
#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY
#=================================================================================================================================================
##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

if [[ "$grabpaste" = "http" ]]; then
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
      ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

            if [[ "$ytdlpconfirm" = "" ]]; then

                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
                      dash0=$(echo "-") # not blinking

                           # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
                           #________________x________________________________________ _________________________________________________________
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " ""$der"" >>> YT-DLP MENU         Enter - Update Clipboard Display         yt-dlp Version: $ytdlpver"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " d "$dash0" Download Default     l - Last Download     v - View Downloads     p - Play Clipboard                 q - Quit"
                      echo " c "$dash0" Download Choose"
                      echo " s "$dash0" Self Destruct        g - Download List                            x - Clear Clipboard"
                      echo
                  
                      echo "" | xclip -sel clip  # clearing out the clipboard
                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
                  else 
                      
                      dash1=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
                      
                      echo
                      echo "YT-DLP Confirmed: "$ytdlpconfirm""
                      echo
                      echo "Download Directory: $dirsaved"  # dislpay default download directory
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " ""$der"" >>> YT-DLP MENU         Enter - Update Clipboard Display         yt-dlp Version: $ytdlpver"
                      echo "___________________________________________________________________________________________________________________"
                      echo

echo -e " d "$dash1" Download Default     l - Last Download     v - View Downloads     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                 q - Quit "

                      echo " c "$dash1" Download Choose"
                      echo " s "$dash1" Self Destruct        g - Download List                            x - Clear Clipboard"
                      echo                                                                                  
            fi
  else

      if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " ""$der"" >>> YT-DLP MENU         Enter - Update Clipboard Display         yt-dlp Version: $ytdlpver"
            echo "___________________________________________________________________________________________________________________"
            echo

echo -e " d - Download Default     l - Last Download     v - View Downloads     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                 q - Quit "
                                                      
            echo " c - Download Choose"
            echo " s - Self Destruct        g - Download List                            x - Clear Clipboard"
            echo                                                             

        else 

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo
            echo " ""$der"" >>> YT-DLP MENU         Enter - Update Clipboard Display         yt-dlp Version: $ytdlpver"        
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " d - Download Default     l - Last Download     v - View Downloads     p - Play Clipboard                 q - Quit"
            echo " c - Download Choose"
            echo " s - Self Destruct        g - Download List                            x - Clear Clipboard"
            echo
fi
fi

echo -en " Enter Option: "                             
read -r -n1 optiony

}
     while true
     do
     menuy
    case $optiony in
     q)  # QUIT
     clear
     break;;
     x)  # CLEAR CLIPBOARD  (DOWNLOAD LIST)
     echo "" | xclip -sel clip  # clearing out the clipboard
     pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
     ;;
     g)  # DOWNLOAD LIST  <YT-DLP MENU>

rm ${base_dir}/videoinfox-dl-Default~ 2> /dev/null  # tmp fix

echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null) # grab clipboard content
dwnlist() {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -f "$pasteclip" ]]; then
:
else
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
fi
 
# find default download list and write to file.
find ${base_dir}/videoinfox-dl-Default > ${base_dir}/videoinfox.dowload.list.default

# find user created download lists and write to file. these results also include the log files which shouldn't be listed here
find "$PWD" -type f \( -iname "videoinfox-dl*" \) > ${base_dir}/videoinfox.dowload.list

# removing all lines that contain  .log   this removes all  */.videoinfox-dl*.log listings from results. write file: videoinfox.dowload.list  
sed -i '/.log/d' ${base_dir}/videoinfox.dowload.list 
sed -i '/videoinfox-dl-Default/d' ${base_dir}/videoinfox.dowload.list  # remove default list from user list and write file

# count lines file for message display below:  (Copy 1 above User List to the the clipboard to: Download or Set...) 
copymessage=$(sed -n '$=' ${base_dir}/videoinfox.dowload.list 2> /dev/null)  # only reading, no writing
##################################################################################
##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################## 

# DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

# DEFAULT DIR NUMBER 1 FORMAT
dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
# DEFAULT DIR NUMBER 2 FORMAT
dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
# DEFAULT DIR NUMBER 3 FORMAT
dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
# DEFAULT DIR NUMBER 4 FORMAT
dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
# DEFAULT DIR NUMBER 5 FORMAT
dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
# NO MATCH ALL LESS BOLD
dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
# FORMAT PWD NAME FOR COMPARISON
echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

# FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

# FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

# FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

# FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

# FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
# LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
# DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

if [[ "$controldir" = "$dir5display" ]]; then 
    [[ "$dir5display" = "$dir1display" ]] && dirdisp="$dirdisplay1"
    [[ "$dir5display" = "$dir2display" ]] && dirdisp="$dirdisplay2"
    [[ "$dir5display" = "$dir3display" ]] && dirdisp="$dirdisplay3"
    [[ "$dir5display" = "$dir4display" ]] && dirdisp="$dirdisplay4"
fi

# DEFAULT DIR 5 DISPLAY
if [[ "$controldir" = "$dir5display" ]]; then
    # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
    dirdisp="$dirdisplay5"
else
    # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
    dirdisp="$dirdisplayno"
fi 

# DEFAULT DIR 1  DISPLAY
[[ "$controldir" = "$dir1display" ]] && dirdisp="$dirdisplay1"
# DEFAULT DIR 2  DISPLAY
[[ "$controldir" = "$dir2display" ]] && dirdisp="$dirdisplay2"
# DEFAULT DIR 3  DISPLAY
[[ "$controldir" = "$dir3display" ]] && dirdisp="$dirdisplay3"
# DEFAULT DIR 4  DISPLAY
# if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
[[ "$controldir" = "$dir4display" ]] && dirdisp="$dirdisplay4"


################################################################################
##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################
########## blinking routine for display ##########

# blinking
downloadlist1=$(echo -e "\033[5mDOWNLOAD LIST\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking
downloadlist0=$(echo "DOWNLOAD LIST")

# blinking
dash1=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking
dash0=$(echo "-")

# if file exists goto then
if [[ -f "$pasteclip" ]]; then
    finalresult="$downloadlist1"  # if the file exists: blinking   DOWNLOAD LIST
    finalresult2="$dash1"  #                            blinking   -
else
    finalresult="$downloadlist0"  # if the file doesn't exist: non blinking   DOWNLOAD LIST
    finalresult2="$dash0"  # if                                non blinking   -
fi

########## end blinking routine #################
#########################################################################################################################################################
# START Routine to find out if clipboard contents  =  The default download list or a user list - dash blink or not:  Set User List and Delete User List
#########################################################################################################################################################

# REFORMAT PASTECLIP VARIBLE FOR COMPARISON TO CONTROL VARIBLE
echo "$pasteclip" > ${base_dir}/videoinfox.c.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.c.tmp | tr "/" " " > ${base_dir}/videoinfox.c.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.c.tmp   # remove .c.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.c.tmp2 # remove horizontal whitespace from file an write
# REFORMATTED PASTECLIP
read -r ctmp2 < ${base_dir}/videoinfox.c.tmp2  # clipboard content with default list or user list.
                                                        # list name with full path: with slashes and spaces removed
# CONTROL VARIABLE
ctmpprefformat=""$HOME"/.config/videoinfox/videoinfox-dl-Default"
# REFORMAT CONTROL VARIABLE FOR COMPARISON TO PASTECLIP VARIBLE
echo "$ctmpprefformat" > ${base_dir}/videoinfox.dlname.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.dlname.tmp | tr "/" " " > ${base_dir}/videoinfox.dlname.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.dlname.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dlname.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE
read -r ctmp3 < ${base_dir}/videoinfox.dlname.tmp2  # default list name with full path: with slashes and spaces removed
if [[ -z "$pasteclip" ]]; then
    dashit2="$dash0"  # no blink dash for: Set User List and Delete User List
else
    if [[ "$ctmp2" = "$ctmp3" ]]; then
            dashit2="$dash0"  # no blink dash for: Set User List and Delete User List
    else
        dashit2="$dash1"  #    blink dash for: Set User List and Delete User List
    fi
fi
# CONTROL VARIABLE 2  (clear Set User List filename)
read -r chkulistset < ${base_dir}/videoinfox.set-user-list
# REFORMAT CONTROL VARIABLE 2 FOR COMPARISON TO PASTECLIP VARIBLE
echo "$chkulistset" > ${base_dir}/videoinfox.chkulist.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.chkulist.tmp | tr "/" " " > ${base_dir}/videoinfox.chkulist.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.chkulist.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.chkulist.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE 2
read -r ctmp4 < ${base_dir}/videoinfox.chkulist.tmp2  # default list name with full path: with slashes and spaces removed
#  REMOVE TMP2 FILES
rm ${base_dir}/videoinfox.c.tmp2
rm ${base_dir}/videoinfox.dlname.tmp2 

#########################################################################################################################################################
# END Routine to find out if clipboard contents  =  The default download list or a user list - dash blink or not:  Set User List and Delete User List
#########################################################################################################################################################

clear
cat ${base_dir}/videoinfox.dowload.list  # display user created download lists recursively reachable fron current directory.
echo
echo "Default List:" 
cat ${base_dir}/videoinfox.dowload.list.default  # display default download list name with full path

#if [[ -z "$copymessage" ]]; then  # empty user list  (no user lists recursively reachable from the curent directory)
#       :

#  else  # at least 1 list  (1 or more user lists recursively reachable from the curent directory)        
      # echo
      # echo "Copy 1 above List to the the clipboard."
#fi

read -r ulistset < ${base_dir}/videoinfox.set-user-list  # set user list for videoinfox -u shortcut
echo
# CEAR USER SET LIST IF IT GETS DELETED OUTSIDE OF THE VIDEOINFOX INTERFACE
if [[ -f "$chkulistset" ]]; then
       :
   else  # if the user set list doesn't exist, clear the user set list.
       touch ${base_dir}/videoinfox.set-user-list
       ctmp4=""
fi

if [[ ! -z "$ctmp4" ]]; then
         echo "User Set List:"   # display if there is at least one line
         echo "$ulistset"
         echo
fi

echo "Copy 1 above list to the the clipboard. Then press enter."
echo

echo "Directory:" "$PWD"
echo "Clipboard:" "$pasteclip"          #
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$der"" >>> DOWNLOAD LIST       Enter - Update Clipboard Display              "$dirdisp" - Default Dirs"
echo "___________________________________________________________________________________________________________________" 
echo
echo " d "$finalresult2" Download List     s "$dashit2" Set User List        k - Default List       m - Create Directory               q - Quit"
echo " v "$finalresult2" View List         c - Create User List     a "$dashit2" Add to Queue       x - Clear Clipboard"    
echo " l - View Logs         r "$dashit2" Delete User List     b - Download Queue                                        h - Help"
echo 
echo -en " Enter Option: "
read -r -n1 optiond
echo

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -z "$pasteclip" ]]; then
       echo
       echo " Clipboard is empty . . ."
       sleep .18
     
   else
       :
fi
}

while true; do
dwnlist
case $optiond in

# LOAD STORED DIRECTORIES
#read -r dir1 < ${base_dir}/videoinfo.tv-dir 2> /dev/null
#read -r dir2 < ${base_dir}/videoinfo.movies-dir 2> /dev/null
#read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null
#read -r dir4 < ${base_dir}/videoinfo.parent-dir 2> /dev/null
#read -r dir5 < ${base_dir}/videoinfo.dir-at-exit 2> /dev/null

1)
cd "$dir1"
;;
2)
cd "$dir2"
;;
3)
cd "$dirsaved"
;;

4)
cd "$dir4"
;;
5)
cd "$dir5"
;;
         
q)  # QUIT (DOWNLOAD LIST)
echo "$pasteclip3" | xclip -sel clip  # restore clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
break;;
x)  # CLEAR CLIPBOARD  (DOWNLOAD LIST)
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
;;
m)
##################################################################################################################################################
###########################   CREATE DIRECTORY  n   (DOWNLOAD LIST)   ############################################################################
##################################################################################################################################################

pasteclip2=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content   save to restore on option quit
echo "" | xclip -sel clip  # clearing the clipboard
function navtree {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -d "$pasteclip" ]]; then
      :

  else      
      echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
     
fi
clear
# recursive list of directories for the user to copy one to the clipboard and press  c   to change to that directory
#### find "$PWD" -type d -iname "*" | sort -u 2>/dev/null

find "$PWD" -type d -iname "*" | sort -u > ${tmp_dir}/nt-list.tmp 2>/dev/null

# NUMBER THE LIST
sed '/./='  ${tmp_dir}/nt-list.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/nt-list-number.tmp 2>/dev/null

cat ${tmp_dir}/nt-list-number.tmp
# recursive number of directories found
ttotal=$(find  "$PWD" -type d -iname "*" 2>/dev/null | wc -l)   

notify-send "Videoinfox is done processing: Directory Tree" "Total Directories Found: "$ttotal" " # GUI Notification.

# recursive number of files found
#ttotalnum=$(find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) 2>/dev/null | wc -l)
##################################################################################
##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################## 

# DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

# DEFAULT DIR NUMBER 1 FORMAT
dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
# DEFAULT DIR NUMBER 2 FORMAT
dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
# DEFAULT DIR NUMBER 3 FORMAT
dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
# DEFAULT DIR NUMBER 4 FORMAT
dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
# DEFAULT DIR NUMBER 5 FORMAT
dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
# NO MATCH ALL LESS BOLD
dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
# FORMAT PWD NAME FOR COMPARISON
echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

# FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

# FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

# FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

# FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

# FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
# LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
# DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

if [[ "$controldir" = "$dir5display" ]]; then 
    [[ "$dir5display" = "$dir1display" ]] && dirdisp="$dirdisplay1"
    [[ "$dir5display" = "$dir2display" ]] && dirdisp="$dirdisplay2"
    [[ "$dir5display" = "$dir3display" ]] && dirdisp="$dirdisplay3"
    [[ "$dir5display" = "$dir4display" ]] && dirdisp="$dirdisplay4"
fi

# DEFAULT DIR 5 DISPLAY
if [[ "$controldir" = "$dir5display" ]]; then
    # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
    dirdisp="$dirdisplay5"
else
    # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
    dirdisp="$dirdisplayno"
fi 

# DEFAULT DIR 1  DISPLAY
[[ "$controldir" = "$dir1display" ]] && dirdisp="$dirdisplay1"
# DEFAULT DIR 2  DISPLAY
[[ "$controldir" = "$dir2display" ]] && dirdisp="$dirdisplay2"
# DEFAULT DIR 3  DISPLAY
[[ "$controldir" = "$dir3display" ]] && dirdisp="$dirdisplay3"
# DEFAULT DIR 4  DISPLAY
# if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
[[ "$controldir" = "$dir4display" ]] && dirdisp="$dirdisplay4"

################################################################################
##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################
########## blinking routines for display ##########

# not blinking Play Directory
playdir1=$(echo "Play Directory")
# blinking Play Directory
playdir2=$(echo -e "\033[5mPlay Directory\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking dash
dash0=$(echo "-")
# blinking dash
dash1=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
# get file count of videos one directory deep for blinking   Play Directory
blinkit=$(find_supported_files --count)

# if find results are zero goto then
if [[ "$blinkit" = 0 ]]; then
      blinkit2="$playdir1"  # zero files. non bliking  Playdirectory
      bdash="$dash0"
  else
      blinkit2="$playdir2" # not zero files. blinking  Play Directory
      bdash="$dash1"
fi
# not blinking
changedir1=$(echo "Change Directory")
# blinking
changedir2=$(echo -e "\033[5mChange Directory\033m\033[0m\033[5m\033[5m\033[0m")

# if directory exists goto then
if [[ -d "$pasteclip" ]]; then
      changedir3="$changedir2"  # if the directory exists, blinking  Change Directory
  else
      changedir3="$changedir1"  # if the directory doesn't exist, non blinking  Change Directory
fi
########## end blinking routines ################## 
echo
echo "Treetop:" "$grabdirfornav2"
echo "Total Directories: "$ttotal" "
#echo "Total Video Files:" "$ttotalnum"                                                                                                            
echo
echo "Current Directory:" "$PWD"
#echo "Video Files:" "$blinkit"
#echo
#echo "Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$der"" >>> CREATE DIRECTORY                                                  "$dirdisp" - Default Dirs"
echo "___________________________________________________________________________________________________________________" 
echo
echo " c - "$changedir3"     m - Create Directory     n - Change Treetop                                     q - Quit"
echo " u - Up One Level"
echo " t - Treetop"
echo
echo -en " Enter Option: "
read -r -n1 option
echo
}
  
         while true
         do
         navtree
        case $option in
         
         q)  # QUIT
    ##############################     cd "$grabdirfornav2" &>/dev/null   # restore directory
         echo "" | xclip -sel clip  # clearing the clipboard
         pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
         break
         ;;
         1)  # CD DIRECTORY TO TV    
         cd "$dir1" 
         grabdirfornav2="$dir1"
         ;;
    
         2)  # CD DIRECTORY TO MOVIES
         grabdirfornav2="$dir2"
         cd "$dir2" 
         ;;

         3)  # CHANGE DIRECTORY TO DOWNLOADS
         grabdirfornav2="$dirsaved"
         cd "$dirsaved" 
         ;;
   
         4)  # CHANGE DIRECTORY TO EXTRA   
         grabdirfornav2="$dir4"
         cd "$dir4" 
         ;;

         5)  # CHANGE DIRECTORY TO LAST EXIT
         grabdirfornav2="$dir5"
         cd "$dir5" 
         ;;
       
       
         u)  # UP ONE LEVEL 
         if [[ "$grabdirfornav2" = "$PWD" ]]; then
               echo
               echo " At treetop. Can't go any higher . . ."
               sleep .50

           else
               cd .. &>/dev/null
         fi 
         ;;
         t)  # TREE TOP
         cd "$grabdirfornav2" &>/dev/null
         ;;          
         c)  # CHANGE DIRECTORY
# GETTING LINECOUNT
linecount=$(wc -l ${tmp_dir}/nt-list.tmp | cut -d' ' -f1)

echo
read -r -p " Enter line number to change directory: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
if [[ $linenumber -gt $linecount ]]; then 
      echo
      echo " Number out of range . . ."
      sleep .9
  else

tail -n +"$linenumber" ${tmp_dir}/nt-list.tmp > ${tmp_dir}/nt-list.tmp2 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

read line < ${tmp_dir}/nt-list.tmp2

      cd "$line" 2> /dev/null
 
      IFS=$OLDIFS
  
      fi
      fi
;;        

 
         m)  # CREATE DIRECTORY  (CREATE DIRECTORY)
         echo
         echo " Enter name for new directory or enter with no entry to cancel . . ."
         echo
         read -r -p " Create Directory: " newdir  # waiting fot user input.

         direxist4="$PWD""/""$newdir"

         if [[ -z "$newdir" ]]; then
               echo
               echo " Nothing was entered . . ."
               sleep 1.2

           else
               if [[ -d "$direxist4" ]]; then
                     echo
                     echo " Directory already exists . . ."
                     sleep 1.2

                 else
                     mkdir "$newdir" 2> /dev/null
                     echo
                     echo " Directory Created:" "$PWD""/""$newdir"
                     sleep 1.2
           fi
         fi

         ;;

         
         ########################################################################################################################################
         n)  # CHANGE TREETOP (CREATE DIRECTORY)  ###############################################################################################
         ########################################################################################################################################

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo
echo " $ver >>> CHANGE TREETOP"
echo "___________________________________________________________________________________________________________________"
echo
echo " No quotations needed for paths with spaces. Case sensative."
echo 
echo " Enter directory or paste directory if in clipboard."
echo
read -r -p " " specifydir  # waiting fot user input - the directory you want to chang to 
    
    if [[ -z "$specifydir" ]]; then
               echo
               echo " Nothing was entered . . ."
               sleep .75
          else
              if [[ -d "$specifydir" ]]; then
                     echo
                     grabdirfornav2="$specifydir"
                     cd "$specifydir"   # change the directory
                     echo " Treetop changed to: $PWD"  # <pwd>  print current working directory to the screen
                     sleep 1.5                   
                else
                     echo
                     echo " No such directory . . ."
                     sleep 1.5                   
          fi
    fi       
echo

;;

         esac
         done
         ;;

a)  # ADD TO QUEUE (DOWNLOAD LIST)
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

ddlist=${base_dir}/videoinfox-dl-Default

if [[ -f "$pasteclip" ]]; then
      if [[ "$pasteclip" == "$ddlist" ]]; then
            :
        else
            echo "$pasteclip" >> ${base_dir}/videoinfox-download.queue
            echo
            echo " ""$pasteclip"
            echo
            echo " Download list added to queue . . ."
            echo "" | xclip -sel clip  # clearing out the clipboard
            sleep 1.7
      fi

  else
      :
fi

;;
    b)   # DOWNLOAD QUEUE  (DOWNLOAD LIST)

# SAVE CURRENT DIRECTORY FOR RESTORE ON FUNCTION
savethedir="$PWD"

function dwnque {

clear

if [[ -f ${base_dir}/videoinfox-download.queue ]]; then
      # REMOVE DUPLICATES
      cat -n ${base_dir}/videoinfox-download.queue | sort -uk2 | sort -n | cut -f2- > ${base_dir}/videoinfox-download.queue.tmp
      mv ${base_dir}/videoinfox-download.queue.tmp ${base_dir}/videoinfox-download.queue
      
      # REMOVE BLANK LINES
      squash ${base_dir}/videoinfox-download.queue
      
      cat ${base_dir}/videoinfox-download.queue

  else
      echo
      echo " Download queue empty . . ."
      echo
fi
      
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$der"" >>> DOWNLOAD QUEUE"        
echo "___________________________________________________________________________________________________________________"
echo
echo " b - Download Queue     d - Delete Queue                                                                  q - Quit"
echo 
echo -en " Enter Option: "
read -r -n1 optiondq
echo
}
while true; do
dwnque
case $optiondq in
        q)  # QUIT   (DOWNLOAD QUEUE)
        break ;;

      
        d)  # DELETE QUEUE LIST  (DOWNLOAD QUEUE)
        function menudelq {
   
        echo
        echo " Delete Download Queue?"
        echo
        echo " y - Yes     n - No"  
        echo 
        echo -en " Enter Option: "
        read -r -n1 optiondelq
        echo
        }

        while true
        do
      menudelq
      case $optiondelq in

      y)  # YES
        if [[ -f ${base_dir}/videoinfox-download.queue ]]; then
              rm ${base_dir}/videoinfox-download.queue 2> /dev/null
              echo
              echo " Download Queue Deleted . . ."
              sleep 1.7
          else
              echo
              echo " Download Queue Was Already Deleted . . ."
              sleep 1.7
        fi
        break
        ;;
        n)  # NO
        break;;

        *)
        
        esac
        done
        ;;
        b)  # DOWNLOAD QUEUE  (DOWNLOAD QUEUE)

# READ USER SET LIST FOR REMOVAL IF IT IS IN THE DOWNLOAD QUEUE
read usersetlist < ${base_dir}/videoinfox.set-user-list

#################################################
##########  START DOWNLOAD QUEUE LOOP  ########## 
#################################################

if [[ -f ${base_dir}/videoinfox-download.queue ]]; then

clear

# DOWNLOAD QUEUE FILE
input1=${base_dir}/videoinfox-download.queue
# LOOP 1 READ LINE BY LINE DOWNLOAD QUEUE LIST
while read -r line; do

input2="$line"

echo
echo 
echo -e "Processing Download List:" "\033[5m"$line"\033m\033[0m"

# REMOVE BLANK LINES IN CURRENT DOWNLOAD LIST
squash "$line"

# WRITE LINE TO TEMP FILE.  DOWNLOAD LIST WITH FULL PATH
echo "$line" > ${tmp_dir}/videoinfox-queue.tmp

# REMOVE FILE NAME FROM PATH AND WRITE FILE
sed -i 's%/[^/]*$%%' ${tmp_dir}/videoinfox-queue.tmp 

# READ FILE WHICH IS PATH ONLY
read -r abc < ${tmp_dir}/videoinfox-queue.tmp

# CHANGE TO READ PATH
cd "$abc"

# CREATE LOG FILE FOE CURRENT DOWNLOAD LIST 
logfile="$line".log  # tag  .log  onto the users Download List  */.videoinfox-dl*.log 
echo ""$ver" >>> DOWNLOAD LIST >>> Logfile:" "$line"".log" > "$logfile"  # create file
echo >> "$logfile"

# IF DOWNLOAD LIST = SET USER LIST THEN REMOVE
if [[ "$line" == "$usersetlist" ]]; then
      touch ${base_dir}/videoinfox.set-user-list
  else
      :
fi
# LOOP 2 READ LINE BY LINE FROM CURRENT DOWNLOAD LIST
    while read -r line  
    do

    echo

    ${base_dir}/yt-dlp "$line"  # download url

    echo
    echo "Logging URL and Filename to:" "$logfile"

    # logging yt-dlp output
    echo "$line" >> "$logfile" 
    ${base_dir}/yt-dlp "$line" | tee >> "$logfile"
    echo >> "$logfile" 

    ############  REMOVE UNWANTED LOG INFO  ############# 
    sed -i '/\[youtube\]/d' "$logfile" &> /dev/null  # removing lines that start with  [youtube]
    sed -i '/\[info\]/d' "$logfile" &> /dev/null  # removing lines that start with  [info]
    sed -i 's/\[download\]//' "$logfile" &> /dev/null  # remove   [download]   from the end of the line.
    sed -i 's/has already been downloaded//' "$logfile" &> /dev/null  # remove   has already been downloaded   from the end of the line.
    sed -i -e 's/^[ \t]*//' "$logfile" &> /dev/null  # remove spaces at beginning of line.
    #####################################################    

    done < "$input2"

done < "$input1"

###############################################
##########  END DOWNLOAD QUEUE LOOP  ########## 
###############################################

echo
echo
echo -e "$der" "\033[5mdone processing download queue . . .\033m\033[0m"
echo
echo "Press enter to exit this screen"

notify-send "Videoinfox messsage: Done Processing Download Queue . . ."

read -p ""
echo "" | xclip -sel clip  # clearing out the clipboard

cd "$savethedir"  # RESTORE DIRECTORY
else
    :
fi
;;

esac
done
;;
c)  # CREATE USER LIST  <DOWNLOAD LIST>
echo
echo " If the name starts with any spaces they will be ignored. Spaces are fine after the first character."
echo
echo " The first character for the filename can be:  a dash -  or  an underscore _   or  a dot ."
echo
read -r -p " Create New List: " createulist  # waiting fot user input. grabbing new filename

if [[ -z "$createulist" ]]; then
      echo
      echo " Nothing was entered . . ."
      sleep .7

  else

      if [[ -f "videoinfox-dl""$createulist" ]]; then
            echo
            echo " File already exists . . ."
            sleep .75

        else

ulistname="$PWD/videoinfox-dl"$createulist""  # add user input to end of:  current directory/videoinfox-dl
touch "$ulistname"  #  create user list with full path and filename
echo
echo " User List Created: "$ulistname""
echo
echo
sleep .75

      fi
fi
;; 
s)  # SET USER LIST  <DOWNLOAD LIST>
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

###########################################################################################################################################################
# START Routine to find out if clipboard contents  =  The default download list or a user list.  only a user list can:  Set User List and Delete User List
###########################################################################################################################################################

# REFORMAT PASTECLIP VARIBLE FOR COMPARISON TO CONTROL VARIBLE
echo "$pasteclip" > ${base_dir}/videoinfox.c.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.c.tmp | tr "/" " " > ${base_dir}/videoinfox.c.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.c.tmp   # remove .c.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.c.tmp2 # remove horizontal whitespace from file an write
# REFORMATTED PASTECLIP
read -r ctmp2 < ${base_dir}/videoinfox.c.tmp2  # clipboard content with default list or user list.
                                                        # list name with full path: with slashes and spaces removed
# CONTROL VARIABLE
ctmpprefformat=""$HOME"/.config/videoinfox/videoinfox-dl-Default"
# REFORMAT CONTROL VARIABLE FOR COMPARISON TO PASTECLIP VARIBLE
echo "$ctmpprefformat" > ${base_dir}/videoinfox.dlname.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.dlname.tmp | tr "/" " " > ${base_dir}/videoinfox.dlname.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.dlname.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dlname.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE
read -r ctmp3 < ${base_dir}/videoinfox.dlname.tmp2  # default list name with full path: with slashes and spaces removed
if [[ -z "$pasteclip" ]]; then
        :

   else
   
        if [[ "$ctmp2" = "$ctmp3" ]]; then
               echo 
               echo " The Default List can't be a User Set List. Only user created lists . . ."
               echo
               read -p " Press enter to Continue"

           else  # clipbaord = User List
                echo "$pasteclip" > ${base_dir}/videoinfox.set-user-list
                
                echo
                echo " ""$pasteclip"
                echo
                echo " User List Set for option: videoinfox -l"
                echo
                notify-send "Videoinfox Message: User List Set for option: videoinfox -l" ""$pasteclip"" # GUI Notification.

                read -p " Press enter to Continue"

                echo "" | xclip -sel clip  # clearing out the clipboard
                pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content 
   
        fi
fi
#  REMOVE TMP2 FILES
rm ${base_dir}/videoinfox.c.tmp2
rm ${base_dir}/videoinfox.dlname.tmp2

##########################################################################################################################################################
# END Routine to find out if clipboard contents  =  The default download list or a user list.  only a user list can:  Set User List and Delete User List
##########################################################################################################################################################

;;
r)  # DELETE USER LIST  <DOWNLOAD LIST>
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

###########################################################################################################################################################
# START Routine to find out if clipboard contents  =  The default download list or a user list.  only a user list can:  Set User List and Delete User List
###########################################################################################################################################################
# Also, check if the User List in the clipboard  =  Set User List  if it is, the set user list will be set to null
###########################################################################################################################################################

# REFORMAT PASTECLIP VARIBLE FOR COMPARISON TO CONTROL VARIBLE
echo "$pasteclip" > ${base_dir}/videoinfox.c.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.c.tmp | tr "/" " " > ${base_dir}/videoinfox.c.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.c.tmp   # remove .c.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.c.tmp2 # remove horizontal whitespace from file an write
# REFORMATTED PASTECLIP
read -r ctmp2 < ${base_dir}/videoinfox.c.tmp2  # clipboard content with default list or user list.
                                                        # list name with full path: with slashes and spaces removed
# CONTROL VARIABLE
ctmpprefformat=""$HOME"/.config/videoinfox/videoinfox-dl-Default"
# REFORMAT CONTROL VARIABLE FOR COMPARISON TO PASTECLIP VARIBLE
echo "$ctmpprefformat" > ${base_dir}/videoinfox.dlname.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.dlname.tmp | tr "/" " " > ${base_dir}/videoinfox.dlname.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.dlname.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dlname.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE
read -r ctmp3 < ${base_dir}/videoinfox.dlname.tmp2  # default list name with full path: with slashes and spaces removed

# CONTROL VARIABLE 2  (clear Set User List filename)
read -r chkulistset < ${base_dir}/videoinfox.set-user-list
# REFORMAT CONTROL VARIABLE 2 FOR COMPARISON TO PASTECLIP VARIBLE
echo "$chkulistset" > ${base_dir}/videoinfox.chkulist.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.chkulist.tmp | tr "/" " " > ${base_dir}/videoinfox.chkulist.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.chkulist.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.chkulist.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE 2
read -r ctmp4 < ${base_dir}/videoinfox.chkulist.tmp2  # default list name with full path: with slashes and spaces removed
if [[ -z "$pasteclip" ]]; then
        :

   else
   
        if [[ "$ctmp2" = "$ctmp3" ]]; then
                :

           else  # clipbaord = User List

                function menudul {
                clear
                echo
                echo " Delete User List:" "$pasteclip"
                echo
                echo " y - Yes     n - No"  
                echo 
                echo -en " Enter Option: "
                read -r -n1 option
                echo
                }

                while true
                do
              menudul
              case $option in

    
                y)  # YES
  
                if [[ "$ctmp2" = "$ctmp4" ]]; then
                        touch ${base_dir}/videoinfox.set-user-list
                        echo "" | xclip -sel clip  # clearing out the clipboard
                        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                   else
                        :
                fi                
                rm "$pasteclip" 2>/dev/null
                rm "$pasteclip".log 2>/dev/null

                echo
                echo " User List DELETED . . ."
                echo 
                sleep .75
                break;; 

        
                n)  # NO 
                echo
                echo " User List SAVED . . ."
                echo   
                sleep .75
                break;;
      
                *)
                
                
                esac
                done     
                   
        fi
fi
#  REMOVE TMP2 FILES
rm ${base_dir}/videoinfox.c.tmp2
rm ${base_dir}/videoinfox.dlname.tmp2
rm ${base_dir}/videoinfox.chkulist.tmp2

##########################################################################################################################################################
# END Routine to find out if clipboard contents  =  The default download list or a user list.  only a user list can:  Set User List and Delete User List
##########################################################################################################################################################
;;

k)  # DEFAULT LIST  <DOWNLOAD LIST>

echo "" | xclip -sel clip  # clearing out the clipboard

function ddefault {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
########## start blinking and error correcting routine #################

# blinking
addtodefault1=$(echo -e "\033[5mAdd to Default List\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking
addtodefault0=$(echo "Add to Default List")
checktheclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$checktheclip" = "http" ]]; then
      atd="$addtodefault1"
      
  else      
      atd="$addtodefault0"
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content      

fi

########## end blinking and error correcting routine #################

# # DEFAULT LIST - REMOVE DUPLICATES, BLANK LINES and ANY LINES NOT STARTING WITH HTTP
cat -n ${base_dir}/videoinfox-dl-Default | sort -uk2 | sort -n | cut -f2- > ${base_dir}/videoinfox-dl-Default.tmp
mv ${base_dir}/videoinfox-dl-Default.tmp ${base_dir}/videoinfox-dl-Default

squash ${base_dir}/videoinfox-dl-Default 2>/dev/null  # remove any blank lines in the list
sed -i '/http/!d' ${base_dir}/videoinfox-dl-Default  # remove all lines not starting with  http

clear
cat ${base_dir}/videoinfox-dl-Default  # display default download list
echo
echo "Copy 1 url to the clipboard then Add to Default List to add the url."
echo
echo "Directory:" "$PWD"
echo "Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$der"" >>> DEFAULT DOWNLOAD LIST                                     Enter - Update Clipboard Display"
echo "___________________________________________________________________________________________________________________" 
echo
echo " a - "$atd"     r - Remove Last Entry     c - Clear Default List     x - Clear Clipboard     q - Quit"
echo
echo -en " Enter Option: "
read -r -n1 optiondd
echo
}

while true; do
ddefault
case $optiondd in
         
q)  # QUIT  <DEFAULT LIST>
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
break;;
x) #  CLEAR CLIPBOARD  <DEFAULT LIST> 
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
;;
c)  # CLEAR DEFAULT LIST   <DEFAULT LIST>  
function yesorno {
echo
echo " Clear the Default List?"
echo
echo " y - Yes     n - No"  
echo 
echo -en " Enter Option: "
read -r -n1 optionyn
echo
}

while true; do
    yesorno
    case $optionyn in
    
    y) 
    # CREATING EMPTY DEFAULT DOWNLOAD LIST WITH LIST EMPTY MESSAGE
    touch ${base_dir}/videoinfox-dl-Default
    echo "Default Download List Empty" >> ${base_dir}/videoinfox-dl-Default
 
    rm ${base_dir}/videoinfox-dl-Default.log 2> /dev/null    
 
    echo
    echo " Default List CLEARED . . ."
    echo 
    sleep .75
    break;; 
 
       
    n) 
    echo
    echo " Default List SAVED . . ."
    echo     
    sleep .75

    break;;

*)
          
esac
done
;;

a)  # ADD TO DEFAULT LIST  <DEFAULT LIST>

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
echo "$pasteclip" >> ${base_dir}/videoinfox-dl-Default
# notify-send "Videoinfox Message: Added to Default Download List." ""$pasteclip"" # GUI Notification.
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
;;
r)  # REMOVE LAST LINE IN THE DEFAULT DOWNLOAD LIST <DEFAULT LIST>

sed -i '$d' ${base_dir}/videoinfox-dl-Default
;;
*)

esac
done
;;
d)  # DOWNLOAD THE URL LIST <DOWNLOAD LIST>
clear

dirclip="$PWD"

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -f "$pasteclip" ]]; then

# check if   $pasteclip   contains   Default List   or   User Created list 
find ${base_dir}/videoinfox-dl-Default > ${base_dir}/videoinfox.default2
checkclip=$(cat ${base_dir}/videoinfox.default2)
# PROCESSING DEFAULT LIST
if [[ "$checkclip" = "$pasteclip" ]]; then 

read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null
cd "$dirsaved" # Change directory to default download directory

# DEFAULT LIST - REMOVE DUPLICATES, BLANK LINES and ANY LINES NOT STARTING WITH HTTP
cat -n ${base_dir}/videoinfox-dl-Default | sort -uk2 | sort -n | cut -f2- > ${base_dir}/videoinfox-dl-Default.tmp
mv ${base_dir}/videoinfox-dl-Default.tmp ${base_dir}/videoinfox-dl-Default
squash ${base_dir}/videoinfox-dl-Default 2>/dev/null  # remove any blank lines in the list
sed -i '/http/!d' ${base_dir}/videoinfox-dl-Default  # remove all lines not starting with  http
else # PROCESSING USER CREATED LIST

echo "$pasteclip" | sed 's|\(.*\)/.*|\1|' > ${base_dir}/videoinfox.userlist-tmp # remove last slash and filenname leaving only path
read -r grablistdir < ${base_dir}/videoinfox.userlist-tmp 2> /dev/null
cd "$grablistdir"  # change directory to list location

# USER CREATED LIST - REMOVE DUPLICATES, BLANK LINES and ANY LINES NOT STARTING WITH HTTP
cat -n "$pasteclip" | sort -uk2 | sort -n | cut -f2- > ${base_dir}/videoinfox-dl-userlist.tmp  # remove duplicates
mv ${base_dir}/videoinfox-dl-userlist.tmp "$pasteclip"
squash "$pasteclip" 2>/dev/null  # remove any blank lines in the list
sed -i '/http/!d' "$pasteclip" 2>/dev/null  # remove all lines not starting with  http
#########################################################################################################################################################
# START Routine to find out if clipboard content  =  set user list filename  if it does, the file will be cleared from the screen after list download
#########################################################################################################################################################

# REFORMAT PASTECLIP VARIBLE FOR COMPARISON TO CONTROL VARIBLE
echo "$pasteclip" > ${base_dir}/videoinfox.c.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.c.tmp | tr "/" " " > ${base_dir}/videoinfox.c.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.c.tmp   # remove .c.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.c.tmp2 # remove horizontal whitespace from file an write
# REFORMATTED PASTECLIP
read -r ctmp2 < ${base_dir}/videoinfox.c.tmp2  # filename in clipboard with full path: with slashes and spaces removed
              
# CONTROL VARIABLE
read -r getuserlist < ${base_dir}/videoinfox.set-user-list
# REFORMAT CONTROL VARIABLE FOR COMPARISON TO PASTECLIP VARIBLE
echo "$getuserlist" > ${base_dir}/videoinfox.checku.tmp  # write filename to file: ${base_dir}/videoinfox.checku.tmp 
cat ${base_dir}/videoinfox.checku.tmp | tr "/" " " > ${base_dir}/videoinfox.checku.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.checku.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.checku.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE
read -r ctmp5 < ${base_dir}/videoinfox.checku.tmp2  # set user list filename with full path: with slashes and spaces removed
if [[ "$ctmp2" = "$ctmp5" ]]; then
                touch ${base_dir}/videoinfox.set-user-list
           
           else
                :
fi 
#  REMOVE TMP2 FILES
rm ${base_dir}/videoinfox.c.tmp2
rm ${base_dir}/videoinfox.checku.tmp2

fi
#########################################################################################################################################################
# END Routine to find out if clipboard content  =  set user list filename  if it does, the file will be cleared from the screen after list download
#########################################################################################################################################################
rm videoinfox-dl*~ &> /dev/null  # duplicate lists were showing up with   ~   added onto the filename

logfile="$pasteclip".log  # tag  .log  onto the users Download List  */.videoinfox-dl*.log 
echo ""$ver" >>> DOWNLOAD LIST >>> Logfile:" "$pasteclip"".log" > "$logfile"  # create file
echo >> "$logfile"

#justfile=$(echo "$pasteclip" | sed 's|.*/||')  # ended up not using. grabs filename minus path

input="$pasteclip"  # input file for download loop (clipboard contents)
################  DOWNLOAD LOOP START  ###################################################################################################################

while read -r line; do

echo

${base_dir}/yt-dlp "$line"  # download url
echo
echo "Logging URL and Filename to:" "$logfile" 
# logging yt-dlp output
echo "$line" >> "$logfile" 
${base_dir}/yt-dlp "$line" | tee >> "$logfile"
echo >> "$logfile" 

done < "$input"

################  DOWNLOAD LOOP END  #####################################################################################################################
############  REMOVE UNWANTED LOG INFO  ############# 

sed -i '/\[youtube\]/d' "$pasteclip".log &> /dev/null  # removing lines that start with  [youtube]
sed -i '/\[info\]/d' "$pasteclip".log &> /dev/null  # removing lines that start with  [info]
sed -i 's/\[download\]//' "$pasteclip".log &> /dev/null  # remove   [download]   from the end of the line.
sed -i 's/has already been downloaded//' "$pasteclip".log &> /dev/null  # remove   has already been downloaded   from the end of the line.
sed -i -e 's/^[ \t]*//' "$pasteclip".log &> /dev/null  # remove spaces at beginning of line.

#####################################################
echo
echo
echo -e "$der" "\033[5mdone processing download list . . .\033m\033[0m"
echo
echo "List:" "$pasteclip"  # display list filename with full path
echo "Log :" "$logfile"  # display log filename with full path
echo
echo "Press enter to exit this screen"

notify-send "Videoinfox messsage: Done Processing Download List . . ." "$pasteclip"

read -p ""
echo "" | xclip -sel clip  # clearing out the clipboard
else  # File didn't exist. clipboard cleared

echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
fi
cd "$dirclip"  # restore directory to before  Download List
;;
v)  # VIEW A DOWNLOAD LIST

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -f "$pasteclip" ]]; then

clear
cat "$pasteclip" 2>/dev/null
echo
read -p "Up/Down arrows or mouse to scroll.  Press enter to quit"

else  # File didn't exist. clipboard cleared

echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
fi
;;
l)  # VIEW LOGS

echo "" | xclip -sel clip  # clearing out the clipboard clipboard

function viewlogs {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
########## blinking routine for display ##########

# blinking
viewlog1=$(echo -e "\033[5mView Log\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking
viewlog0=$(echo "View Log")

# if file exists goto then
if [[ -f "$pasteclip" ]]; then
      finalresult="$viewlog1"  # if the file exists, blinking   View Log

  else
      finalresult="$viewlog0"  # if the file doesn't exist, non blinking   View Log
fi
########## end blinking routine #################
clear
# find default download list and write to file.
find ${base_dir}/videoinfox-dl-Default.log > ${base_dir}/videoinfox.dowload.list.default.log 2> /dev/null

# find user created list logs 
find "$PWD" -type f \( -iname "videoinfox-dl*.log" \)  # find log files  */.videoinfox-dl*log
echo

cat ${base_dir}/videoinfox.dowload.list.default.log 

echo
echo "Copy 1 above log to the clipboard to view"
echo
echo "Directory:" "$PWD"
echo "Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " "$der" >>> DOWNLOAD LIST >>> VIEW LOGS                               Enter - Update Clipboard Display"
echo "___________________________________________________________________________________________________________________" 
echo
echo " l - "$finalresult"                                                                                             q - Quit"
echo
echo -en " Enter Option: "
read -r -n1 optionvl
echo
}

while true; do
viewlogs
case $optionvl in
         
q)  # QUIT
echo "$pastecliptemp" | xclip -sel clip  # restoring clipboard clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
break;;
l)  # VIEW LOG
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard contentclear

if [[ -f "$pasteclip" ]]; then

clear
cat "$pasteclip" 2>/dev/null
read -p "Up/Down arrows or mouse to scroll.  Press enter to quit"
echo "" | xclip -sel clip  # clearing out the clipboard clipboard

else
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
fi

esac
done
;;
h) # DOWNLOAD LIST HELP
less ${base_dir}/videoinfox.download-list-help
;;

*)
;;

esac
done
;;
#######################################################################################################################################
########################   (PLAY ClIPBOARD) YT-DLP MENU   #############################################################################
#######################################################################################################################################

     p) 
     #  @PLAY CLIPBOARD - <VIEW DOWNLOADS>
          
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
     ################# grabdir="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            touch ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
                else
                    read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
get_file_stats "${ytdlplast}"

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
             :
         else     
             notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
             echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List File  
             ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdir"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${pasteclip}"
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard

      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

      echo " Played List Closed"
      
       else
            
           echo
           echo
           echo " No playable content in the clipboard . . ."
           sleep 1.2
       fi
fi

cd "$grabdir"
;;

  
#####################################################################################
     v)  # VIEW DOWNLOADS
##################################################################################### 

clipsave=$(xclip -o -selection clipboard 2> /dev/null)  # save clipboard content         

keepdir="$PWD"  # save dir for exit      
      function menuyt {  # LIST ALL VIDEO FILES RECURSIVELY IN THE DEFAULT DOWNLOAD DIRECTORY 
cd "$dirsaved"

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$grabclip" = "http" ]]; then
      :

  else      
      if [[ -f "$pasteclip" ]]; then
            :
        else
            echo "" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi

# below was the method i used for this functions before switching to find   
# echo " " > ${base_dir}/videoinfo.viewdownloads
# ls "$PWD/"*.mp4 >> ${base_dir}/videoinfo.viewdownloads
# ls "$PWD/"*.mkv >> ${base_dir}/videoinfo.viewdownloads
# ls "$PWD/"*.avi >> ${base_dir}/videoinfo.
# ls "$PWD/"*.webm >> ${base_dir}/videoinfo.viewdownloads
# ls "$PWD/"*.divx >> ${base_dir}/videoinfo.viewdownloads
# sed -i '/ls: cannot access/d' ${base_dir}/videoinfo.viewdownloads  # removing file type(s) not found errors (remove beinnging of line pattern)

# Find video files.
find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) > ${base_dir}/videoinfo.view-downloads

# CHECK FOR FILES FOR BLINKING DASH
istherefiles=$(find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) | wc -l)

# not blinking dash
vdash0=$(echo "-")
# blinking dash
vdash1=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")

if [[ "$istherefiles" = 0 ]]; then
      vdash="$vdash0"
  
  else
      vdash="$vdash1"

fi

#tac ${base_dir}/videoinfo.viewdownloads >  ${base_dir}/videoinfo.viewdownloads.tmp
#mv ${base_dir}/videoinfo.viewdownloads.tmp ${base_dir}/videoinfo.viewdownloads

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content                  
clear
#cat ${base_dir}/videoinfo.view-downloads

# SORT BACK INTO ORDER
sort -u ${base_dir}/videoinfo.view-downloads > ${base_dir}/videoinfo.view-downloads.tmp
mv ${base_dir}/videoinfo.view-downloads.tmp ${base_dir}/videoinfo.view-downloads 

#  REMOVE BLANK LINES
sed '/^$/d' ${base_dir}/videoinfo.view-downloads > ${tmp_dir}/videoinfo-view-downloads.tmp 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed 's/.*\///' ${tmp_dir}/videoinfo-view-downloads.tmp > ${tmp_dir}/videoinfo-number-view-downloads.tmp2 2>/dev/null

# CREATE NUMBERED lIST
sed '/./=' ${tmp_dir}/videoinfo-number-view-downloads.tmp2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo-number-view-downloads.tmp 2>/dev/null
rm ${tmp_dir}/videoinfo-number-view-downloads.tmp2 2>/dev/null

cat ${tmp_dir}/videoinfo-number-view-downloads.tmp  # display numbered find results 
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
##################################################################################################################################################
#=================================================================================================================================================
#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY
#=================================================================================================================================================
##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

if [[ "$grabpaste" = "http" ]]; then
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
      ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

            if [[ "$ytdlpconfirm" = "" ]]; then

                      echo "" | xclip -sel clip  # clearing out the clipboard
                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                           # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
                           #________________x________________________________________ _________________________________________________________
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> VIEW DOWNLOADS"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " o "$vdash" Autoplay Line     d "$vdash" Play Directory    p - Play Clipboard                                           q - Quit"
                      echo " j "$vdash" Play Line"
                      echo " i "$vdash" Info"     
                      echo            

                  else 
                      echo
                      echo "YT-DLP Confirmed: "$ytdlpconfirm""
                      echo
                      echo "Download Directory: $dirsaved"  # dislpay default download directory
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> VIEW DOWNLOADS"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo -e " o "$vdash" Autoplay Line     d "$vdash" Play Directory     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                                          q - Quit"
                      echo " j "$vdash" Play Line"
                      echo " i "$vdash" Info"     
                      echo                                                                                  
            fi
  else

      if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> VIEW DOWNLOADS"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo -e " o "$vdash" Autoplay Line     d "$vdash" Play Directory     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                                          q - Quit"
            echo " j "$vdash" Play Line"
            echo " i "$vdash" Info"
            echo                                                             

        else 

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> VIEW DOWNLOADS"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " o "$vdash" Autoplay Line     d "$vdash" Play Directory    p - Play Clipboard                                           q - Quit"
            echo " j "$vdash" Play Line"
            echo " i "$vdash" Info"     
            echo                                          
fi
fi

echo -en " Enter Option: "
read -r -n1 optionyt

}
        
              while true
              do
              menuyt
             case $optionyt in
              q)  # QUIT        
              cd "$keepdir"
              rm ${tmp_dir}/videoinfo-number-view-downloads.tmp 2> /dev/null
              rm ${tmp_dir}/videoinfo-view-downloads.tmp 2> /dev/null

              break;;

                            
              p)
 
          #  @PLAY CLIPBOARD - <VIEW DOWNLOADS>
          
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdir="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            touch ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
get_file_stats "${ytdlplast}"

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
             :
         else     
             notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
             echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List File  
             ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdir"   # restore dir prior to entering yt-dlp menu              

  else
      
      if [[ -f "$pasteclip" ]]; then

      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${pasteclip}"
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

      echo " Played List Closed"
 
        else
            
           echo
           echo
           echo " No playable content in the clipboard . . ."
           sleep 1.2
      fi 
fi

cd "$grabdir"
;;  
              i)  # INFO - <VIEW DOWNLOADS>
if [[ "$istherefiles" = 0 ]]; then
      echo
      echo
      echo " No video files in the current directory . . ."
      sleep 1

  else
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

get_file_stats "${pasteclip}"

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo-view-downloads.tmp ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo-view-downloads.tmp > ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp

                 if ! [[ -z "$playnumber" ]]; then
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
get_file_stats "${playnumber}"

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp 2>/dev/null

                 fi

            fi

      fi

  fi
;;
###### Check this area.  pulled possible misplaced code. test playclipboard
         ########################################################################################################################################
         d)  # (@PLAY DIRECTORY) VIEW DOWNLOADS  ################################################################################################
         ########################################################################################################################################

# WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
find_supported_files > ${tmp_dir}/videoinfox.navtree-play-directory-apa

#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
if ! file_contains '^/' "${tmp_dir}/videoinfox.navtree-play-directory-apa"; then
    {
        rm "${tmp_dir}/videoinfox.navtree-play-directory-apa"
        rm "${tmp_dir}/videoinfox.navtree-play-directory-apa2"
        rm "${tmp_dir}/videoinfox.numbered-navtree-play-directory-list"
        rm "${tmp_dir}/videoinfox.navtree-play-directory-apa-work"
    } 2>/dev/null
    return
fi

#  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfox.navtree-play-directory-apa"

#  PLAYED LIST INPUT FOR LOOP
input="$moddedplayedlist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
touch "${tmp_dir}/videoinfox.navtree-play-directory-apa2"

#  #  START WRITING
while read -r line; do
    if [[ -f "${line}" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
        printf -- '%s\n' "$line" >> "${tmp_dir}/videoinfox.navtree-play-directory-apa2"
    fi
done < "${moddedplayedlist}"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfox.navtree-play-directory-apa2 ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
touch ${tmp_dir}/videoinfox.navtree-play-directory-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfox.navtree-play-directory-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfox.navtree-play-directory-apa2 ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfox.navtree-play-directory-apa2

# NUMBER THE LIST
sed '/./='  ${tmp_dir}/videoinfox.navtree-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null


################clear

if [[ -f ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list ]]; then
        cat ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
   else
       echo
       echo
       echo " No video files in the current directory . . ."
       sleep 1.7
fi
linenumber=1

tail -n +"$linenumber" ${tmp_dir}/videoinfox.navtree-play-directory-apa > ${tmp_dir}/videoinfox.navtree-play-directory-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfox.navtree-play-directory-apa.tmp ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null); do
    clear
    echo
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$der"" >>> VIEW DOWNLOADS >>> PLAY DIRECTORY" 
    echo
    echo " [PLAY]>" "$line"
    echo "___________________________________________________________________________________________________________________"
    echo

    get_file_stats "${line}"
    
    echo
    echo
    echo " Video Player Controls:"
    echo                             
    echo " - Fullscreen Toggle: f"
    echo
    echo " - Play/Pause Toggle: space bar"
    echo
    echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
    echo
    echo " - Quit: q"      
    echo -e "\n"

    ffplay -fs -autoexit "$line" 2> /dev/null

    echo " To bypass the 3 second wait press enter with no entry"
    echo
    echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
    echo 
    read -t 3 -p " Press any key then press enter to quit : " playdir
           
    # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
    if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
            break                                                   # if enter is pressed without any input the next video will play
    fi
done
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null
rm ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null
rm ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
rm ${tmp_dir}/videoinfox.navtree-play-directory-apa-work 2>/dev/null 

;;           
              o)
##################################################################################################################################################
###########################   AUTOPLAY LINE  o   <VIEW DOWNLOADS>  ###############################################################################
##################################################################################################################################################
if [[ "$istherefiles" = 0 ]]; then
      echo
      echo
      echo " No video files in the current directory . . ."
      sleep 1

  else
if [[ -f ${tmp_dir}/videoinfo-view-downloads.tmp ]]; then

echo
echo
read -r -p " Autoplay Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo-view-downloads.tmp > ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp 2>/dev/null
input="$HOME""/.config/videoinfox/tmp/videoinfo-view-downloads-autoplay.tmp"

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> SEARCH RESULTS >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${line}"
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
 
rm ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp 2> /dev/null
IFS=$OLDIFS

else
    echo
    echo
    echo " Select Show All or use Find to acess this feature . . ."
    sleep 1.7
fi

fi

;;
              j)
##################################################################################################################################################
###########################   PLAY LINE  j   <VIEW DOWNLOADS>  ###################################################################################
##################################################################################################################################################

if [[ "$istherefiles" = 0 ]]; then
      echo
      echo
      echo " No video files in the current directory . . ."
      sleep 1

  else
if [[ -f ${tmp_dir}/videoinfo-view-downloads.tmp ]]; then
      echo
      echo
      read -r -p " Play Line: " linenumber  # waiting fot user input

      # create file moving selected line number to the top
      tail -n +"$linenumber" ${tmp_dir}/videoinfo-view-downloads.tmp > ${tmp_dir}/videoinfo-view-downloads-playnumber.tmp 2>/dev/null
      
      # read first line of file for play
      read playnumber < ${tmp_dir}/videoinfo-view-downloads-playnumber.tmp

      if ! [[ -z "$playnumber" ]]; then

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> SEARCH RESULTS >>> PLAY LINE" 
      echo
      echo " [PLAY]>" "$playnumber"
      echo "___________________________________________________________________________________________________________________"
      echo

      get_file_stats "${playnumber}"
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$playnumber" |  awk -F '/' '{print $NF}')  
  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"      

      echo "$playnumber" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$playnumber" 2>/dev/null  # play video
      rm ${tmp_dir}/videoinfo-view-downloads-playnumber.tmp 2>/dev/null

     fi

else
    echo
    echo
    echo " Select Show All or use Find to acess this feature . . ."
    sleep 1.7

fi

fi

;;
                *)

                esac
                done  
                
              ;;
              s)  # DOWNLOAD VIDEO PLAY, THEN DELETE ON VIDEO PLAYER CLOSE 
              
              grabdir="$PWD"

              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"   # change to download directory              

              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
              
              grabpaste3=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

              if [[ "$grabpaste3" = "http" ]]; then
         
              clear
              ${base_dir}/yt-dlp "$pasteclip" -o "$dirsaved"/download.tmp  # downloading temporary video
              notify-send "Videoinfox messsage: YT-DLP is done downloading . . ." "$pasteclip" 

              clear
              echo
              echo "___________________________________________________________________________________________________________________"
              echo
              echo " ""$der"" >>> YT-DLP MENU >>> Play Video >>> Self Destruct"
              echo
              echo " [PLAY]> ""$pasteclip"""
              echo "___________________________________________________________________________________________________________________"         
              echo
              echo
              echo " Video Player Controls:"
              echo                             
              echo " - Fullscreen Toggle: f"
              echo
              echo " - Play/Pause Toggle: space bar"
              echo
              echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
              echo
              echo " - Quit: q"      
              echo -e "\n"
              echo " This screen will exit when the video player is closed."
              echo
              
              ffplay -fs -autoexit &> /dev/null "$dirsaved"/download.tmp*  # play temporary video
              rm "$dirsaved"/download.tmp*  # on player close, delete temporary video
              echo "" | xclip -sel clip  # clearing out the clipboard
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
             
              else 
                    echo
                    echo
                    echo " Clipboard is empty or contained invalid video url . . ."
                    sleep 1
              fi

              cd "$grabdir" # restore dir
              ;; 
              l)  # play last download
               
              grabdir="$PWD"  # storing directory to restore at the end of this function
               
              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"   # change to download directory

                 if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
                        read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt         
                        ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))
                        echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file
                        read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file

                    else
                        read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download
                        ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownloadbak*" \))
                        echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file
                        read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                 fi   
              clear
              echo
              echo "___________________________________________________________________________________________________________________"
              echo
              echo " ""$der"" >>> PLAY LAST DOWNLOAD"
              echo
              echo " [PLAY]> ""$ytdlplast"""
              echo "___________________________________________________________________________________________________________________"         
              echo
              
get_file_stats "${ytdlplast}"

              echo
              echo " Video Player Controls:"
              echo                             
              echo " - Fullscreen Toggle: f"
              echo
              echo " - Play/Pause Toggle: space bar"
              echo
              echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
              echo
              echo " - Quit: q"      
              echo -e "\n"
              echo " This screen will exit when the video player is closed."
              echo
         
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
                       
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to file  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
              cd "$grabdir"   # restore dir prior to entering yt-dlp menu
              ;;  
              d)  # DOWNLOAD DEFAULT
              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"  # change to download directory
 
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content              
#!!!
              grabpaste3=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

              if [[ "$grabpaste3" = "http" ]]; then
                  
              clear
      
              ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
              ${base_dir}/yt-dlp "$pasteclip"     
      
              # remove first dot and everything after it in filename. file names with dots before the extension were breking find results
              sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

              # remove first [ and everything after it in filename. this was done because file names with [ 
              sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

              # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
              mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
      
              read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download video file
              
              notify-send "Videoinfox messsage: YT-DLP done downloading . . ." "$lastdownload"
              
              echo "" | xclip -sel clip  # clearing out the clipboard
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

              
                else 
                    echo
                    echo
                    echo " Clipboard is empty or contained invalid video url . . ."
                    sleep 1
              fi
              
              cd "$grabdir"
              ;;
              c)  # DOWNLOAD CHOOSE
              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"   # change to download directory

              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

              grabpaste3=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

              if [[ "$grabpaste3" = "http" ]]; then
              
              clear
              echo
              echo
              
              # <yt-dlp> gets the filename minus the extension. this is done becuase the user can pick different video file types to download.
              ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload
 
              # <yt-dlp> giving options for quality and file type to download
              ${base_dir}/yt-dlp -F "$pasteclip"
              
              echo
              echo
              echo "Find what video quality and format you want. (Code on far left)"
              read -r -p "Enter that Code and Press enter : " svrcode
              echo
              clear
              ${base_dir}/yt-dlp -f "$svrcode" "$pasteclip"

              # remove first dot and everything after it in filename. file names with dots before the extension were breking find results
              sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

              # remove first [ and everything after it in filename. this was done because file names with [ 
              sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

              # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
              mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
              
              read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download video file
              notify-send "Videoinfox messsage: YT-DLP done downloading . . ." "$lastdownload"              
              
              echo "" | xclip -sel clip  # clearing out the clipboard
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
              
              else 
                    echo
                    echo
                    echo " Clipboard is empty or contained invalid video url . . ."
                    sleep 1
              fi
              
              cd "$grabdir"
              ;; 

*)

 esac
 done

fi
################################################## cd "$grabdir"   # restore dir prior to entering yt-dlp menu
;; 

##################################################################################################################################################
m)  # MORE OPTIONS   #############################################################################################################################
##################################################################################################################################################

menu() {

##################################################################################
##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################## 

# DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

# DEFAULT DIR NUMBER 1 FORMAT
dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
# DEFAULT DIR NUMBER 2 FORMAT
dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
# DEFAULT DIR NUMBER 3 FORMAT
dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
# DEFAULT DIR NUMBER 4 FORMAT
dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
# DEFAULT DIR NUMBER 5 FORMAT
dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
# NO MATCH ALL LESS BOLD
dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
# FORMAT PWD NAME FOR COMPARISON
echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

# FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

# FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

# FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

# FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

# FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
# LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
# DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

if [[ "$controldir" = "$dir5display" ]]; then 
    [[ "$dir5display" = "$dir1display" ]] && dirdisp="$dirdisplay1"
    [[ "$dir5display" = "$dir2display" ]] && dirdisp="$dirdisplay2"
    [[ "$dir5display" = "$dir3display" ]] && dirdisp="$dirdisplay3"
    [[ "$dir5display" = "$dir4display" ]] && dirdisp="$dirdisplay4"
fi

# DEFAULT DIR 5 DISPLAY
if [[ "$controldir" = "$dir5display" ]]; then
    # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
    dirdisp="$dirdisplay5"
else
    # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
    dirdisp="$dirdisplayno"
fi 

# DEFAULT DIR 1  DISPLAY
[[ "$controldir" = "$dir1display" ]] && dirdisp="$dirdisplay1"
# DEFAULT DIR 2  DISPLAY
[[ "$controldir" = "$dir2display" ]] && dirdisp="$dirdisplay2"
# DEFAULT DIR 3  DISPLAY
[[ "$controldir" = "$dir3display" ]] && dirdisp="$dirdisplay3"
# DEFAULT DIR 4  DISPLAY
# if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
[[ "$controldir" = "$dir4display" ]] && dirdisp="$dirdisplay4"

################################################################################
##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"                                                                 #
echo "___________________________________________________________________________________________________________________"
echo
echo " $der >>> MORE OPTIONS                                                      "$dirdisp" - Default Dirs"
echo "___________________________________________________________________________________________________________________"
echo
echo " c - Change Directory     n - Video Count        v - Video Info                                           q - Quit"                     
echo " f - Find Directory       d - Video Duration"
echo " l - List Directory"
echo
echo -en " Enter Option: "
read -r -n1 option
}

  
while true; do
    menu
    case $option in
        q)
            # QUIT - <HOME> 
            break
        ;;
        1)
            # CD DIRECTORY TO TV    
            cd "$dir1" 
        ;;
        2)
            # CD DIRECTORY TO MOVIES
            cd "$dir2" 
        ;;
        3)
            # CHANGE DIRECTORY TO DOWNLOADS
            cd "$dirsaved" 
        ;;
        4)
            # CHANGE DIRECTORY TO EXTRA   
            cd "$dir4" 
        ;;
        5)
            # CHANGE DIRECTORY TO LAST EXIT
            cd "$dir5" 
        ;;
l)  # LIST DIRECTORY
##################################################################################################################################################
###########################   MORE OPTIONS l  LIST DIRECTORY  ####################################################################################
##################################################################################################################################################

#   The Line below gives a total count of all mp4, mkv, avi, & divx in Current Directory.
currentdirfilecount=$(find_supported_files --count)
    

if [[ -f "videoinfo.List-Directory" ]]; then
#     >>>>>>>>>>>>>>>>>>>>>>>>>> DISPLAY LAST DIRECTORY LISTING >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 

      less videoinfo.List-Directory  # display in <less>
  
  else

#     >>>>>>>>>>>>>>>>>>>>>>>>>> CREATE NEW DIRECTORY LISTING FILE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   

# The group of echo's below write a header to file <videoinfo.List-Directory> 
# touch videoinfo.List-Directory
echo "$ver                                                                                  LIST DIRECTORY" >> videoinfo.List-Directory
echo >> videoinfo.List-Directory
echo "This File was Created $(date) by" "$USER" >> videoinfo.List-Directory
echo >> videoinfo.List-Directory  # Every line ending in  ' >> videoinfo.List-Directory '  is writing that line to text file <videoinfo.List-Directory>)
echo "SAVED RESULTS LOADED FROM FILE: videoinfo.List-Directory" >> videoinfo.List-Directory
echo  >> videoinfo.List-Directory
echo "Working Directory: ""$PWD" >> videoinfo.List-Directory
echo  >> videoinfo.List-Directory 
echo "___________________________________________________________________________________________________________________" >> videoinfo.List-Directory
echo  >> videoinfo.List-Directory 
echo " Up & Down Arrows or Mouse wheel - scroll                                                            Home - top" >> videoinfo.List-Directory
echo " q - quit                                                                                            End - bottom" >> videoinfo.List-Directory
echo "___________________________________________________________________________________________________________________" >> videoinfo.List-Directory       
echo >> videoinfo.List-Directory
echo  >> videoinfo.List-Directory

# Display & Write <videoinfo.List-Directory>  The Results of:  - ffprobe for Codec & Resolution <$codecres>
#                                                              - ffmpeg for Duration in (hrs:min)
clear

for video_file in *.mp4 *.mkv *.avi *.webm *.divx; do 
    {
        printf -- '%s\n' "${video_file}"
        ffprobe "${ffprobe_opts[@]}" "${video_file}"
        # grep out duration, cut everything after "," then remove the ","
        # TODO: Test if "grep Duration | cut -d ' ' -f 4" can be replaced by "awk '/Duration/{print $4}'"
        ffmpeg -i "${video_file}" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//
        printf -- '%s\n' ""
    } | tee -a videoinfo.List-Directory
done

# echo >> videoinfo.List-Directory
echo "Total Video Files:" "$currentdirfilecount"
echo >> videoinfo.List-Directory
echo "Total Video Files:" "$currentdirfilecount" >> videoinfo.List-Directory
echo
echo
echo >> videoinfo.List-Directory
echo ">>> Listing is not recursive <<<"
echo ">>> Listing is not recursive <<<" >> videoinfo.List-Directory
echo
echo >> videoinfo.List-Directory
echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen   
echo "Working Directory: ""$PWD" >> videoinfo.List-Directory
echo
if [[ "$currentdirfilecount" != 0 ]]; then
      echo "$rer"
      echo
      echo -e "\033[5mProbing $currentdirfilecount \033[5mVideo Files for Duration\033[0m"  #  file count of find results
      echo
      echo "This can take a while if there are a lot of video files to process."
      echo "You will get a GUI Notification when this process is complete."
      echo
     
      #  This is where the file <${base_dir}/videoinfo.duration.tmp> is created to store duration in seconds with the format being  (x.xxxxxx)
      #  Video files are found in current directory and processed with ffprobe and written to <${base_dir}/videoinfo.duration.tmp>. 
find . -maxdepth 1 -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) -exec ffprobe -show_entries format=duration -v quiet -of csv="p=0" {} \; > ${base_dir}/videoinfo.duration.tmp 2>/dev/null

      #  ffprobe outputs video duration in seconds 6 places past the decimal point.
      #  bash can't do floating point math.  So  <bc>  is needed first to get sum of   <${base_dir}/videoinfo.duration.tmp>
      #  The  <paste -sd+ ${base_dir}/videoinfo.duration.tmp>  puts a +  between each line of the file and  <bc>  gives you the sum. 
      floatingseconds=$(paste -sd+ ${base_dir}/videoinfo.duration.tmp | bc)
         
      #  The total in seconds <$floatingseconds> is taken from line above and the format needs changed from  (x.xxxxxx) to (x)
      #  Below, <awk> is stripping 7 characters in from the right of the sum of  <$floatingseconds>
      #  In this case, the decimal point and the 6 trailing numbers are stripped from the string.
      totalseconds=$(echo "$floatingseconds" | awk '{ print substr( $0, 1, length($0)-7 ) }')
        
      #  Calculation of  <$totalseconds>  into different formats.
      secs=$(echo "$totalseconds")  # $totalseconds variable stored in $secs variable
      totalminutes=$(($(($totalseconds/60))))  # total minutes calculation

      echo >> videoinfo.List-Directory
      echo >> videoinfo.List-Directory
      echo "Seconds"
      echo "Seconds" >> videoinfo.List-Directory
      echo "$totalseconds"  # display total seconds
      echo "$totalseconds" >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory 
      echo "Minutes"
      echo "Minutes" >> videoinfo.List-Directory
      echo "$totalminutes"  # display total minutes
      echo "$totalminutes" >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory
      echo "Hrs:Mi:Sec"
      echo "Hrs:Mi:Sec" >> videoinfo.List-Directory
      printf '%d:%d:%d\n' $((secs/3600)) $((secs%3600/60)) $((secs%60))  # calculation to display hours, minutes and seconds
      printf '%d:%d:%d\n' $((secs/3600)) $((secs%3600/60)) $((secs%60)) >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory
      echo "Days     Hrs:Min:Sec"
      echo "Days     Hrs:Min:Sec" >> videoinfo.List-Directory
      printf '%d        %d:%d:%d\n' $(($secs/86400)) $(($secs%86400/3600)) $(($secs%3600/60)) $(($secs%60))  # same as above except Days are added
      printf '%d        %d:%d:%d\n' $(($secs/86400)) $(($secs%86400/3600)) $(($secs%3600/60)) $(($secs%60)) >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory
      echo -e "\033[5mNEW RESULTS LOADED \033[5m \033[0m(use Mouse Wheel to Scroll)"
      echo "EXISTING RESULTS LOADED FROM FILE videoinfo.List-Directory " $(stat -c %y "videoinfo.List-Directory") >> videoinfo.List-Directory
      echo >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory
      notify-send "Videoinfox is done processing: List Directory" "$PWD"  # GUI Notification is displayed when this function <option 1> has completed.
      # The file  <${base_dir}/videoinfo.duration.tmp>  was created for <ffprobe> to store video duration in seconds of all find results.
      # The math was already performed on this file and it is no longer needed.  So it is being removed.  
      rm ${base_dir}/videoinfo.duration.tmp
   fi
fi
# Everytime You Save.  The File <videoinfo.List-Directory> is saved to the directory that option 1 was run in.
menu1() {
    clear
    less videoinfo.List-Directory  # view results from file
    echo
    echo " Directory: ""$PWD"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$der"" >>> LIST DIRECTORY"                                                  
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " Save or Delete Directory Listing"
    echo
    echo " s - Save     d - Delete"  
    echo 
    echo -en " Enter Option: "
    read -r -n1 option1
    echo
}

        while true; do
            menu1
            case $option1 in
                s) 
                    echo
                    echo " Results SAVED . . ."
                    echo 
                    #read -p "Press enter to Continue"
                    sleep .75
                    break
                ;; 
                d) 
                    rm videoinfo.List-Directory
                    echo
                    echo " Results DELETED . . ."
                    echo 
                    #read -p "Press enter to Continue"    
                    sleep .75
                    break
                ;;
                *)
                ;;
            esac
        done
        ;;
c)
##################################################################################################################################################
###########################   MORE OPTIONS c  CHANGE DIRECTORY  ##################################################################################
##################################################################################################################################################
 
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo
echo " $ver >>> CHANGE DIRECTORY"
echo "___________________________________________________________________________________________________________________"
echo
echo " No quotations needed for paths with spaces. Case sensative."
echo 
read -r -p " Enter Directory: " specifydir  # waiting fot user input - the directory you want to chang to 
    
    if [[ -z "$specifydir" ]]; then
        echo
        echo " error: Nothing was entered"
        sleep .75
    else
        if [[ -d "$specifydir" ]]; then
            echo
            cd "$specifydir"   # change the directory
            echo " Working Driectory changed to: $PWD"  # <pwd>  print current working directory to the screen
            sleep 1.5
        else
            echo
            echo " error:  No such file or directory"
            sleep 1.5
        fi
    fi
echo
#read -p "     Press enter to Continue" 
;;


f)     
##################################################################################################################################################
###########################   MORE OPTIONS f  FIND DIRECTORY  ####################################################################################
##################################################################################################################################################

pasteclip=$(xclip -o -selection clipboard > /dev/null)  # grab clipboard content
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$ver"" >>> FIND DIRECTORY                                                               wildcard * ok"
echo "___________________________________________________________________________________________________________________" 
echo
read -r -p " Directory Name: " dirfind  # waiting fot user input - dierectory that you want to find
findmeadir=$(find . -type d -iname "$dirfind" 2>/dev/null | wc -l)   # number of files found
       
                                                                                       
    if [[ -z "$dirfind" ]]; then
        echo
        echo " error: Nothing was entered"  
        sleep .75  # EXIT THIS LOOP
    else
        if echo "$dirfind" | grep -q "/"; then
            echo
            echo " error: No slashes directory name only"
            sleep .75  # EXIT THIS LOOP  
        else
            echo
            find . -type d -iname "$dirfind" | sort -u 2>/dev/null  # directory(s) found   
            echo
            echo " Total Directories Found:" "$findmeadir"  # number of files found
                  
            if [[ "$findmeadir" = 0 ]]; then
                sleep .75
                :  # the colon can be used in place of a command to 'Do Nothing'  Exit this nested loop
            else                         
                pastetemp=$(xclip -o -selection clipboard 2>/dev/null)  # perserve clipboard content prioir to runnin this function
                notify-send "Videoinfox is done processing: Find Directory" "Total Directories Found: $findmeadir" # GUI Notification.
                echo       
                echo " Chang the directory: Copy 1 line (including the dot) to the Clipboard then press enter"
                echo                             
                echo " Stay in current directory: enter without copy."
                read -r -p " "
                pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
                cd "$pasteclip" 2>/dev/null 
                echo " Working Driectory: ""$PWD"""  # <pwd>  print current working directory to the screen 
                echo "$pastetemp" | xclip -sel clip 2>/dev/null  #  reload clipboard content prior to running this function
                pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
                sleep 1.5
            fi
        fi
    fi
echo

#read -p "Press enter to Continue"

;;
n)
##################################################################################################################################################
###########################   MORE OPTIONS  4  VIDEO COUNT  ######################################################################################
##################################################################################################################################################
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> VIDEO COUNT - Recursive"
echo "___________________________________________________________________________________________________________________" 
echo
echo " RECURSIVE COUNT OF VIDEO FILES"
echo
mp4count=$(find . -type f \( -iname "*.mp4" \) 2>/dev/null | wc -l)  # total number of <mp4> files found
echo " MP4   = " "$mp4count"
mkvcount=$(find . -type f \( -iname "*.mkv" \) 2>/dev/null | wc -l)  # total number of <mkv> files found
echo " MKV   = " "$mkvcount"
avicount=$(find . -type f \( -iname "*.avi" \) 2>/dev/null | wc -l)  # total number of <avi> files found
echo " AVI   = " "$avicount"
webmcount=$(find . -type f \( -iname "*.webm" \) 2>/dev/null | wc -l) # total number of <webm files found
echo " WEBM  = " "$webmcount"
divxcount=$(find . -type f \( -iname "*.divx" \) 2>/dev/null | wc -l) # total number of <divx> files found
echo " DIVX  = " "$divxcount"
echo "------------------"
totalcount=$(($mp4count + $mkvcount + $avicount + $webmcount + $divxcount))  # calcutation for Sum of All 4 file types
echo " TOTAL = " $totalcount  # display Sum
# GUI Notification is displayed when this function <option 6> has completed. 
notify-send  "Videoinfox is done processing Video File Count " "Total Video Files located in $PWD : $totalcount"
echo
read -r -p " Press enter to Continue" 
;;
    

d)
##################################################################################################################################################
###########################  MORE OPTIONS  d  VIDEO DURATION  ####################################################################################
##################################################################################################################################################

if [[ -f "videoinfo.Video-Duration" ]]; then
#     >>>>>>>>>>>>>>>>>>>>>>>>>> DISPLAY Saved RESULTS >>>>>>>>>>>>>>>>>>>>>>>>>> 
      cat videoinfo.Video-Duration
  else
#     >>>>>>>>>>>>>>>>>>>>>>>>>> CREATE NEW RESULTS >>>>>>>>>>>>>>>>>>>>>>>>>>
#   The Line below gives a total count of all mp4, mkv, avi, & divx Recursively.
alldirfilecount=$(find . -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -name "*.webm" -o -iname "*.divx" \) 2>/dev/null | wc -l)

#  The group of echo's below write a header to file <videoinfo.Video-Duration> 
touch videoinfo.Video-Duration
echo "$ver                                                                                              VIDEO DURATION" >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration
echo "This File was Created $(date) by" "$USER" >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration  # Every line ending in  ' >> videoinfo.Video-Duration '  is writing that line to text file <videoinfo.Video-Duration>

#  The rest of this function Writes the Results to the Screen and File <videoinfo.Video-Duration>
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"  
echo
echo " ""$der"" >>> VIDEO DURATION - Recursive"
echo "___________________________________________________________________________________________________________________" 
echo
echo "Working Directory: ""$PWD" >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration
echo "RECURSIVE DURATION OF VIDEO FILES"
echo "RECURSIVE DURATION OF $alldirfilecount VIDEO FILES" >> videoinfo.Video-Duration
echo
echo "This can take a while if there are a lot of video files to process."
echo "You will get a GUI Notification when this process is complete."
echo
echo -e "\033[5mProbing $alldirfilecount \033[5mVideo Files for Duration\033[0m"  #  file count of find results
echo -e "\n"
echo >> videoinfo.Video-Duration
#  This is where the file <${base_dir}/videoinfo.duration.tmp> is created to store duration in seconds with the format being  (x.xxxxxx)
#  Video files are found recursively and processed with ffprobe and written to <${base_dir}/videoinfo.duration.tmp>. 
find . -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) -exec ffprobe -show_entries format=duration -v quiet -of csv="p=0" {} \; > ${base_dir}/videoinfo.duration.tmp 2>/dev/null
#  ffprobe outputs video duration in seconds 6 places past the decimal point.
#  bash can't do floating point math.  So  <bc>  is needed first to get sum of  <${base_dir}/videoinfo.duration.tmp>
#  The  <paste -sd+ ${base_dir}/videoinfo.duration.tmp>  puts a +  between each line of the file and  <bc>  gives you the sum. 
floatingseconds=$(paste -sd+  ${base_dir}/videoinfo.duration.tmp | bc)
#  The total in seconds is taken from line above and the format needs changed from  (x.xxxxxx) to (x)
#  Below, <awk> is stripping 7 characters in from the right of the sum of  <$floatingseconds>
#  In this case, the decimal point and the 6 trailing numbers are stripped from the string.
totalseconds=$(echo "$floatingseconds" | awk '{ print substr( $0, 1, length($0)-7 ) }')

clear
echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
echo
echo "$der"
echo
echo "RECURSIVE DURATION OF VIDEO FILES"
echo
echo "DONE Probing ""$alldirfilecount"" Video Files for Duration"  #  file count of find results
echo
#  Calculation of  <$totalseconds>  into different formats.
secs=$(echo "$totalseconds")
totalminutes=$(($(($totalseconds/60))))  # convert seconds into minutes

echo "Seconds"
echo "Seconds" >> videoinfo.Video-Duration
echo "$totalseconds"  # display total seconds
echo "$totalseconds" >> videoinfo.Video-Duration  
echo
echo >> videoinfo.Video-Duration
echo "Minutes"
echo "Minutes" >> videoinfo.Video-Duration
echo $totalminutes  # display total minutes
echo $totalminutes >> videoinfo.Video-Duration  
echo
echo >> videoinfo.Video-Duration
echo "Hrs:Mi:Sec"
echo "Hrs:Mi:Sec" >> videoinfo.Video-Duration
printf '%d:%d:%d\n' $((secs/3600)) $((secs%3600/60)) $((secs%60))  # calculation to display hours, minutes and seconds
printf '%d:%d:%d\n' $((secs/3600)) $((secs%3600/60)) $((secs%60)) >> videoinfo.Video-Duration  
echo
echo >> videoinfo.Video-Duration
echo "Days     Hrs:Min:Sec" 
echo "Days     Hrs:Min:Sec" >> videoinfo.Video-Duration
printf '%d        %d:%d:%d\n' $(($secs/86400)) $(($secs%86400/3600)) $(($secs%3600/60)) $(($secs%60)) # same as above + Days
printf '%d        %d:%d:%d\n' $(($secs/86400)) $(($secs%86400/3600)) $(($secs%3600/60)) $(($secs%60)) >> videoinfo.Video-Duration  
echo
echo >> videoinfo.Video-Duration
echo
echo -e "\033[5mNEW RESULTS LOADED \033[5m \033[0m"
echo "SAVED RESULTS LOADED FROM FILE: videoinfo.Video-Duration" $(stat -c %y "videoinfo.Video-Duration") >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration
#echo
#echo "     q  to quit" >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration
notify-send  "Videoinfox is done processing: Video Duration" "$PWD"  # GUI Notification is displayed when this function has completed.
# The file  <${base_dir}/videoinfo.duration.tmp>  was created for <ffprobe> to store video duration in seconds of all find results.
# The math was already performed on this file and it is no longer needed.  So it is being removed.  
#rm ${base_dir}/videoinfo.duration.tmp
fi

menu5() {
    clear
    cat videoinfo.Video-Duration
    echo
    echo "___________________________________________________________________________________________________________________" 
    echo
    echo " ""$der"" >>> VIDEO DURATION - Recursive"
    echo "___________________________________________________________________________________________________________________" 
    echo
    echo " s - Save     d - Delete"  
    echo 
    echo -en " Enter Option: "
    read -r -n1 option5
    echo
}

while true; do
    menu5
    case $option5 in
        s) 
            echo
            echo " Results SAVED . . ."
            echo 
            #read -p "Press enter to Continue"
            .75
            break
        ;; 
        d) 
            rm videoinfo.Video-Duration
            echo
            echo " Results DELETED . . ."
            echo 
            #read -p "Press enter to Continue"    
            sleep .75
            break
        ;;
        *)
        ;;
    esac
done
;;
v)
##################################################################################################################################################
###########################   MORE OPTIONS v  ENTER VIDEO FILE  ##################################################################################
##################################################################################################################################################

clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$ver"" >>> ENTER VIDEO FILE - For Info"
echo "___________________________________________________________________________________________________________________"
echo
echo " Full path needed. No quotations needed for paths or files with spaces. Case Sensative."
echo
read -r -p " Video File: " specifyfile  # waiting fot user input - video file to display
echo

        if [[ -z "$specifyfile" ]]; then
            echo " error: Nothing was entered"
            sleep .7
        else  
            if [[ -f "$specifyfile" ]]; then
                echo "$specifyfile"  | xclip -sel clip  # copy valid file to the cilpboard for play
                pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                get_file_stats "${pasteclip}"
                echo
                echo " Filename copied to clipboard for play"
                echo
                read -r -p " Press enter to Continue" 
            else
                echo " error: No such file or directory"
                sleep .7
            fi
        fi

    echo
    ;;
    esac
    done
    ;;
esac    
done

##################################################################################################################################################
###########################  END MAIN LOOP  ######################################################################################################
##################################################################################################################################################
#  EXIT MESSAGE
clear
echo -e "\n"
echo
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$ver"" >>> EXIT"
echo "___________________________________________________________________________________________________________________" 
echo -e "\n"
# Error: target STRING not available is an xclip error
#   FYI :

#   The Line Below performs a Recursive Search and outputs ffprobe's Duration of every find in seconds format (x.xxxxxx).
#   find . -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname ".avi" -o -iname "*.webm -o -iname "*.divx"\) -exec ffprobe -show_entries format=duration -v quiet -of csv="p=0" {} \;

#   The Line Below performs a Recursive Search and outputs Video File Count.
#   find . -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm -o -iname "*.divx" \) | wc -l

#   The Line Below gets the Codec & Resolution from a video file.
#   NOTE : Do NOT include  <  >   around the filename. 
#   ffprobe "${ffprobe_opts[@]}" <filename>

#   The Line Below gets the Duration from video file and dsiplays in  <Days:Hours:Minutes:Seconds>
#   NOTE :  Save Double Quotes around the filename. 
#   ffmpeg -i "filename" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//
#

main() {
    # Run our initialisation tasks
    init
    # Parse our given args
    while getopts ":adhlu:v" opts; do
        case "${opts}" in
            (a)     write_default_list ;;
            (d)     play_directory ;;
            (h)     print_help ;;
            (l)     write_user_set_list ;;
            (u)     use_custom_list "${OPTARG}" ;;
            (v)     print_version ;;
            (\?)    printf -- '%s\n' "ERROR: Invalid option: ${OPTARG}." >&2; exit 1 ;;
            (:)     printf -- '%s\n' "Option '-${OPTARG}' requires an argument, e.g. '-${OPTARG} 5'." >&2; exit 1 ;;
        esac
    done
}

main "${@}"
