#!/bin/bash
#  file : videoinfox v3.9.00
#  github and reddit: powerhousepro69
#  GNU General Public License v2.0
#  reddit:  /videoinfox

# This is where Videoinfox's Version Number is set.
# Version Number: no blinking dot
ver="Videoinfox v3.9.00"
# Version Number: with blinking dot
der=$(echo -e "Videoinfox v3\033[5m.\033m\033[0m\033[5m\033[5m\033[0m9.00")

# YT-DLP is not on the dependeny list becuase Videoinfox will dowload it to:   ${base_dir}   All calls to yt-dlp are pointed to:   
# ${base_dir}/yt-dlp   There is an update option in:   <Set>  Settings to update yt-dlp   (just the copy in ${base_dir})
# I didn't want to overwrite anyones copy of:   /user/local/bin/yt-dlp     Also, I wanted to make sure all new Videoinfox script installs
# included the most recent version of Yt-dlp
dependencies='notify-send bc ffmpeg ffprobe ffplay xclip'
dependency_failmsg=''

base_dir="${HOME}/.config/videoinfox"
playlist_dir="${base_dir}/playlists"
tmp_dir="${base_dir}/tmp"
readonly base_dir playlist_dir tmp_dir

# Get the top level PID and setup a trap so that we can call die() within subshells
trap "exit 1" TERM
_self_pid="${$}"
export _self_pid

die() {
    if [ -t 0 ]; then
        printf '\e[31;1m====>%s\e[0m\n' "${0}:(${LINENO}): ${*}" >&2
    else
        printf -- '====>%s\n' "${0}:(${LINENO}): ${*}" >&2
    fi
    # Send a TERM signal to the top level PID, this is trapped and exit 1 is forced
    kill -s TERM "${_self_pid}"
}

init() {
    # Check for dependencies and output anything missing to stderr
    for dependency in ${dependencies}; do
        if ! command -v "${dependency}" >/dev/null 2>&1; then
            dependency_failmsg="${dependency_failmsg},${dependency}" 
        fi
    done

    if (( "${#dependency_failmsg}" > 0 )); then
        printf -- '\n%s\n%s\n' \
            "The following dependencies were not found in PATH:" \
            "${dependency_failmsg/,/}" >&2
        exit 1
    fi

    # Disallow usage in /
    [[ "${PWD}" = "/" ]] && die "Videoinfox must not be run within /"

    # TODO: Add error handling for mkdir failures via a die() function
    [[ -d "${base_dir}" ]] || mkdir -p "${base_dir}"
    [[ -d "${tmp_dir}" ]] || mkdir -p "${tmp_dir}"
    [[ -d "${playlist_dir}" ]] || mkdir -p "${playlist_dir}"
}

find_supported_files() {
    case "${1}" in
        (--count)
            find "${PWD}" -maxdepth 1 -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) |
                wc -l
        ;;
        (*)
            find "${PWD}" -maxdepth 1 -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) |
                sort -u
        ;;
    esac
}

write_supported_list() {
    while read -r line; do
        case "${line}" in
            (*.mp4|*.webm|*.mkv|*.avi|*.divx)
                printf -- '%s\n' "${line}" >> "${2?No output file defined}"
            ;;
        esac
    done < "${1:?No input file defined}"
}

# Remove empty lines from a given file
squash() {
    sed -i '/^$/d' "${1:?No file specified}"
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -v     DISPLAY VERSION NUMBER THEN EXIT  
#-------------------------------------------------------------------------------------------------------------------------------------------------
print_version() {
    printf -- '%s\n' "${ver}"
    exit 0
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -l     ADD CLIPBOARD CONTENT ON THE FLY TO:   USER SET LIST   THEN EXIT
#-------------------------------------------------------------------------------------------------------------------------------------------------

# Create a gui keyboard shortcut for:   videoinfox -l
# It isn't necessary to have the Videoinfox running while using this feature.
# Build your set user list on the fly without leaving the gui
# COPY THE URL TO THE BROWSER. THEN USE YOUR SHORTCUT TO WRITE URL TO THE USER SET LIST. Rinse and repeat to keep adding to the list.

# -l  Write clipboard content to the User Set List. For instructions on use: Yt-dlp >>> Download List >>> Help
write_user_set_list() {
    read -r grabuserlist < "${base_dir}/videoinfox.set-user-list"
    if [[ -f "$grabuserlist" ]]; then
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
        echo "$pasteclip" >> "$grabuserlist"  # write url to the user set list
        notify-send "Videoinfox Message: Added link to List ${grabuserlist}  . . ." "${pasteclip}" # GUI Notification.
    
        cat -n "$grabuserlist" | sort -uk2 | sort -n | cut -f2- > "${base_dir}/videoinfox.ulistfly.tmp"  # REMOVE DUPLICATES
        squash "${base_dir}/videoinfox.ulistfly.tmp"  # remove any blank lines in the list
        sed -i '/http/!d' "${base_dir}/videoinfox.ulistfly.tmp"  # remove all lines not starting with  http
    
        mv "${base_dir}/videoinfox.ulistfly.tmp" "${grabuserlist}"

        echo "" | xclip -sel clip  # clearing out the clipboard
        exit
    else
        notify-send "Videoinfox -l Error . . ." "No user list has been set for this feature.  Set User List in Videoinfox first."
        exit
    fi
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -a     ADD CLIPBOARD CONTENT  ON THE FLY TO:   DEFAULT LIST   THEN EXIT
#-------------------------------------------------------------------------------------------------------------------------------------------------

# Create a gui keyboard shortcut for:   videoinfox -a
# It isn't necessary to have the Videoinfox running while using this feature.
# Build your default list on the fly without leaving the gui
# COPY THE URL TO THE BROWSER. THEN USE YOUR SHORTCUT TO WRITE URL TO THE DEFAULT DOWNLOAD LIST. Rinse and repeat to keep adding to the Default List. 

# -a  Write clipboard content to the Default List. For instructions on use: Yt-dlp >>> Download List >>> Help
write_default_list() {
    # This file should always exist:   ${base_dir}/videoinfox-dl-Default   if it doesn't, it will be created
    if [[ ! -f "${base_dir}/videoinfox-dl-Default" ]]; then
        # CREATING EMPTY DEFAULT DOWNLOAD LIST WITH LIST EMPTY MESSAGE
        touch "${base_dir}/videoinfox-dl-Default"
        echo "Default Download List Empty" >> "${base_dir}/videoinfox-dl-Default"
    fi
    # ADD TO DEFAULT LIST  <DEFAULT LIST>
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    echo "$pasteclip" >> "${base_dir}/videoinfox-dl-Default"  # write url to the default download list
    notify-send "Videoinfox added link to the Default Download List . . ." "${pasteclip}" # GUI Notification.

    # REMOVE DUPLICATES
    cat -n "${base_dir}/videoinfox-dl-Default" | sort -uk2 | sort -n | cut -f2- > "${base_dir}/videoinfox-dl-Default.tmp"
    mv "${base_dir}/videoinfox-dl-Default.tmp" "${base_dir}/videoinfox-dl-Default"

    squash "${base_dir}/videoinfox-dl-Default" 2>/dev/null  # remove any blank lines in the list
    sed -i '/http/!d' "${base_dir}/videoinfox-dl-Default"  # remove all lines not starting with  http

    echo "" | xclip -sel clip  # clearing out the clipboard

    exit
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -h     DISPLAY HELP THEN EXIT  
#-------------------------------------------------------------------------------------------------------------------------------------------------
print_help() {
cat << EOF
___________________________________________________________________________________________________________________
       echo  
 "${ver}" >>> COMMAND LINE OPTIONS >>> HELP              Where Video Play is a Clipboard Copy Away . . .
___________________________________________________________________________________________________________________ 

 Note: Videoinfox won't accept multiple options. Only one option per instance.

   -h  This help screen.

   -v  Display the version number.

   -a  Write clipboard content to the Default List. For instructions on use: Yt-dlp >>> Download List >>> Help

   -l  Write clipboard content to the User Set List. For instructions on use: Yt-dlp >>> Download List >>> Help

   -u  This option can be used with your own ready to download url list that can be any name and location.
       There is no need to use the Videoinfox interface with this option. Videos will be downloaded to the
       directory of the list location.  Example: videoinfox -u mylist  Only enter the list filename.
       The list must be recursively reachable from the current directory.
       The first line in the list must begin with http to be processed.

   -d  Autoplay video files in the current directory.

EOF
exit 0
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -u     DOWNLOAD ANY LIST THAT IS RECURSIVELY REACHABLE FROM THE CURRENT DIRECORY. ENTER FULL FILENAME ONLY. NO WILDCARD
#-------------------------------------------------------------------------------------------------------------------------------------------------

# -u  This option can be used with your own ready to download url list that can be any name and location
use_custom_list() {
    clear
    echo
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$ver"" >>> Load a recursively reachable Download List for processing . . ."
    echo "___________________________________________________________________________________________________________________"    
    if echo "$2" | grep "/" > /dev/null; then
        echo
        echo " error: No directories. Only a filename. List must be recursively reachable from the current directory."
        echo
        exit
    fi
    if echo "$2" | grep "*" > /dev/null; then
        echo
        echo " error: No wildcards. Only a filename. List must be recursively reachable from the current directory."
        echo 
        exit
    fi
    filecount=$(find "$PWD" -type f \( -iname "$2" \) | wc -l)
       
    if [[ "$filecount" = 1 ]]; then
        chkforhttp=$(find "$PWD" -type f \( -iname "$2" \))  # getting list name to check the first line for http
        read chkforhttp2 < "$chkforhttp"  # reading first line into varible $chkforhhtp2
        chkforhttp=$(echo "$chkforhttp2" | cut -c-4)   # cut everything after the 4th character

        if [[ ! "$chkforhttp" = "http" ]]; then
            echo
            echo -e "\033[5m error\033m\033[0m:   The first 4 characters on the first line don't start with http"
            echo "          This is a safety feature to prevent accidental deletion of a file that is not a Download List."
            echo
            echo "          If this file was processed, The following lines would have been removed:"
            echo
            echo "          - All lines that don't begin with: http"
            echo "          - All duplicate lines"
            echo "          - All blank lines"
            echo
            echo "          ** The first line of all Download Lists must begin with http to be processed with: videoinfox -u"
            echo 
            exit
        fi
        ##### GRAB THE PATH FROM THE DOWNLOAD LIST TO CHANGE THE WORKING DIRECTORY TO THAT PATH #####

        find "$PWD" -type f \( -iname "$2" \) > videoinfox-u-option-grabdir.tmp #2> /dev/null # find the list to grab the full path with filename
        sed -i 's%/[^/]*$%%' videoinfox-u-option-grabdir.tmp  # remove last slash and filename from the path for the cd command
        read -r < videoinfox-u-option-grabdir.tmp whatsthepath  # read the path into the varible: $whatsthepath 
        rm videoinfox-u-option-grabdir.tmp  # download list location is no longer needed. so it will be removed
        cd "$whatsthepath"  # cd to the download list location.


        #####  ERROR CORRECTION FOR THE USER'S LIST BEFORE DOWNLOAD.  #####

        cat -n "$2" | sort -uk2 | sort -n | cut -f2- > videoinfox-u-option.tmp  # remove duplicates from the user's list
        squash videoinfox-u-option.tmp  # remove all blank lines from the user's list
        sed -i '/http/!d' videoinfox-u-option.tmp  # remove all lines not starting with: http from the user's list
        mv videoinfox-u-option.tmp "$2"  
        #####  TAGGING .log ONTO THE USER'S LIST FILENAME TO CREATE A LOG FILE OF THE DOWNLOAD  #####
    
        ulogfile="$2".log  # tag  .log  onto the filename for log creation
        echo "$ver" ">>> videoinfox -u" "$2" ">>> Logfile" > "$ulogfile"  # create the log file header Line 1
        echo >> "$ulogfile"
        echo "Download list:" "$PWD/""$2" >> "$ulogfile"  # create the log file header Line 2
        echo >> "$ulogfile"  # create the log file header Line 3 (blank line)
        echo >> "$ulogfile"  # create the log file header Line 4 (blank line)

        echo
        echo "Processing list:" "$PWD/""$2"
        
            
        #####  DOWNLOAD LIST  #####
        
        input="$2"  # INPUT FOR THE DOWNLOAD LOOP (the download list)
        #####  DOWNLOAD LOOP START  #####

        while read -r line; do

            echo
            ${base_dir}/yt-dlp "$line"  # download url
            echo
            echo "Logging URL and Filename to:" "$PWD/""$ulogfile" 

            # logging yt-dlp output to the log file

            echo "$line" >> "$ulogfile" 
            ${base_dir}/yt-dlp "$line" | tee >> "$PWD/""$ulogfile"
            echo >> "$ulogfile" 

        done < "$input"

        #####  DOWNLOAD LOOP END  #####
        #####  REMOVE UNWANTED LOG INFO  ##### 

        sed -i '/\[youtube\]/d' "$2".log &> /dev/null  # removing lines that start with  [youtube]
        sed -i '/\[info\]/d' "$2".log &> /dev/null  # removing lines that start with  [info]
        sed -i 's/\[download\]//' "$2".log &> /dev/null  # remove   [download]   from the end of the line.
        sed -i 's/has already been downloaded//' "$2".log &> /dev/null  # remove   has already been downloaded   from the end of the line.
        sed -i -e 's/^[ \t]*//' "$2".log &> /dev/null  # remove spaces at beginning of line.
        #####  DISPLAY AFTER THE LIST IS DONE DOWNLOADING  #####

        echo
        echo
        echo -e "$ver" "\033[5mdone processing download list . . .\033m\033[0m"                 
        echo
        echo "List:" "$PWD/""$2"  # display list filename with full path
        echo "Log :" "$PWD/""$ulogfile"  # display log filename with full path
        echo
        
        notify-send "Videoinfox -u messsage: Done Processing Download List . . ." "$PWD/""$2"
        exit  # exit videoinfox

    else
        echo
        echo " Videoinfox Error: List not found. List must be recursively reachable from the current directory."
        echo
        exit
    fi    
}

#-------------------------------------------------------------------------------------------------------------------------------------------------
#  videoinfox -d     PLAY DIRECTORY.  AUTOPLAY VIDEO FILES IN THE CURRENT DIRECTORY
#-------------------------------------------------------------------------------------------------------------------------------------------------

# -d  Autoplay video files in the current directory
play_directory() {
    # WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
    find_supported_files > "${tmp_dir}/videoinfox.optiond-play-directory-apa"

    #  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
    atleastone=$(grep -c '^/' "${tmp_dir}/videoinfox.optiond-play-directory-apa" 2>/dev/null)

    #  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYED LIST
    if (( atleastone > 0 )); then
        #  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
        moddedplayedlist="${HOME}/.config/videoinfox/tmp/videoinfox.optiond-play-directory-apa"

        #  PLAYED LIST INPUT FOR LOOP
        input="$moddedplayedlist"  

        #  CREATE TEMP FILE NEEDED FOR LOOP 
        touch "${tmp_dir}/videoinfox.optiond-play-directory-apa2"

        #  #  START WRITING
        while read -r line; do
            if [[ ! -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
                printf -- '%s\n' "$line" >> "${tmp_dir}/videoinfox.optiond-play-directory-apa2"
            fi
        done < "${input}"
        #  DONE WRITING ONLY VALID FILES

        #  REMOVE BLANK LINES
        squash "${tmp_dir}/videoinfox.optiond-play-directory-apa2" 2>/dev/null

        #  MOVE apa2 BACK TO apa
        mv "${tmp_dir}/videoinfox.optiond-play-directory-apa2" "${tmp_dir}/videoinfox.optiond-play-directory-apa" 2>/dev/null

        #  CREATE FILE NEEDED FOR LOOP 
        touch "${tmp_dir}/videoinfox.optiond-play-directory-apa2"

        #  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
        while read -r line; do
            case "${line}" in
                (*.mp4|*.webm|*.mkv|*.avi|*.divx)
                    printf -- '%s\n' "${line}" >> "${tmp_dir}/videoinfox.optiond-play-directory-apa2"
                ;;
            esac
        done < "${input}"
        #  END WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx

        #  REMOVE BLANK LINES
        squash "${tmp_dir}/videoinfox.optiond-play-directory-apa2" 2>/dev/null

        #  MOVE apa2 BACK TO apa
        cp "${tmp_dir}/videoinfox.optiond-play-directory-apa2" "${tmp_dir}/videoinfox.optiond-play-directory-apa" 2>/dev/null

        # REMOVE PATH ONLY LEAVING FILENAME
        sed -i 's/.*\///' "${tmp_dir}/videoinfox.optiond-play-directory-apa2"

        # NUMBER THE LIST
        sed '/./=' "${tmp_dir}/videoinfox.optiond-play-directory-apa2" |
            sed '/./N; s/\n/ /' > "${tmp_dir}/videoinfox.numbered-optiond-play-directory-list" 2>/dev/null

    
    else #  NO LINES START WITH A SLASH /   remove empty files
        rm "${tmp_dir}/videoinfox.optiond-play-directory-apa" 2>/dev/null
        rm "${tmp_dir}/videoinfox.optiond-play-directory-apa2" 2>/dev/null
        rm "${tmp_dir}/videoinfox.numbered-optiond-play-directory-list" 2>/dev/null
    fi
    clear

    if [[ -f "${tmp_dir}/videoinfox.numbered-optiond-play-directory-list" ]]; then
        cat "${tmp_dir}/videoinfox.numbered-optiond-play-directory-list" 2>/dev/null
    else
        echo
        echo
        echo "$der  No playable content in the current directory . . ."
        echo
    fi
    linenumber=1

    tail -n +"$linenumber" "${tmp_dir}/videoinfox.optiond-play-directory-apa" > "${tmp_dir}/videoinfox.optiond-play-directory-apa.tmp" 2>/dev/null
    mv "${tmp_dir}/videoinfox.optiond-play-directory-apa.tmp" "${tmp_dir}/videoinfox.optiond-play-directory-apa" 2>/dev/null

    OLDIFS=$IFS
    IFS=$'\n'

    for line in $(cat "$input" 2>/dev/null); do
        clear
        echo
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " ""$der"" >>> Command Line Option -d >>> PLAY DIRECTORY" 
        echo
        echo " [PLAY]>" "$line"
        echo "___________________________________________________________________________________________________________________"
        echo

        echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
        
        echo
        echo
        echo " Video Player Controls:"
        echo                             
        echo " - Fullscreen Toggle: f"
        echo
        echo " - Play/Pause Toggle: space bar"
        echo
        echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
        echo
        echo " - Quit: q"      
        echo -e "\n"

        ffplay -fs -autoexit "$line" 2> /dev/null

        echo " To bypass the 3 second wait press enter with no entry"
        echo
        echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
        echo 
        read -t 3 -p " Press any key then press enter to quit : " playdir
            
        # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
        if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
            clear
            break                                                   # if enter is pressed without any input the next video will play
        else                                                        
            clear                                                   # press any key then enter within 3 seconds to quit Play Played List
        fi
    done
    
    IFS=$OLDIFS

    rm ${tmp_dir}/videoinfox.optiond-play-directory-apa 2>/dev/null
    rm ${tmp_dir}/videoinfox.optiond-play-directory-apa2 2>/dev/null
    rm ${tmp_dir}/videoinfox.numbered-optiond-play-directory-list 2>/dev/null

    exit
}

##################################################################################################################################################
#  END COMMAND LINE OPTIONS  #####################################################################################################################
##################################################################################################################################################

##################################################################################################################################################
##################################################################################################################################################

#  THE BELOW 7 FUNCTIONS RUN ONCE ON EVERY STARTUP THEN INTO THE MAIN LOOP.

#  3. Configuration directory check and file creation. If  ${base_dir}  doesn't exist, directory will be crated along with config files.
#  4. Check for Videoinfox Update and Notify if update is available.
#  5. Create empty Default Download List if one doesn't already exist.
#  6. Created Download List Help file.
#  7. Create Main Help file.
#  8. Create Version History file.

##################################################################################################################################################
#####  3. DIRECTORY CHECK & FILE CREATION  ####################################################################################################### 
##################################################################################################################################################

# The below check: Does the directory <${base_dir}> exist ?
# If it doesn't exist, directory is created. Empty files are created to avoid error when running Videoinfo for the first time.

direxist="$HOME/.config/videoinfox"

if [[ ! -d "$direxist" ]]; then
      
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo  
      echo " $ver >>> FIRST RUN >>> SETUP"
      echo
      echo " Directory and file creation"
      echo "___________________________________________________________________________________________________________________"
      echo "___________________________________________________________________________________________________________________"
      echo         
      echo " Created config directory: "$HOME"/.config/videoinfox and required files "
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " NOTE: Do not randomly paste in Videoinfox.  It will cause unwanted code to run producing"  
      echo " undesired results and can corrupt Videoinfox's data integrity and retention."
      echo
      echo " Everywhere the dot is blinking in the version number, don't paste and Videoinfox will function as intended."
      echo
      echo " ""$der"
      echo "__________________________________________________________________________________________________________________"
      echo
      echo " Yt-dlp will be downloaded to: "$HOME"/.config/videoinfox  "
      echo "__________________________________________________________________________________________________________________"
      echo
      echo -e " A sample video url was copied to the clipboard to show how the \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m feature works."
      echo
      echo " Video playing:  [ f - toggle fullscreen ]   [ spacebar - play/pause ]   [ l/r arrows - fwd/rew ]   [ q -quit ]"
      echo
      echo " Press  p  when Videoinfox starts up. That will download the video url that is in the clipboard and auto play it."
      echo "__________________________________________________________________________________________________________________"
      echo -e "\n" 
      echo " Setup for the first run or if the videoinfox directory gets deleted anytime after the first run."
      
                                        
 
      #####################
      # CREATE DIRECTORIES
      ####################
      # SET DEFAULT  LAST SEARCH  to <2> Never Save
      echo "2" > ${base_dir}/videoinfo.lastsearch-set

      # CHECK FOR  ~/Downloads  If it doesn't exist, create it 
      direxist2="$HOME/Downloads"

      if [[ ! -d "$direxist2" ]]; then
             mkdir ~/Downloads
      fi
      # SET DEFAULT  yt-dlp  DOWNLOAD DIRECTORY TO  ~/Downloads    It can be changed in the <set> menu
      echo "$HOME"/Downloads > ${base_dir}/videoinfo.yt-download-dir

      # SET DIR AT EXIT TO THE DEFAULT DOWNLOAD DIRECTORY SO DEFAULT DIR DISPLAY #3 LIGHTS UP ON FIRST RUN 
      echo "$HOME"/Downloads > ${base_dir}/videoinfo.dir-at-exit
      read -r diratexit < ${base_dir}/videoinfo.dir-at-exit
      cd "$diratexit" 2>/dev/null 

      # Writing header for new blank Saved Search  playlist  ++++++++ this was added to get around a bug until the bug gets squashed.       
      echo > ${base_dir}/videoinfo.keptsearch
      echo "PLAYlIST" >> ${base_dir}/videoinfo.keptsearch
      echo >> ${base_dir}/videoinfo.keptsearch
      echo "This File was Created: $(date) by" "$USER" >> ${base_dir}/videoinfo.keptsearch
      echo >> ${base_dir}/videoinfo.keptsearch

      
      ###############
      # CREATE FILES
      ###############

      # CREATING EMPTY FILES SO NO ERRORS ARE PRODUCED ON FIRST RUN
      echo > ${base_dir}/videoinfo.findwork
      echo > ${base_dir}/videoinfo.findwork2
      echo > ${base_dir}/videoinfo.findwork3
      echo > ${base_dir}/videoinfo.lastfindtime    
      echo > ${base_dir}/videoinfo.lastsearchtotal
      echo > ${base_dir}/videoinfo.lastsearchtotal2
      echo > ${base_dir}/videoinfo.playedlist
      echo > ${base_dir}/videoinfo.keptsearch
      echo > ${base_dir}/videoinfo.tv-dir
      echo > ${base_dir}/videoinfo.movies-dir
      echo > ${base_dir}/videoinfo.parent-dir
      echo > ${base_dir}/videoinfo.lastdownload
      echo > ${base_dir}/videoinfo.lastfindstring
      echo > ${base_dir}/videoinfo.lastfinddir
      echo > ${base_dir}/videoinfo.lastsearchtotal
      echo > ${base_dir}/videoinfox.set-user-list
          
   
      # SAMPLE URL DOWLOAD LIST BEING CREATED WITH 3 VIDEO URL'S
      echo "https://www.youtube.com/watch?v=d59H0UxhyaY" > $HOME/Downloads/videoinfox-dl-sample-list
      echo "https://www.youtube.com/watch?v=5tSAKS8LRj0" >> $HOME/Downloads/videoinfox-dl-sample-list
      echo "https://www.youtube.com/watch?v=DAPkOxRnh4c" >> $HOME/Downloads/videoinfox-dl-sample-list

      echo

           sec=36
           while [ $sec -ge 0 ]; do  #  This pauses the execution.  It displays and counts down the seconds set in <$sec>
                echo -ne " Downloading Yt-dlp in: $sec\033[0K\r"
                let "sec=sec-1"
                sleep 1
           done

 
# Yt-dlp initial download attempt on the first run. If it fails, download will be re-attempted when you select the Yt-dlp Menu.
clear
echo
echo 
echo 
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> Attempting to download the most recent version of Yt-dlp"
echo "___________________________________________________________________________________________________________________" 
echo
echo " If Yt-dlp can't be downloaded, the download attempt will be aborted."
echo
echo " If the download fails, it is most likely due to at least 1 of the following reasons:"
echo
echo "    - Your internet connection is down."
echo
echo "    - Github isn't reachable due to technical issues on their end."
echo
echo "    - There is no Yt-dlp release available in:  https://github.com/yt-dlp/yt-dlp/releases/latest/download"
echo
echo
echo " If this download fails, the download attempt will be tried again when you select the Yt-dlp Menu in Videoinfox."
echo
echo
echo " Note: The Yt-dlp Menu will not work until there is a copy of yt-dlp in:"
echo
echo " "$HOME"/.config/videoinfox"
echo
echo

dirtemp="$PWD"  # save dir for restore after ty-dlp download
cd ${base_dir}
  
wget https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp 2>/dev/null  # download and rename 
 
if [[ -f ${base_dir}/yt-dlp ]]; then
        chmod a+rx ${base_dir}/yt-dlp  # set <yt-dlp-fetched> execute bit
        ${base_dir}/yt-dlp --version > ${base_dir}/videoinfo.yt-dlp.version # write yt-dlp ver number to file: yt-dlp.version 
        echo
        echo " Yt-dlp Downloaded . . ."
        echo
        # SAMPLE VIDEO URL BEING COPIED TO CLIPBOARD
        echo "https://www.youtube.com/watch?v=rNWPqfCJDnc" | xclip -sel clip 

        sec=5           
        while [ $sec -ge 0 ]; do  #  This pauses the execution.  It displays and counts down the seconds set in <$sec>                       
             echo -ne " $ver starting in: $sec\033[0K\r"
             let "sec=sec-1"
             sleep 1
        done
        
        rm ${base_dir}/wget-* 2> /dev/null          
   else
       
        echo
        echo " Yt-dlp Download Failure . . ."
        echo

        sec=15           
        while [ $sec -ge 0 ]; do  #  This pauses the execution.  It displays and counts down the seconds set in <$sec>                       
             echo -ne " $ver starting in: $sec\033[0K\r"
             let "sec=sec-1"
             sleep 1
        done 

        rm ${base_dir}/wget-* 2> /dev/null    

cd "$dirtemp"  # restore directory

fi

fi


#squash ${base_dir}/videoinfo.playlist  # remove all blank lines

##################################################################################################################################################
#####  4. CHECK FOR  (VIDEOINFOX NOTIFICATION UPDATE)                         routine to get version number from github          #################
########################################################################      and compare it to this scripts version number      #################

clear  # Display while downloading videoinfox from github on startup
echo
echo
echo
echo "___________________________________________________________________________________________________________________"
echo  
echo " $ver >>> Checking for update . . ."
echo "___________________________________________________________________________________________________________________"
echo

dirtemp="$PWD"  # save directory for restore
cd ${tmp_dir}

# download  videoinfox  from github
wget -q https://raw.githubusercontent.com/powerhousepro69/videoinfox/main/videoinfox 2>/dev/null

# make script executable to get ver number
chmod +x ${tmp_dir}/videoinfox 2> /dev/null

# get ver number of download
viv=$(${tmp_dir}/videoinfox -v 2> /dev/null)  

# download ver: cut the first 13 characters + sed to remove the dot =  version number minus the dot 
viv2=$(echo "$viv" | cut -c13- | sed -e 's/\.//g' 2> /dev/null) # format: whole number  xxxx

# script ver:   cut the first 13 characters + sed to remove the dot =  version number minus the dot 
viv3=$(echo "$ver" | cut -c13- | sed -e 's/\.//g') # format: whole number  xxxx
# Prevent Update Available notifications from displaying if download fails. 
# If download fails, download version = script version

if [[ ! -f ${tmp_dir}/videoinfox ]]; then  # Downloaded
    viv3="$viv2"
fi
# for the notification just on the home screen

if [[ "$viv2" = "$viv3" ]]; then
    # Version numbers are the same
    viv4=$(echo -e \ "               ") # dead space place holder for when there is no Update Available in the display
    rm ${tmp_dir}/* 2> /dev/null
    cd "$dirtemp"  # restore directory
else
    # Version numbers are not the same
    viv4="Update Available"   # Update Available   notification on home screen
    notify-send "Videoinfox messsage: Update Available" "$viv" # send gui notification with update ver number
    rm ${tmp_dir}/* 2> /dev/null
    cd "$dirtemp"  # restore directory
fi
##################################################################################################################################################
#####  5. IF THE DEFAULT LIST DOESN'T EXIST, CREATE IT  ##########################################################################################
##################################################################################################################################################

if [[ ! -f ${base_dir}/videoinfox-dl-Default ]]; then
    # CREATING EMPTY DEFAULT DOWNLOAD LIST WITH LIST EMPTY MESSAGE
    touch "${base_dir}/videoinfox-dl-Default"
    echo "Default Download List Empty" >> ${base_dir}/videoinfox-dl-Default
fi
##################################################################################################################################################
#####  6. CREATE DOWNLOAD LIST HELP FILE  ######################################################################################################## 
##################################################################################################################################################

cat << EOF > "${base_dir}/videoinfox.download-list-help"
___________________________________________________________________________________________________________________
 
 "$ver" >>> DOWNLOAD LIST >>> HELP                                                            q - Quit
___________________________________________________________________________________________________________________

 There is a Default List and User Created Lists.  If a list is deleted, it's log file will also be deleted.
___________________________________________________________________________________________________________________


 DEFAULT LIST:  - There is just one Default List.
                - The list resides in Videoinfox's .config directory and is maintained by the script.
                - Script Directory location is irrelevant.  The Default List will follow the user.
                - Video URL's' are always downloaded to the default Download Directory.


                  Default List Companion: videoinfox -a

                  TO SETUP:  Make a gui shortcut for  videoinfox -a  (no space after the a)


                  The shortcut varies per terminal. I use Mate Terminal and this is my shortcut command:

                  mate-terminal --command=\"videoinfox -a\"


                  TO USE:  Copy a Video URL to the clipboard then use the  videoinfox -a  shortcut.
                           That will add the URL to the Default List.  Rinse and repeat until done.


                  Keep pasting your clipboard copies on the fly to the Default List without running Videoinfox.
                  When done making the list, start Videoinfox. Load the list and Download.

                  Note: Clipboard will be cleared everytime you run the shortcut.
                        Videoinfox doesn't need to be running to use the shortcut.

___________________________________________________________________________________________________________________


 USER LISTS:    - Unlimited User Lists.
                - Lists can be put anywhere and named.
                - Script Directory location is relavant to having access to the User Lists in Videoinfox.
                - Video URL's are always downloaded to the directory of the list's location.


                  User Set List Companion: videoinfox -l

                  TO SETUP:  Make a gui shortcut for  videoinfox -l  (no space after the l)


                  The shortcut varies per terminal. I use Mate Terminal and this is my shortcut command:

                  mate-terminal --command=\"videoinfox -l\"


                  TO USE:  Copy a Video URL to the clipboard then use the  videoinfox -l  shortcut.
                           That will add the URL to the User Set List.  Rinse and repeat until done.


                  Keep pasting your clipboard copies on the fly to the User Set List without running Videoinfox.
                  When done making the list, start Videoinfox. Load the list and Download.


                  *** A User List must be set first for the  videoinfox -l  shortcut to work ***

                  Create an empty User List.  Select: Create User List.  Give the list a name.
                  The new list will be displayed at the top of the screen.  Copy the entire line to the clipboard.

                  Then select: Set User List.  Your all set and ready to go.  You can exit Videoinfox if you want.

                  Note: Clipboard will be cleared everytime you run the shortcut.
                        Videoinfox doesn't need to be running to use the shortcut.


___________________________________________________________________________________________________________________

   *** The User Lists can be anywhere so lists need to be recursively reachable from the current directory ***
___________________________________________________________________________________________________________________


                  When a User List is set,

                  It will be stored until 1 of the 3 events happen:  - The list is downloaded
                                                                     - The list is deleted
                                                                     - Another list is set
___________________________________________________________________________________________________________________


                  You can also make a list with your preferred text editor.

                  The download list name always has to beigin with: videoinfox-dl to be accessed by Videoinfox.

                  Add anything to the end of the filename.


                  Sample download list name: videoinfox-dl-funny-videos


                  One video URL per line starting at line 1. No Spaces.

___________________________________________________________________________________________________________________


 COMMAND LINE OPTION: videoinfox -u       

 This option can be used with your own ready to download url list that can be any name and location. 
 There is no need to use the Videoinfox interface with this option. Videos will be downloaded to the 
 directory of the list location.  Example: videoinfox -u mylist  Only enter the list filename. 
 The list must be recursively reachable from the current directory.       
 The first line in the list must begin with http to be processed.

 videoinfox -h  will also display the above instuctions for: videoinfox -u

___________________________________________________________________________________________________________________


 Erorr correction on all Download Lists:  - remove all lines that don't start with  http
                                          - remove all duplicate lines.
                                          - remove all empty lines.

                                          * Download lists will be edited if they contain any of the above errors.

___________________________________________________________________________________________________________________


 DOWNLOAD QUEUE: Batch download multiple Videoinfox Created User Lists.
                 Copy a User List to the clipboard, enter to update then select Add to Queue.
                 When done adding User Lists to the queue, select Download Queue.

          Notes: Pressing enter after making a selection isn't necessary before selecting an option. Pressing enter
                 after clipboard copy will update the clipboard display and show what options are available.

                 If there is a User Set List and it gets processed by Download Queue, It will be cleared after
                 download. The list will be left untouched. It will just be cleard from User Set List.

                 User Lists will always be downloaded to the directory of the list's location.

___________________________________________________________________________________________________________________


 CREATE DIRECTORY: Easily create directories for your Download Lists with Navigate Tree & Default Dirs Interface.
                   After directory creation, Change to directory. Then Create User List.

___________________________________________________________________________________________________________________
EOF
#####  DOWNLOAD LIST HELP COMPLETED  ############################################################################################################# 
##################################################################################################################################################
##################################################################################################################################################
#####  7. CREATE HELP FILE  ###################################################################################################################### 
##################################################################################################################################################

#if [[ -f ${base_dir}/videoinfo.help ]]; then
#      :

#  else

cat << EOF > "${base_dir}/videoinfo.help"
___________________________________________________________________________________________________________________

 $ver  Where Video Play Is A Clipboard Copy Away
___________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________

 Up & Down Arrows or Mouse wheel - scroll                                                             Home - top
 q - quit                                                                                             End - bottom
___________________________________________________________________________________________________________________

 Find local Video Files fast and watch immediately. Download Video URL's effortlessly and watch immediately.

 Add URL's to The Default Download list on the fly without leaving your gui or starting up Videoinfox.

 Add URL's to any User Set List on the fly without leaving your gui or starting up Videoinfox.

 Batch download all of your User Created url Lists with Yt-dlp and Videoinfox's Download Queue.
___________________________________________________________________________________________________________________

 Version History is located in:  Settings (set)
___________________________________________________________________________________________________________________

 Find videos to play or get info on: Change to a parent directory of your video library and select Find.
 You can also select Show All to display all videos recursively.

 Search Tips:  The files you search for have to be in the path of the current directory.

 Using example filename:   The Reunion Show   and what searches would find it.

 the*      would find files starting with:  the     

 *ion*     would find files with:  ion  anywhere in the file name from the beginning to the end.

 *show     would find files that ended with:  show


 With search results on the screen, select Play Line and enter the number that you want to play.  
___________________________________________________________________________________________________________________

 1 2 3 4 5 - Default Dirs  One keypress to change default directories. <Set> to set default directories     

 Default 1-4 have display priority over 5. So if your directory on last exit (5) equals 1-4,  1-4 gets the display.  
___________________________________________________________________________________________________________________

 Last Search  <set>  If search results are not manually deleted <Clear Results> before exit,

                     Three Choices:     1 - Always Save     2 - Never Save     3 - Ask on Exit
___________________________________________________________________________________________________________________

 To use Play Clipboard: 
 
 Copy a video url to the clipboard and press enter to verify the url is valid.  
 Then  p  to Download and Autoplay Fullscreen. 
___________________________________________________________________________________________________________________
 

 Clipboard copy is used to interact with Videoinfox in the following areas: 

 Download video url's (yt-dlp) with Play Clipboard, Download Default, Download Choose and Self Destruct. 
 Copy a url link (entire line) to the clipboard before selecting any of the above options.

 Loading Download List, View Logs, and Add to Queue.
 Copy a list (entire line) to the clipboard before selecting any of the above options.

 Note: Optional. Press enter after clipboard copy to update the clipboard display to see all available options.

___________________________________________________________________________________________________________________

 Yt-dlp Menu    d - Download Default... Yt-dlp with no arguements.
                c - Download Choose.... Choose video type and quality before download.
                s - Self Destruct...... Download, auto play then delete when the video player is quit.
                g - Download List...... Instructions are located in Help on the Download List screen.

 Last Download works with Play Clipboard, Download Default and Download Choose.
 Self Destruct isn't written to Last Download because the video is deleted after closing the player."  >> ${base_dir}/videoinfo.help

 Note: Vidoeinfox keeps its own yt-dlp copy in:  ${base_dir}
       On every start of Videoinfox, it will check for its own update and notify if an update is available.
       No auto update checks are done for Yt-dlp.  To check for a Yt-dlp update and install update: Settings (Set)"  >> ${base_dir}/videoinfo.help
___________________________________________________________________________________________________________________

 Autoplay Features:


 Play Clipboard: Download and autoplay a video url that is in the clipboard.
                 This option always writes to the Played List.
                 Available in: Home Screen, Played List, Playlist, Yt-dlp Menu and View Downloads.

 Play Directory: Autoplay all videos in the current directory from beginning to end of the directory listing.
                 This option never writes to the Played List.
                 Available in: Home Screen, Navigate Tree and View Downloads.

 Autoplay Line:  Autoplay from line number entered to the end of the list.
                 This option never writes to the Played List.
                 Available in: Home Screen, Navigate Tree, Played List, Play List and View Downloads.

 Play Line:      Only play the line number entered.
                 This option always writes to the Played List.
                 Available in: Home Screen, Navigate Tree, Played List. Play List and View Downloads
                 Note: One exception. The Playlist will never write to the Played List.
___________________________________________________________________________________________________________________

 Create Unlimited Playlists." >>${base_dir}/videoinfo.help


 Playlist Add: Add videos to a playlist from the 3 below sources.

 - Home Screen. Add videos from recursive search results or recursive directory listings to the Playlist." >>${base_dir}/videoinfo.help

 - Navigate Tree. Add videos from one level deep directory listings to the Playlist." >>${base_dir}/videoinfo.help

 - Navigate Tree >>> Show All - Directory To Playlist. Add all videos in the current directory to a new Playlist." >>${base_dir}/videoinfo.help

 - Played List. Add videos from Played List to the Playlist." >>${base_dir}/videoinfo.help

                Play Clipboard, Last Download and Play Line all write to the Played List." >>${base_dir}/videoinfo.help

                Note: One exception. Play Line in View Playlist never writes to the Played List." >>${base_dir}/videoinfo.help
___________________________________________________________________________________________________________________

 Navigate Tree: Whatever the directory is when entering Navigate Tree will be set as the Treetop.
                Recursive Navigation from the Treetop.


                While in Navigate Tree, there are two ways to change the Treetop.

                - Default Dirs
                - Change Treetop

___________________________________________________________________________________________________________________

 videoinfox -h to see command line options.
___________________________________________________________________________________________________________________

 When you use:  Videoinfox Update in Settings (Set), the update will always be applied to: /usr/local/bin
___________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________

  Play Clipboard voodoo wouldn't have been possible without XCLIP

  Download feature wouldn't have been possible without YT-DLP


  Videoinfox Features:

  - Navigation was designed to be robust and efficient. One keypress for all menu selections. 
  - Check for update on startup and notifity if update is available. Download and update in Videoinfox.
  - Play a local file by entering the line number. Play single video or autoplay the entire list.
  - Create unlimited Playlists from: Recusive search results, Recursive directory listings and the Played List
  - Play Clipboard: Blinking notification when there is a valid video url for play.
  - Play Clipboard: Download a video url that is in the clipboard via Yt-dlp and autoplay.
  - Play Clipboard is available in: Home  Played List  Play List  Yt-dlp Menu  View Downloads
  - See codec, resolution and duration on the playing video.
  - Play Directory autoplay available in: Home Screen, Navigate Tree and View Downloads.
  - Autoplay video files in the current directory with option to quit. videoinfox -d
  - Blinking Play Directory otification when there are video files in the current directory.
  - Navigate Tree Blinking Change Directory notification when there is a valid directory in the clipboard.
  - Navigate Tree with Play Directory autoplay and Play Line with autoplay. Select line number to start play.
  - Video Player (ffplay) auto closes when the video ends.
  - Auto clear the clipboard after the video player is closed.
  - To watch the last download after Play Clipboard cleared the link select Last Download.
  - Auto clear the clipboard of invalid files and urls.
  - Press enter after your copy to the clipboard to validate clipboard content.
  - File types searched for: .webm   .mp4   .mkv   .avi   .divx
  - Rapid directory changing by setting default directories (4) in Settings. The 5th is dir at last exit.
  - Default Dirs - 1 2 3 4 5  available in: Home  Navigate Tree  Download List  More Options
  - Play Line option. Only play the line number entered and write to Played List.
  - Autoplay Line option. Start autoplay from any line in the Played List by entering the line number.
  - Played List will keep track of everything played except for Play Directory and Autoplay Line.
  - Played List: Play All option that will auto play the entire list with option to quit.
  - Playlist: Save a list of videos from search results, directory listings and Played List.
  - Remove duplicates from the Playlist and Played List.
  - Enter a video file with full path to get info on and play.
  - Auto save last find result(s) and autoload until deleted. Defaulted to never save. Change in Settings.
  - Yt-dlp integration for easy download and play of single url's or entire lists.
  - Download Queue: Add unlimited Videoinfox User Download Lists to the queue for download.
  - Download Default: Yt-dlp with no arguments. Download only. No auto play.
  - Download Choose: Choose video type and quality before download. Download only. No auto play.
  - Self Destruct: Download, auto play, delete when the player is closed.
  - Last Download available in: Home and Yt-dlp Menu for: Play Clipboard, Download Default and Download Choose.
  - Download List: Blinking notification on list load.
  - View Logs: Blinking notification on log load.
  - Default List: Keep pasting Video URL's on the fly from the clipboard to the Default List.
  - Default List companion: Create a gui shortcut for: videoinfox -a  to add to the Default List.
  - Unlimited User Lists: Keep pasting Video URL's on the fly from the clipboard to the User Set List.
  - User Set List companion: Create a gui shortcut for: videoinfox -l  to add to the User Set list.
  - Download any list. Any name and location. No need to use the Videoinfox interface: videoinfox -u listname
  - Download and update Yt-dlp in Videoinfox.
  - Save directory state on exit to load on next run.
  - Change directory by entering full path.
  - Find directory and change to it by copying it to clipboard.
  - List video info one directory deep. Save per directory.
  - Recursive count of videos broken down by video type.
  - Recursive duration (days:hrs:min:sec) Save per directory.
  - GUI notifications.
___________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________

 Privacy Policy: Videoinfox will never collect or attempt to transmit any information on it's users.

                 Internet activity will only happen under the following circumstances:

                 - On First Run, Github will be contacted to download Yt-dlp.
                 - On every start, Github will be contacted to download Videoinfox for Update Available Check.
                 - Everytime Videoinfox Update or Yt-dlp Update is selected in Settings, Github will be contacted.
                 - If there isn't a copy of Yt-dlp in Videoinfox's config directory, Github will be contacted
                   everytime you select the Yt-dlp Menu to attempt a download of Yt-dlp.
                 - Everytime Yt-dlp is used to download a video url.
                   Refer to Yt-dlp's site for their privacy policy. https://github.com/yt-dlp/yt-dlp
___________________________________________________________________________________________________________________

 Thanks for checking out Videoinfox!  If you encounter any issues: Reddit /videoinfox
___________________________________________________________________________________________________________________

 If Videoinfox is removed, the directory  ${base_dir}  will have to be manually deleted.
___________________________________________________________________________________________________________________
EOF


#fi

#####  HELP COMPLETED  ########################################################################################################################### 
##################################################################################################################################################
##################################################################################################################################################
#####  8. CREATE VERSION HISTORY FILE  ########################################################################################################### ################################################################################################################################################## 
cat << EOF > "${base_dir}/videoinfo-ver-history"
_________________________________________________________________________________________________________________________

$ver  Where Video Play Is A Clipboard Copy Away                                            VERSION HISTORY
_________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________________

Up & Down Arrows or Mouse wheel - scroll                                                                    Home - top
q - quit                                                                                                    End - bottom
_________________________________________________________________________________________________________________________


# KNOWN ISSUE

KNOWN ISSUES: v3.5.08 In Change Playlist when attempting to delete the Default Playlist.


_________________________________________________________________________________________________________________________" >> ~/.config/videoinfox/videoinfo-ver-history
echo >> ~/.config/videoinfox/videoinfo-ver-history
v3.9.02 Fix: Option display in View Playlist with a valid http video link in the clipboard." >> ~/.config/videoinfox/videoinfo-ver-history
echo >> ~/.config/videoinfox/videoinfo-ver-history
        Fix: Resume Autoplay would error on a new Playlist without initially running Start Autoplay." >> ~/.config/videoinfox/videoinfo-ver-history               
echo >> ~/.config/videoinfox/videoinfo-ver-history
        Added below line to Playlist >>> Help" >> ~/.config/videoinfox/videoinfo-ver-history
        When Resume Autoplay reaches the end of the playlist, it will remain there until Start Autoplay is run again." >> ~/.config/videoinfox/videoinfo-ver-history
_________________________________________________________________________________________________________________________

v3.9.00 View Playlist appearance update + new options in View Playlist and Navigate Tree >>> Show All.

        Add: Start Autoplay in View Playlist saves the last played video to Resume Autoplay.
             Resume Autoplay will also save the last played video.
             ** Use Start Autoplay first to begin watching **
             ** Use Resume Autoplay after to continue watching and keep track of where you left off in the playlist **
             More info. located in View Playlist >>> Help 

        Add: Delete Line in View Playlist. Delete line number entered from the playlist.

        Add: Directory To Playlist in Navigate Tree >>> Show All.
             This option will write a one level deep directory listing to a new playlist.
             Good for creating a tv show season number x playlist.

        Change: All blinking  -  changed to non blinking  ~  everywhere except the Yt-dlp Menu
                ** This will be updated in the Yt-dlp Menu along with selection by number instead of clipboard copy.

        Change: Home Screen, Played List and Playlist
                Clipboard: is hidden if there isn't a valid video url available in the clipboard.

        Fix: Home Screen >>> View Playlist
             After using Play Clipboard, the user set directory wasn't being restored on quit to home screen.

        Fix: View Playlist >>> Change Playlist
             The playlist name display wasn't updating if the loaded playlist was deleted.
             Note: If the loaded playlist is deleted, the default playlist will be loaded.

        Note: The loaded playlist is auto saved when another playlist is loaded.
_________________________________________________________________________________________________________________________

v3.8.00 Add, Move and Change

        Add: Show All to Navigate Tree.

        Move: The following options in Navigate Tree were moved to Navigate Tree >>> Show All
              - Autoplay Line   - Play Line   - View Playlist   - Playlist Add

        Add: - Info to Navigate Tree >>> Show All

        Change: Playlist Add now hides the Videoinfox Menu to gain more screen space for video listings.

        Add: Error Message to Playlist Add if number entered excedes the line count. 
        MSG: Number out of range . . .


        Note: There are only 2 areas left in Videoinfox that still use the clipboard feature.

        1. More Options >>> Find Directory

        2. Yt-dlp Menu >>> Download List
     
        - Download List     - Set User List
        - View List
        - View Logs         - Delete User List     - Add to Queue

        The above will all eventually be converted over from clipboard copy to line number for all selections.
        Once that is finished, the only time the clipboard feature will be used is in the gui. Copying video
        url's to the clipboard to download or when building a download list with a videoinfox keyboard shortcut.
_________________________________________________________________________________________________________________________

v3.7.00 Enter line number to change directory. No more clipboard copy to change directory on the following two screens.

        NAVIGATE TREE - Change Directory
        YT-DLP MENU >>> DOWNLOAD LIST >>> CREATE DIRECTORY - Change Directory

        Navigate Tree and Create Directory displays updated.
_________________________________________________________________________________________________________________________

v3.5.13 Moved options around in Yt-dlp Menu >>> View Downloads.

        Added: Clear Clipboard to Yt-dlp Menu.

        Added: Line to HOME >>> HELP. Autoplay Features - Play Clipboard - Available in ...
_________________________________________________________________________________________________________________________

v3.5.10 Updated info on Find screen.
_________________________________________________________________________________________________________________________

v3.5.09 Moved options around in Played List.
_________________________________________________________________________________________________________________________

v3.5.08 Fix in VIEW PLAYLIST >>> CHANGE PLAYLIST - Change Playlist when the DEFAULT Playlist was deleted.
        When the Default Playlist was deleted it generated a script error from the cp command.

        The Default Playlist can't be deleted. It can only be cleared. If the Default Playlist is deleted, it is
        temporarily removed (not deleted) from CHANGE PLAYLIST. The Default Playlist will show again in Change Playlist
        after another playlist is loaded. This issue in Change Playlist will be dealt with in a future update. 
_________________________________________________________________________________________________________________________

v3.5.07 MSG Change in Yt-dlp Menu >>> Download List >>> Create Directory  - Change Directory.

        Message shows when Change Directory is selected without a valid directory in the clipboard or
        the directory in the clipboard is outside of the Treetop.

        OLD MSG: At treetop. Can't go any higher . . .
        NEW MSG: Copy an above directory to the clipboard to use this feature . . .

Notes:  Whatever the directory is when entering Create Directory or Navigate Tree is set as the Treetop.
        While in Create Directory or Navigate Tree, the Treetop can be changed with Default Dirs or Change Treetop.
_________________________________________________________________________________________________________________________

v3.5.06 Fix: Play Line in Navigate Tree would try to play an out of range number.
_________________________________________________________________________________________________________________________

v3.5.05 Change: Ytdlp Menu >>> Download List - Create Directory option was changed from N to M
_________________________________________________________________________________________________________________________

v3.5.04 Add: Number out of range message to Played List >>> Play Line.

        Fix: Bug that Play Line and Autoplay Line were causing on the Home Screen.

        Fix: Typo in Yt-dlp >>> Download List >>> Help.

             From: Notes: Pressing enter BEFORE making a selection isn't necessary....
             To:   Notes: Pressing enter AFTER making a selection isn't necessary....
_________________________________________________________________________________________________________________________

v3.5.01 Fix: Some of the Play Clipboard selections were writing to the Play List instead of the Played List.
_________________________________________________________________________________________________________________________

v3.5.00 Add: Multi Playlist - Create unlimited playlists.

             Add videos to a playlist from the 3 below sources.

              - Home Screen. Add videos from recursive search results or recursive directory listings to the Playlist.
              - Navigate Tree. Add videos from one level deep directory listings to the Playlist.
              - Played List. Add videos from Played List to the Playlist.

              (Play Clipboard, Last Download and Play Line all write to the Played List).
_________________________________________________________________________________________________________________________

v3.4.22 Edit: Help in Download List - Create Directory.
_________________________________________________________________________________________________________________________

v3.4.21 Add: Blinking dash at Playlist Add in Played List.
_________________________________________________________________________________________________________________________

v3.4.20 Change: Create User List in Download List.

        If a list was saved with a filename that already existed, the existing list would be overwritten.

        Add: Error handling. If the file already exists, don't overwrite.
        MSG: File already exists . . .

        (At this time, there is no overwrite option.)
_________________________________________________________________________________________________________________________

v3.4.19 Changes in Download List.

        CREATER USER LIST

        Add: Error reporting for Create User List when enter is pressed with no user input.
        MSG: Nothing was entered . . .


        CREATE DIRECTORY

        Change: Create Directory not longer changes directory automatically after creation.

        Add: Error reporting for Create Directory when enter is pressed with no user input.
        MSG: Nothing was entered . . .

        Add: Error reporting for Create Directory if the directory already exists.
        MSG: Directory already exists . . .

        Add: Change Treetop added to Create Directory.
_________________________________________________________________________________________________________________________

v3.4.14 Add: Error reporting on empty clipboard for (Change Directory) in Navigate Tree.
        MSG: Copy a directory to the clipboard to use this feature . . .
_________________________________________________________________________________________________________________________

v3.4.13 Add: Error reporting when no viedos are available in View Downloads (Default Download Directory).
_________________________________________________________________________________________________________________________

v3.4.12 Add: Info (blinking dash) when videos are available.

        Fix: Option spacing in Play List when there was a url in the clipboard.
_________________________________________________________________________________________________________________________

v3.4.11 Edit: Home Help > Videoinfox Features:"  
_________________________________________________________________________________________________________________________

v3.4.10 Change: User Set List display in Download List."  

        Add: Show message on Home Screen when Show All is selected and there are no video files to play.
        MSG: No video files recursively reachable from the current directory . . .

        Add: Change Treetop in Navigate Tree.
             Now the Treetop can be changed by Default Dirs or by manually entering a directory.

        Add: Navigate Tree info in Home Help.
_________________________________________________________________________________________________________________________

v3.4.08 Add: Download List error reporting when trying to set the Default List as a User Set List."  
        MSG: The Default List can't be a User Set List. Only user created lists . . ."  

        Add: Download Queue removes any blank lines in each list in the queue before processing."  
_________________________________________________________________________________________________________________________

v3.4.07 Add: Show Message when Set User List is slected in Yt-dlp >>> Download List.

        Message: User list set for option: videoinfox -l   Also, gui notification.
_________________________________________________________________________________________________________________________

v3.4.06 Fix: View Downloads in Yt-dlp Menu.

             Play Directory, Autoplay Line and Play Line were not being displayed when there was a url in the clipboard.
_________________________________________________________________________________________________________________________

v3.4.05 Add: Error handling and reporting in Yt-dlp Menu.

        Download Default, Download Choose and Self Destruct. Yt-dlp won't try to process empty clipboard or invalid url.
        Error message: Clipboard is empty or contained invalid video url . . .
_________________________________________________________________________________________________________________________

v3.4.04 Fix: Error in Played List.
_________________________________________________________________________________________________________________________

v3.4.03 Fix: Last Download in Yt-dlp Menu wasn't changing back to user set directory after video play.
_________________________________________________________________________________________________________________________

v3.4.02 Updated Home Help and Version History.
_________________________________________________________________________________________________________________________

v3.4.01 Change timeout on message: Added to Playlist . . .
_________________________________________________________________________________________________________________________

v3.4.00 Added: Playlist Add in Played List. Add videos from the Played List to the Playlist.
               View Playlist added to Played List.

          Fix: Bug in Played List

       Update: Home Help > Autoplay Features and Playlist.
_________________________________________________________________________________________________________________________

v3.3.03 Fixed an error in Clear Results on Home Screen.
_________________________________________________________________________________________________________________________

v3.3.02 Switched 2 lines around in Yt-dlp >>> Download List
_________________________________________________________________________________________________________________________

v3.3.01 Add: Remove duplicates from the Play List.
_________________________________________________________________________________________________________________________

v3.3.00 Additions and Changes

        New feature: PlayList Add: add video selection to the Playlist by entering line number.
              
        Playlist Add: added to the Home Screen. Add to the Playlist from Search Results.

        Playlist Add: added to Navigate Tree. Add to the Playlist from directory listings.
                      View Playlist was added to Navigate Tree. 

        No more coying to the clipboard to play selections from the Playlist.
        View Playlist look and function was updated to maintain user interface continuity.

        Added to View Playlist: Autoplay Line and Play Line. Neither will write to the Played List.
        Removed error correction routine for clipboard copy errors. It was no longer needed.
        Added error correction to verify file validity before adding selection to the Playlist.


        Notes:

        Local video files can no longer be added to the Playlist from the Clipboard.
        Local video files played with Play Clipboard will still be added to the Played List.
        All Local video play and autoplay is now done by entering the line number or using Play Directory.
 
    
        The clipboard feature is still used to:

        Download video url's (yt-dlp) with Play Clipboard, Download Default, Download Choose and Self Destruct.
        Loading Download List, View Logs, and Add to Queue.
        Change Directories in Navigate Tree and Create Directory.

        Updated Home Help.
_________________________________________________________________________________________________________________________

v3.0.00 New features in Yt-dlp >>> Download List. Added: Add to Queue, Download Queue and Create Directory.
_________________________________________________________________________________________________________________________

v2.9.52 Updated header in View Downloads.
_________________________________________________________________________________________________________________________

v2.9.51 Updated Autoplay Features in Home Help.
_________________________________________________________________________________________________________________________

v2.9.50 Fixed Major Faux Pas with Autoplay Line and Play Line.
        I was referencing the absolute path on my machine with the last 2 added features.

        Added Play Directory, Autoplay Line and Play Line to View Downloads.
_________________________________________________________________________________________________________________________

v2.9.41 Removed play loop exit in Play Line.
_________________________________________________________________________________________________________________________

v2.9.40 Played List Menu Updated. No more copying to the clipboard to play a local file. Enter line number to play.
_________________________________________________________________________________________________________________________

v2.9.30 Change, Add and Fix.

        Change: Renamed Play Line to Autoplay Line. Autoplay from entered line number to end of list.
                - Home Screen: Moved a few things around. Autoplay Line will not write to the Played List.
                - Navigate Tree: Moved a few things around. Autoplay Line will not write to the Played List.

           Add: - Play Line to Home Screen. Only Play Line number entered. This feature will write to the Played List.
                - Play Line to Navigate Tree. Only Play Line number entered. This feature will write to the Played List.

                - Autoplay Features added to Home Help.

           Fix: Last Search Setting (Ask On Exit) was freezing script on invalid selection.
_________________________________________________________________________________________________________________________

v2.9.01 Fix: Video Info on Home Screen. Get info on video in clipboard or by entering the line number.
_________________________________________________________________________________________________________________________

v2.9.00 Add: Play Number on Home Screen.
             No more copying a find result to the clipboard to play. Select Play Number and enter the number to play.
_________________________________________________________________________________________________________________________

v2.8.44 Add: Error reporting added to command line options. User notified if videoinfox's config directory is missing.
_________________________________________________________________________________________________________________________

v2.8.42 Add: videoinfox -d  Autoplay video files in the current directory.
_________________________________________________________________________________________________________________________

v2.8.41 Fix: Play Directory alphabetical sorting for directories that include multiple file extensions.
_________________________________________________________________________________________________________________________

v2.8.40 Added: Navigate Tree >>> Play Line. Select line number to start autoplay from directory listing.

        Fix: Find results needed sorted alphabetically in: Find Directory and Home Find.
_________________________________________________________________________________________________________________________

v2.8.30 Added: Played List >>> Play Line. Start Autoplay from any line in the Played List by entering the line number.
_________________________________________________________________________________________________________________________

v2.8.26 Fixed: Play Clipboard play notificaton displaying when processing an invalid url.
_________________________________________________________________________________________________________________________

v2.8.25 Fixed: Flawed logic in Last Download and http side of Play Clipboard keeping track of last sucessful download.
_________________________________________________________________________________________________________________________

v2.8.24 Fixed: Play Clipboard and Last download were breaking with file names that contained a [
_________________________________________________________________________________________________________________________

v2.8.23 Updated: Home Help. Last Download will work with Play Clipboard, Download Default and Download Choose..
                 I fixed this many updates ago and forgot to update it in help.
_________________________________________________________________________________________________________________________

v2.8.22 Added: Error Reporting for Play Clipboard and Play Directory.

               If Play Clipboard is selected with no playable content available in the clipboard,
               Error Message Displayed: No playable content in the clipboard . . .
               With Play Clipboard, you will also see this message right after a Yt-dlp download completes.
               The error shows there because the clipboard is cleared immediately after the download is completed.

               If Play Directory is selected with no playable content available in the current directory,
               Error Message Displayed: No playable content in the current directory . . .

        Fix: If a User Set List was deleted outside of Videoinfox, It would still display as a Set User List.
             Now when download Download List menu is selected, if a list doesn't exist, it is cleared from User Set List.
             The gui notification will also notify if the user download list is not set or missing when using the
             videoinfox -l shortcut. 
_________________________________________________________________________________________________________________________

v2.8.20 Added: Play All option for Played List. Auto play the entire list with option to quit.
_________________________________________________________________________________________________________________________

v2.8.14 Fix: Directory at exit was not auto loading on next run.
_________________________________________________________________________________________________________________________

v2.8.13 Added: Privacy Policy added to Home Help
_________________________________________________________________________________________________________________________

v2.8.12 Edited: Version History. Posted known issue.

                If Play Clipboard is selected with an invalid video url in the clipboard, the gui play notification
                still displays. This only happens if Play Clipboard is selected before pressing enter.
_________________________________________________________________________________________________________________________

v2.8.11 Updated: Home Help and Download List Help.
_________________________________________________________________________________________________________________________

v2.8.10 Added: Command line option -u

               This option can be used with your own ready to download url list that can be any name and location.
               There is no need to use the Videoinfox interface with this option. Videos will be downloaded to the
               directory of the list location.  Example: videoinfox -u mylist  Only enter the list filename.
               The list must be recursively reachable from the current directory.
               The first line in the list must begin with http to be processed.

               videoinfox -h  will display the above instructions.
_________________________________________________________________________________________________________________________

v2.8.05 Fixed issues from v2.8.03 and v2.8.04 Had a mess going on here for a minute.
_________________________________________________________________________________________________________________________

v2.8.04 Fix: I was unaware that my cat edited the last update before commit. Forgot to lock the keyboard and auto save
             got the cat's edit.  The dog really did eat my homework. lol
_________________________________________________________________________________________________________________________

v2.8.03 Fix: Videoinfox Update Available was showing on download fail.

             I went back through the download and update routines and found more errors.
             Fixed error checking and reporting. Tested all possible scenarios with download success vs. download fail.
_________________________________________________________________________________________________________________________

v2.8.02 Fix: Videoinfox and Yt-dlp download and update routines.

             On download fail, notification given.
_________________________________________________________________________________________________________________________

v2.8.01 Fix: a mistake that was in command line option: videoinfox -h

        Error:       -u Write clipboard content to User Set List.
        Correction:  -l Write clipboard content to User Set List.
_________________________________________________________________________________________________________________________

v2.8.00 Feature Added: videoinfox -l shortcut for User Lists.

        Copy your links on the fly without needing to have Videoinfox running.
        Complete instructions located in: Yt-dlp >>> Download List >>> Help
_________________________________________________________________________________________________________________________

v2.7.15 Updated: Features List In Help
_________________________________________________________________________________________________________________________

v2.7.14 Added: Command line option -h
_________________________________________________________________________________________________________________________

v2.7.13 Change: Videoinfo Update exit message appearance.
_________________________________________________________________________________________________________________________

v2.7.12 Bug Squashed: Download List

        Fix: After downloading a user list, the directory wasn't changing back to what is was before downloading list.
_________________________________________________________________________________________________________________________

v2.7.11 Completed Version History.

        It has been a month of heavy coding since I started writing Videoinfox. I initially wrote it because I wanted
        to learn more about the Linux Shell.  I have been a Linux only user for 18 years.  I have learned more about
        Linux in the last 30 days than I have in the past 18 years.  Screenshot of first script at bottom of page.
_________________________________________________________________________________________________________________________

v2.7.10 Added:  Code Stats  to Settings (set)  Edited Help on home screen.  Cleaned up some comments.
_________________________________________________________________________________________________________________________

v2.7.00 Changes, Additions and Bug Squashing.

        Cosmetic update on  1 2 3 4 5 - Default Dirs  display.
        When a default directory is selected that number stays normal while the other 4 numbers will be less bold.
        If you change to a directory that is not a default directory 1-5: All 5 numbers will be less bold.
        If directory on exit (5) matches any of the default directories 1-4: 1-4 gets the display.

        Download List  - Added:  1 2 3 4 5 - Default Dirs  selector.

        More Options   - Changed look to maintain continuity.  
                       - Changed options from numbers to letters
                       - Added:  1 2 3 4 5 - Default Dirs  selector.

        Home Screen    - Changed Navigate Tree option from  t  to  n

        View Downloads - Directory is saved on the way in because the dir is changed to the Default Download Directory.
                         Directory is restored on quit.

        Fix: View Downloads   Valid clipboard content was being lost on quit.
                              Valid clipboard content should only be cleared after Video Player exit.

        Fix: Navigate Tree -  Directory was getting changed when quitting to the Home screen.

        Fix: Self Destruct - After copying to the clipboard, you had to press enter first.

        Fix: Download List - After a list was downloaded the directory was changed back to what it was pre download. 

        First Run now checks for the directory: ~/Downloads  If the directory doesn't exist, it is created.

        Directory Policy: Directory will only be change when the user changes the directory. 
_________________________________________________________________________________________________________________________

v2.1.00 Added Default Download List and a command line option  -a  for making a gui shortcut
        to keep pasting your clipboard copies on the fly to the Default List without needing to run Videoinfox.
        Videoinfox will run, paste your clipboard content to the Default List and exit.  Make Shortcut:  "videoinfox -a"  

        New feature located in:  Yt-dlp Menu >>> Download List >>> Default List           Help -  Download List >>> Help
_________________________________________________________________________________________________________________________

v2.0.73 Added done downloading gui notification to Download Default."
_________________________________________________________________________________________________________________________

v2.0.72 View Downloads  and  Last Download."

        Fix: Valid clipboard content was being cleared after the above options were run then quit."

        Clipboard Policy: There are only 2 circumstances when valid clipboard content will be cleared."

                          1. User copies to clipboard.     2. Clipboard has been played."
_________________________________________________________________________________________________________________________

v2.0.71 Play Clipboard handling of invalid urls and an empty clipboard."

        Fix: Running Play Clipboard with an invalid url would play the Last Download."

        Add: Play Clipboard won't run if the clipboard is empty."
_________________________________________________________________________________________________________________________

v2.0.70 Download List menu fixes and change to download Log."

        Fix: If you would try to Download List with an empty clipboard, it would throw an error."

        Add: View List won't run if the clipboard is empty."
        Add: View Log  won't run if the clipboard is empty."

        Change: Download log only shows url and matching filename.
_________________________________________________________________________________________________________________________

v2.0.69 Added another decimal to the version number be compliant with Semantic Versioning."
_________________________________________________________________________________________________________________________

v2.068  Fixed auto play failing with urls in Play Clipboard. This issue also caused Last Download auto play to fail. "
        Below is what would cause the failure.

        Only with a URL. If you download a video file and you already have a filename with the same name but a
        different video extension in the current directory, it would cause Play Clipboard auto play to fail.
        Last Download would also fail to play in this situation.
_________________________________________________________________________________________________________________________

v2.067  Play Directory will only execute if video files exist in the current directory.

        On the Home Screen, the dash at Play Directory will blink if video files exist in the current directory.
_________________________________________________________________________________________________________________________

v2.066  Version History added to Settings  Version History is still under construction.
_________________________________________________________________________________________________________________________

v2.065  Auto clear clipboard content after player quit script wide.
      
        Before Update:  Yty-dlp Menu  Valid video url in the clipboard causes Play Clipboard to blink.
        After Update: Blinking along with Play Clipboard, (just -)  Download Default, Download Choose and Self Destruct

        They are all available options with a valid video url in the clipboard.
_________________________________________________________________________________________________________________________

v2.064  More error handling with clipboard content

        Affected areas: Anywhere there is Play Clipboard. Also, Navigate Tree and Download List

        Any content that is copied to the clipboard that doesn't start with   http   was addressed with this update.
        A file exist check is done on the clipboard content. If the file doesn't exist,
        the clipboard is cleared and the invalid content never makes it to the clipboard display.

        This was already done at the end of the loop. Now it is also done at the start of the loop.

        The above update doesn't include    http   because Yt-dlp validates anything that starts with   http
_________________________________________________________________________________________________________________________

v2.063  Download List Menu fix.

        I forgot to refresh the clipboard variable   pasteclip   in the following options:

        d - Download List     v - View List     l - View Logs

        The user was forced to press enter after copying to the clipboard for the above options to work.

        Now those 3 features refresh the clipboard variable upon entering those options.
        No need to press enter after copy unless you want to update the clipboard display first.
_________________________________________________________________________________________________________________________

v2.062  Bug Squashed in Play Clipboard and Last Download.

        If you downloaded a video file and you already had the same filename in another directory, find was returning
        more than one result .  This caused Play Clipboard to fail on auto play.
        It also caused Last Download play to fail. 
        FIX: -maxdepth 1 was added to those find lines in Play Clipboard and Last Download.

_________________________________________________________________________________________________________________________

v2.061  Download List added to the Yt-dlp Menu.

        Create download list(s) of video urls with your preferred text editor.
        Then use Videoinfox to download the entire list.

        Help located in:   Download List   explains how the download list feature works.
echo "_________________________________________________________________________________________________________________________

v2.060  Fixed typo on Navigate Tree 
_________________________________________________________________________________________________________________________

v2.059  Blinking Change Directory in Navigate Tree.
echo
        Change Directory blink when valid directory is in clipboard.

        Also added a loop to Change Directory in Navigate Tree.
        To prevent changing to clipboard copied directories outside of the Treetop.
_________________________________________________________________________________________________________________________

v2.058  Yt-dlp menu update. Now 2 download choices:

        d - Download Default - Yt-dlp with no arguments.
        c - Download Choose  - Choose video type and quality before download.
_________________________________________________________________________________________________________________________

v2.057  1 2 3 4 5 - Default Dirs added to Navigate Tree.

        Total Files: added  (file count 1 dir deep)  Navigate Tree
_________________________________________________________________________________________________________________________ 

v2.056  Added missing features in Navigate Tree

        Clipboard content is now saved when entering Navigate Tree and restored on quit.

        Total Files: (recursive) Was added to the display.

        When navigating in or out of a directory, 
        Play Directory will blink when video files are available in the current directory.

        Yt-dlp menu - Clear clipboard after download.
_________________________________________________________________________________________________________________________

v2.055  Added Navigate Tree with Play Directory:
   
        Change Directory, Up one Level and Treetop
_________________________________________________________________________________________________________________________

v2.054  Play Directory

        Play Directory - Auto play with option to quit every time a video ends (played to end or quit by user).

        Moved options around on the home screen.  The blank space will be for another feature.

        (set) was changed from  d  to  z        - d  is now for Play Directory

        all  (x - Clear Clipboard) have been removed because Play Clipboard will clear the clipboard
        everytime there is an invalid valid file or url in the clipboard.  If it is a vald url but not a video url,
        yt-dlp will catch that and the clipboard will be cleared.
_________________________________________________________________________________________________________________________

v2.053  Video Player (ffplay) auto closes when the video ends.

        Auto exit was added to all ffplay lines.
_________________________________________________________________________________________________________________________

v2.052  Added check for update on startup
echo  
        If update available: Message displayed in Videoinfox only on the home screen right after the version number.
        Home screen display: update available with gui notification: Update Available & update version number
_________________________________________________________________________________________________________________________

v2.051  Added digit after decimal on version number.

        fix: Help file wasn't  getting updated for existing users. 
_________________________________________________________________________________________________________________________

v2.05   Some code comments fixed. Sample video url loaded for first run.
_________________________________________________________________________________________________________________________

v2.04   Play Clipboard now on all content screens.

        Squashed a bug in Play Clipboard. 
        That feature would fail when url had a video filename that had a dot before the .ext

        New feature added in  >>> SETTINGS >>> LAST SEARCH

        If there are search results on the the home screen on exit, the below always applies to your next run.

        1 - Always Save     2 - Never Save     3 - Ask on Exit
_________________________________________________________________________________________________________________________

v2.03   Added space below prompt at (play list deleted) and (played list deleted).
_________________________________________________________________________________________________________________________

v2.02   Major Layout changes to remove interface redundancy. + more features.

        Home, playlist and played list screens are aware if the clipboard contains a valid file or a valid url link in
        it and act accordingly. Yt-dlp now tries to extract a fliename from the link in the clipboard. If it is
        successful, the videos name will be displayed.  Now every time there is a valid file or a valid url in the 
        clipboard... <Play Clipboard> will blink to let the user know there is playable content in the clipboard. 
_________________________________________________________________________________________________________________________

v2.01   Had to change the timeout on the first run screen from 3 seconds back to 30 seconds.
_________________________________________________________________________________________________________________________

v2.00   Intoroduction of Play Clipboard.
_________________________________________________________________________________________________________________________

v1.99 and earlier versions:  I wasn't keeping track of version history.  At that point in time, I didn't plan on
Videoinfox having all the features it has now.  It was just a few hundred lines of code to find a video file's codec,
resolution and duration.
_________________________________________________________________________________________________________________________

Videoinfox's Start: Below was the first home screen which is now just another option (More Options) in Videoinfox. 
                    It was named Videoinfo until I found out the word Videoinfo was already in use. 


                    Working Directory:
                    Clipboard Content:

                    Videoinfo

               
                    1. List Directory

                    2. Change Directory
                    3. Find Directory

                    4. Enter Video File
                    5. Find Video File

                    6. Video Count
                    7. Video Duration


                    Enter an Option: 

_________________________________________________________________________________________________________________________
EOF

###########################  END VERSION HISTORY  ################################################################################################ 
##################################################################################################################################################
read -r diratexit < ${base_dir}/videoinfo.dir-at-exit
cd "$diratexit" 2>/dev/null 

#   The Line below is what gets the Codec & Resolution from a video file.
codecres="ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1"
if [[ ! -f ${base_dir}/videoinfo.playlist.current ]]; then
    echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current
fi
##################################################################################################################################################
###########################  HOME LOOP START #####################################################################################################
##################################################################################################################################################

menuf() {
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

    grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

    if [[ "$grabclip" != "http" ]]; then
        if [[ ! -f "$pasteclip" ]]; then
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
        fi
    fi
    # playedlist sort routine removed here

    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

    dirinhome="$PWD" 

    #  Load directory from last exit
    echo "$dirinhome" > ${base_dir}/videoinfo.home.dir

    grabdirfornav="$PWD"  # Save tree top before entering  NAVIGATE TREE  loop
    echo "$grabdirfornav" > ${base_dir}/videoinfo.navigate-dir-dat
    read -r grabdirfornav2 < ${base_dir}/videoinfo.navigate-dir-dat

    clear

    #  read last find total file count
    read -r searchtotal < ${base_dir}/videoinfo.lastsearchtotal

    # save date and time of last find
    stat -c '%y' ${base_dir}/videoinfo.findwork > ${base_dir}/videoinfo.lastfindtime

    # line below  strip tha last 17 characters from <stat> time of file: ${base_dir}/videoinfo.lastfindtime
    cat ${base_dir}/videoinfo.lastfindtime | awk '{ print substr( $0, 1, length($0)-17 ) }' | cut -c 4- > ${base_dir}/videoinfo.time
    mv ${base_dir}/videoinfo.time ${base_dir}/videoinfo.lastfindtime

    #  if search total is any number
    if [[ "$searchtotal" = "" ]]; then
        dashj=$(echo "-")  # don't blink dash on home screen @ Play Number
        rm ${tmp_dir}/videoinfo-findwork.tmp 2>/dev/null
        rm ${tmp_dir}/videoinfo-number-findwork.tmp 2>/dev/null

        # clear search results
        echo "" > ${base_dir}/videoinfo.lastsearchtotal
        echo "" > ${base_dir}/videoinfo.lastfindstring
        echo "" > ${base_dir}/videoinfo.lastfinddir

    else
        #####dashj=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")  # blink dash on home screen @ Play Number
        dashj=$(echo "~")

        # cat ${base_dir}/videoinfo.findwork

        #  REMOVE BLANK LINES
        sed '/^$/d' ${base_dir}/videoinfo.findwork > ${tmp_dir}/videoinfo-findwork.tmp 2>/dev/null

        # REMOVE PATH ONLY LEAVING FILENAME
        sed 's/.*\///' ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-number-findwork.tmp2 2>/dev/null

        # CREATE NUMBERED lIST
        sed '/./=' ${tmp_dir}/videoinfo-number-findwork.tmp2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo-number-findwork.tmp 2>/dev/null
        rm ${tmp_dir}/videoinfo-number-findwork.tmp2 2>/dev/null
        cat ${tmp_dir}/videoinfo-number-findwork.tmp  # display numbered find results    

        echo      
        echo "Dir: "$(cat ${base_dir}/videoinfo.lastfinddir 2>/dev/null) # display last directory that last find was run from
        echo "Date: "$(cat ${base_dir}/videoinfo.lastfindtime 2>/dev/null) # display last find time
        echo "Search: "$(cat ${base_dir}/videoinfo.lastfindstring 2>/dev/null)  # display last find string that was used
        echo "Results: ""$searchtotal"  # number of files found
    fi
    # LOAD DEFAULT DIRECTORIES
    read -r dir1 < ${base_dir}/videoinfo.tv-dir 2> /dev/null
    read -r dir2 < ${base_dir}/videoinfo.movies-dir 2> /dev/null
    read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null
    read -r dir4 < ${base_dir}/videoinfo.parent-dir 2> /dev/null
    read -r dir5 < ${base_dir}/videoinfo.dir-at-exit 2> /dev/null

    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

    ##################################################################################
    ##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
    ################################################################################## 

    # DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

    # DEFAULT DIR NUMBER 1 FORMAT
    dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
    # DEFAULT DIR NUMBER 2 FORMAT
    dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
    # DEFAULT DIR NUMBER 3 FORMAT
    dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
    # DEFAULT DIR NUMBER 4 FORMAT
    dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
    # DEFAULT DIR NUMBER 5 FORMAT
    dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
    # NO MATCH ALL LESS BOLD
    dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
    # FORMAT PWD NAME FOR COMPARISON
    echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
    cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
    rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

    # FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
    echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
    cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
    rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

    # FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
    echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
    cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
    rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

    # FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
    echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
    cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
    rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

    # FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
    echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
    cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
    rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

    # FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
    echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
    cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
    rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
    # LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

    read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
    read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
    read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
    read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
    read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
    read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
    # DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

    if [[ "$controldir" = "$dir5display" ]]; then 

        if [[ "$dir5display" = "$dir1display" ]]; then
            dirdisp="$dirdisplay1"
        fi

        if [[ "$dir5display" = "$dir2display" ]]; then
            dirdisp="$dirdisplay2"
        fi

        if [[ "$dir5display" = "$dir3display" ]]; then
            dirdisp="$dirdisplay3"
        fi

        if [[ "$dir5display" = "$dir4display" ]]; then
            dirdisp="$dirdisplay4"
        fi
    fi

    # DEFAULT DIR 5 DISPLAY
    if [[ "$controldir" = "$dir5display" ]]; then
        dirdisp="$dirdisplay5"  # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
    else
        dirdisp="$dirdisplayno" # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
    fi 

    # DEFAULT DIR 1  DISPLAY
    if [[ "$controldir" = "$dir1display" ]]; then 
        dirdisp="$dirdisplay1"
    fi

    # DEFAULT DIR 2  DISPLAY
    if [[ "$controldir" = "$dir2display" ]]; then 
        dirdisp="$dirdisplay2"
    fi

    # DEFAULT DIR 3  DISPLAY
    if [[ "$controldir" = "$dir3display" ]]; then 
        dirdisp="$dirdisplay3"
    fi

    # DEFAULT DIR 4  DISPLAY
    if [[ "$controldir" = "$dir4display" ]]; then 
        dirdisp="$dirdisplay4"  # if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
    fi

    ################################################################################
    ##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
    ################################################################################
    # CHECKING FOR VIDEOS IN CURRENT DIRECTORY.  if video(s) exist:  the dash @ Play Directory will blink on the home screen
    dovideosexist=$(find_supported_files --count)

    if [[ $dovideosexist -ne 0 ]]; then 
        dash=$(echo "~")  
    else
        dash=$(echo "-")  
    fi
    # if [[ "$searchtotal" = "" ]]; then
    #      :
    #  else
    #      echo
    #      echo "Copy 1 above result to clipboard then press enter"
    # fi

    echo
    echo "Directory: ""$PWD"
    #echo "Clipboard: ""$pasteclip"

    ##################################################################################################################################################

    #                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

    ##################################################################################################################################################

    # the 2 lines of below code are creating two new variables for the following loop.
    # 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
    # 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

    # for main if loop - to look for <http>
    grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

    # for nested if loop - to look for </>
    grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

    # the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
    # If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
    # If it isn't <http>  the ytdlp loop will be skipped

    if [[ "$grabpaste" = "http" ]]; then
        echo "Clipboard: ""$pasteclip"
    fi
    if [[ "$grabpaste" = "http" ]]; then
        read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
        ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

        if [[ "$ytdlpconfirm" = "" ]]; then

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
            #________________x________________________________________ _________________________________________________________
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " $der $viv4      Enter - Update Clipboard Display                "$dirdisp" - Default Dirs"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " f - Find              n - Navigate Tree     p - Play Clipboard     d "$dash" Play Directory     y - Yt-dlp     e - Exit"
            echo " a - Show All          l - Last Download     s - View Playlist      o "$dashj" Autoplay Line      i "$dashj" Info       z - Set" 
            echo " c - Clear Results     v - Played List       k "$dashj" Playlist Add       j "$dashj" Play Line          x - Clrclp     h - Help"
            echo " m - More Options"
            echo         
        else  # yt-dlp extracted a filename
            echo
            echo "YT-DLP Confirmed: "$ytdlpconfirm""
            echo
            echo "Download Directory: $dirsaved"  # dislpay default download directory
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " $der $viv4      Enter - Update Clipboard Display                "$dirdisp" - Default Dirs"
            echo "___________________________________________________________________________________________________________________"
            echo

            echo -e " f - Find              n - Navigate Tree     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m     d "$dash" Play Directory     y - Yt-dlp     e - Exit"

            echo " a - Show All          l - Last Download     s - View Playlist      o "$dashj" Autoplay Line      i "$dashj" Info       z - Set" 
            echo " c - Clear Results     v - Played List       k "$dashj" Playlist Add       j "$dashj" Play Line          x - Clrclp     h - Help"
            echo " m - More Options"
            echo                                                             
        fi
    else

        if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " $der $viv4      Enter - Update Clipboard Display                "$dirdisp" - Default Dirs"
            echo "___________________________________________________________________________________________________________________"
            echo

            echo -e " f - Find              n - Navigate Tree     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m     d "$dash" Play Directory     y - Yt-dlp     e - Exit"

            echo " a - Show All          l - Last Download     s - View Playlist      o "$dashj" Autoplay Line      i "$dashj" Info       z - Set" 
            echo " c - Clear Results     v - Played List       k "$dashj" Playlist Add       j "$dashj" Play Line          x - Clrclp     h - Help"
            echo " m - More Options"
            echo                                                             

        else  # file does not exist

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo 
            echo " $der $viv4      Enter - Update Clipboard Display                "$dirdisp" - Default Dirs"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " f - Find              n - Navigate Tree     p - Play Clipboard     d "$dash" Play Directory     y - Yt-dlp     e - Exit"
            echo " a - Show All          l - Last Download     s - View Playlist      o "$dashj" Autoplay Line      i "$dashj" Info       z - Set" 
            echo " c - Clear Results     v - Played List       k "$dashj" Playlist Add       j "$dashj" Play Line          x - Clrclp     h - Help"
            echo " m - More Options"
            echo         
        fi
    fi

    echo -en " Enter Option: "
    read -r -n1 optionf
}

while true; do
    menuf
    case $optionf in
        h)  # HELP
            #clear
            less ${base_dir}/videoinfo.help  # This help file is recreated on every start
        ;;    
        e)   # EXIT  
            echo "$PWD" > ${base_dir}/videoinfo.dir-at-exit  # SAVE DIRECTORY AT EXIT
        
            read -r lsearch < ${base_dir}/videoinfo.lastsearch-set  # load last search setting

            if [[ "$lsearch" = 1 ]]; then
                :
            fi

            if [[ "$lsearch" = 2 ]]; then
                
                ######### CLEAR FIND RESULTS ##########
                echo " " > ${base_dir}/videoinfo.lastsearchtotal
                echo " " > ${base_dir}/videoinfo.lastfindstring
                echo " " > ${base_dir}/videoinfo.lastfinddir

                # CREATE FIND RESULT MESSAGE THAT THERE ARE NO STORED FINDS
                #echo "                                                                                                                 " > ${base_dir}/videoinfo.findwork
                #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                #echo "Select find to search for files.                                                                                 " >> ${base_dir}/videoinfo.findwork
                #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork     
                echo > ${base_dir}/videoinfo.findwork
            fi
            if [[ "$lsearch" = 3 ]]; then
                function menuq {
                    clear
                    echo -e "\n"
                    echo
                    echo "___________________________________________________________________________________________________________________"  
                    echo
                    echo " $der >>> LAST SEARCH"
                    echo "___________________________________________________________________________________________________________________" 
                    echo        
                    echo -en " 1 - Save Search Results     2 - Clear Search Results "
                    read -r -n1 optionq
                    echo
                }

                while true; do
                    menuq
                    case $optionq in
                        1)  # DO NOTHING SEARCH IS ALREADY SAVED
                            break
                        ;;
                        2)
                            ######### CLEAR FIND RESULTS ##########
                            echo " " > ${base_dir}/videoinfo.lastsearchtotal
                            echo " " > ${base_dir}/videoinfo.lastfindstring
                            echo " " > ${base_dir}/videoinfo.lastfinddir

                            # CREATE FIND RESULT MESSAGE THAT THERE ARE NO STORED FINDS
                            #echo "                                                                                                                 " > ${base_dir}/videoinfo.findwork
                            #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                            #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                            #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork
                            #echo "Select find to search for files.                                                                                 " >> ${base_dir}/videoinfo.findwork
                            #echo "                                                                                                                 " >> ${base_dir}/videoinfo.findwork     

                            echo > ${base_dir}/videoinfo.findwork
                            break;;

                        *)

                    esac
                done
            fi

            clear
            echo -e "\n"
            echo
            echo "___________________________________________________________________________________________________________________"  
            echo
            echo " $der >>> EXIT"
            echo "___________________________________________________________________________________________________________________" 
            echo
            echo
            echo " Directory state SAVED for next run:" "$PWD"
            sleep .7

            break
        ;;
        o)
            ##################################################################################################################################################
            ###########################   AUTOPLAY LINE  o   <HOME>  #########################################################################################
            ##################################################################################################################################################

            if [[ -f ${tmp_dir}/videoinfo-findwork.tmp ]]; then
                echo
                echo
                read -r -p " Autoplay Line: " linenumber  # waiting fot user input

                tail -n +"$linenumber" ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-home-autoplay.tmp 2>/dev/null
                input="$HOME""/.config/videoinfox/tmp/videoinfo-home-autoplay.tmp"

                OLDIFS=$IFS
                IFS=$'\n'

                for line in $(cat "$input" 2>/dev/null); do
                    clear
                    echo
                    echo "___________________________________________________________________________________________________________________"
                    echo
                    echo " ""$der"" >>> SEARCH RESULTS >>> AUTOPLAY LINE" 
                    echo
                    echo " [PLAY]>" "$line"
                    echo "___________________________________________________________________________________________________________________"
                    echo

                    echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
                    
                    echo
                    echo
                    echo " Video Player Controls:"
                    echo                             
                    echo " - Fullscreen Toggle: f"
                    echo
                    echo " - Play/Pause Toggle: space bar"
                    echo
                    echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
                    echo
                    echo " - Quit: q"      
                    echo -e "\n"

                    ffplay -fs -autoexit "$line" 2> /dev/null

                    echo " To bypass the 3 second wait press enter with no entry"
                    echo
                    echo -e "\033[5m 3 seconds remaining to quit Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
                    echo 
                    read -t 3 -p " Press any key then press enter to quit : " playdir
                        
                    # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
                    if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                            break                                                   # if enter is pressed without any input the next video will play
                    fi
                done
 
                rm ${tmp_dir}/videoinfo-home-autoplay.tmp 2> /dev/null
                IFS=$OLDIFS

                else
                    echo
                    echo
                    echo " Select Show All or use Find to acess this feature . . ."
                    sleep 1.7
                fi

            ;;
            j)
                ##################################################################################################################################################
                ###########################   PLAY LINE  j   <HOME>  #############################################################################################
                ##################################################################################################################################################

                if [[ -f ${tmp_dir}/videoinfo-findwork.tmp ]]; then
                    echo
                    echo
                    read -r -p " Play Line: " linenumber  # waiting fot user input

                    # create file moving selected line number to the top
                    tail -n +"$linenumber" ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null
                    
                    # read first line of file for play
                    read playnumber < ${tmp_dir}/videoinfo-findwork-playnumber.tmp

                    if [[ ! -z "$playnumber" ]]; then
                        clear
                        echo
                        echo "___________________________________________________________________________________________________________________"
                        echo
                        echo " ""$der"" >>> SEARCH RESULTS >>> PLAY LINE" 
                        echo
                        echo " [PLAY]>" "$playnumber"
                        echo "___________________________________________________________________________________________________________________"
                        echo

                        echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$playnumber")  " Duration:" $(ffmpeg -i "$playnumber" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height & duration
                        echo
                        echo
                        echo " Video Player Controls:"
                        echo                             
                        echo " - Fullscreen Toggle: f"
                        echo
                        echo " - Play/Pause Toggle: space bar"
                        echo
                        echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
                        echo
                        echo " - Quit: q"      
                        echo -e "\n"
                        echo " This screen will exit when the video player is closed."
                        echo

                        # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
                        getfilenameonly=$(echo "$playnumber" |  awk -F '/' '{print $NF}')  

                        notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"      

                        echo "$playnumber" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
                        ffplay -fs -autoexit "$playnumber" 2>/dev/null  # play video
                        rm ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null

                    fi
                else
                    echo
                    echo
                    echo " Select Show All or use Find to acess this feature . . ."
                    sleep 1.7
                fi
            ;;
            n)
                ##################################################################################################################################################
                ###########################   (@NAVIGATE TREE)  n  ###############################################################################################
                ##################################################################################################################################################

                pasteclip2=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content   save to restore on option quit
                echo "" | xclip -sel clip  # clearing the clipboard
                navtree() {
                    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                    if [[ ! -d "$pasteclip" ]]; then
                        echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
                        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
                    fi
                    clear

                    # recursive list of directories for the user: enter line number to change to that directory
                    ####find "$PWD" -type d -iname "*" | sort -u 2>/dev/null

                    find "$PWD" -type d -iname "*" | sort -u > ${tmp_dir}/nt-list.tmp 2>/dev/null
                    # NUMBER THE LIST
                    sed '/./='  ${tmp_dir}/nt-list.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/nt-list-number.tmp 2>/dev/null

                    cat ${tmp_dir}/nt-list-number.tmp
                    # recursive number of directories found
                    ttotal=$(find  "$PWD" -type d -iname "*" 2>/dev/null | wc -l)   

                    notify-send "Videoinfox is done processing: Directory Tree" "Total Directories Found: "$ttotal" " # GUI Notification.

                    # recursive number of files found
                    ttotalnum=$(find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) 2>/dev/null | wc -l)
                    ##################################################################################
                    ##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
                    ################################################################################## 

                    # DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

                    # DEFAULT DIR NUMBER 1 FORMAT
                    dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
                    # DEFAULT DIR NUMBER 2 FORMAT
                    dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
                    # DEFAULT DIR NUMBER 3 FORMAT
                    dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
                    # DEFAULT DIR NUMBER 4 FORMAT
                    dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
                    # DEFAULT DIR NUMBER 5 FORMAT
                    dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
                    # NO MATCH ALL LESS BOLD
                    dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
                    # FORMAT PWD NAME FOR COMPARISON
                    echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
                    cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
                    rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

                    # FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
                    echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
                    cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
                    rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

                    # FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
                    echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
                    cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
                    rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

                    # FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
                    echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
                    cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
                    rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

                    # FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
                    echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
                    cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
                    rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

                    # FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
                    echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
                    cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
                    rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
                    sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
                    # LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

                    read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
                    read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
                    read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
                    read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
                    read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
                    read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
                    # DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

                    if [[ "$controldir" = "$dir5display" ]]; then 

                        if [[ "$dir5display" = "$dir1display" ]]; then
                                dirdisp="$dirdisplay1"
                        fi

                        if [[ "$dir5display" = "$dir2display" ]]; then
                                dirdisp="$dirdisplay2"
                        fi

                        if [[ "$dir5display" = "$dir3display" ]]; then
                                dirdisp="$dirdisplay3"
                        fi

                        if [[ "$dir5display" = "$dir4display" ]]; then
                                dirdisp="$dirdisplay4"
                        fi
                    fi

                    # DEFAULT DIR 5 DISPLAY
                    if [[ "$controldir" = "$dir5display" ]]; then
                        dirdisp="$dirdisplay5"  # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
                            
                    else
                        dirdisp="$dirdisplayno" # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
                    fi 

                    # DEFAULT DIR 1  DISPLAY
                    if [[ "$controldir" = "$dir1display" ]]; then 
                        dirdisp="$dirdisplay1"
                    fi

                    # DEFAULT DIR 2  DISPLAY
                    if [[ "$controldir" = "$dir2display" ]]; then 
                        dirdisp="$dirdisplay2"
                    fi

                    # DEFAULT DIR 3  DISPLAY
                    if [[ "$controldir" = "$dir3display" ]]; then 
                        dirdisp="$dirdisplay3"
                    fi

                    # DEFAULT DIR 4  DISPLAY
                    if [[ "$controldir" = "$dir4display" ]]; then 
                        dirdisp="$dirdisplay4"  # if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
                    fi

                    ################################################################################
                    ##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
                    ################################################################################
                    ########## blinking routines for display ##########

                    # not blinking Play Directory
                    playdir1=$(echo "Play Directory")
                    # blinking Play Directory
                    playdir2=$(echo -e "\033[5mPlay Directory\033m\033[0m\033[5m\033[5m\033[0m")

                    # not blinking dash
                    dash0=$(echo "-")
                    # blinking dash
                    dash1=$(echo "~")
                    # get file count of videos one directory deep for blinking   Play Directory
                    blinkit=$(find_supported_files --count)

                    # if find results are zero goto then
                    if [[ "$blinkit" = 0 ]]; then
                        blinkit2="$playdir1"  # zero files. non bliking  Playdirectory
                        bdash="$dash0"
                    else
                        blinkit2="$playdir2" # not zero files. blinking  Play Directory
                        bdash="$dash1"
                    fi
                    # not blinking
                    changedir1=$(echo "Change Directory")
                    # blinking
                    changedir2=$(echo -e "\033[5mChange Directory\033m\033[0m\033[5m\033[5m\033[0m")

                    # if directory exists goto then
                    if [[ -d "$pasteclip" ]]; then
                        changedir3="$changedir2"  # if the directory exists, blinking  Change Directory
                    else
                        changedir3="$changedir1"  # if the directory doesn't exist, non blinking  Change Directory
                    fi
                    ########## end blinking routines ################## 
                    echo
                    echo "Treetop:" "$grabdirfornav2"
                    echo "Total Directories: "$ttotal" "
                    echo "Total Video Files:" "$ttotalnum"                                                                                                            
                    echo
                    echo "Current Directory:" "$PWD"
                    echo "Video Files:" "$blinkit"
                    # echo
                    # echo "Clipboard:" "$pasteclip"
                    echo "___________________________________________________________________________________________________________________"
                    echo  
                    echo " ""$der"" >>> NAVIGATE TREE                                                     "$dirdisp" - Default Dirs"
                    echo "___________________________________________________________________________________________________________________" 
                    echo
                    #echo " c - "$changedir3"     a "$bdash" Show All     d "$bdash" Play Directory     n - Change Treetop                     q - Quit"
                    echo " c - Change Directory     a "$bdash" Show All     d "$bdash" Play Directory     n - Change Treetop                      q - Quit"
                    echo " u - Up One Level"
                    echo " t - Treetop"
                    echo   
                    echo -en " Enter Option: "
                    read -r -n1 option
                    echo
                }
  
                while true; do
                    navtree
                    case $option in
                        q)  # QUIT
                            ##############################     cd "$grabdirfornav2" &>/dev/null   # restore directory
                            echo "" | xclip -sel clip  # clearing the clipboard
                            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
                            break
                        ;;
                        1)  # CD DIRECTORY TO TV    
                            grabdirfornav2="$dir1"
                            cd "$dir1"
                        ;;
                        2)  # CD DIRECTORY TO MOVIES
                            grabdirfornav2="$dir2"
                            cd "$dir2" 
                        ;;
                        3)  # CHANGE DIRECTORY TO DOWNLOADS
                            grabdirfornav2="$dirsaved"
                            cd "$dirsaved" 
                        ;;
                        4)  # CHANGE DIRECTORY TO EXTRA   
                            grabdirfornav2="$dir4"
                            cd "$dir4" 
                        ;;
                        5)  # CHANGE DIRECTORY TO LAST EXIT
                            grabdirfornav2="$dir5"
                            cd "$dir5" 
                        ;;
                        u)  # UP ONE LEVEL 
                            if [[ "$grabdirfornav2" = "$PWD" ]]; then
                                echo
                                echo " At treetop. Can't go any higher . . ."
                                sleep .50
                            else
                                cd .. &>/dev/null
                            fi 
                        ;;
                        t)  # TREE TOP
                            cd "$grabdirfornav2" &>/dev/null
                        ;;
                        c)  # CHANGE DIRECTORY
                            # GETTING LINECOUNT
                            linecount=$(wc -l ${tmp_dir}/nt-list.tmp | cut -d' ' -f1)

                            echo
                            read -r -p " Enter line number to change directory: " linenumber  # waiting fot user input
                            if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                                :
                            else  # ENTRY IS A NUMBER
                                if [[ $linenumber -gt $linecount ]]; then 
                                    echo
                                    echo " Number out of range . . ."
                                    sleep .9
                                else
                                    tail -n +"$linenumber" ${tmp_dir}/nt-list.tmp > ${tmp_dir}/nt-list.tmp2 2>/dev/null
                                    OLDIFS=$IFS
                                    IFS=$'\n'
                                    read line < ${tmp_dir}/nt-list.tmp2
                                    cd "$line" 2> /dev/null
                                    IFS=$OLDIFS
                                fi
                            fi
                        ;;
                        d)
                            ####################################################################################################################################
                            # (@PLAY DIRECTORY) NAVIGATE TREE  #################################################################################################
                            ####################################################################################################################################

                            # WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
                            find_supported_files "${tmp_dir}/videoinfox.navtree-play-directory-apa"

                            #  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
                            atleastone=$(grep '^/' ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null | wc -l)

                            #  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYED LIST
                            if [[ $atleastone -ne 0 ]]; then
                                #  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
                                moddedplayedlist="${HOME}/.config/videoinfox/tmp/videoinfox.navtree-play-directory-apa"

                                #  PLAYED LIST INPUT FOR LOOP
                                input="$moddedplayedlist"  

                                #  CREATE TEMP FILE NEEDED FOR LOOP 
                                touch "${tmp_dir}/videoinfox.navtree-play-directory-apa2"

                                #  #  START WRITING
                                while read -r line; do
                                    if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
                                        echo "$line" >> "${tmp_dir}/videoinfox.navtree-play-directory-apa2"
                                    fi
                                done < "${moddedplayedlist}"
                                #  DONE WRITING ONLY VALID FILES

                                #  REMOVE BLANK LINES
                                squash "${tmp_dir}/videoinfox.navtree-play-directory-apa2" 2>/dev/null

                                #  MOVE apa2 BACK TO apa
                                mv "${tmp_dir}/videoinfox.navtree-play-directory-apa2" "${tmp_dir}/videoinfox.navtree-play-directory-apa" 2>/dev/null

                                #  CREATE FILE NEEDED FOR LOOP 
                                touch "${tmp_dir}/videoinfox.navtree-play-directory-apa2"

                                #  WRITE FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
                                write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfox.navtree-play-directory-apa2"

                                #  REMOVE BLANK LINES
                                squash "${tmp_dir}/videoinfox.navtree-play-directory-apa2" 2>/dev/null

                                #  MOVE apa2 BACK TO apa
                                cp ${tmp_dir}/videoinfox.navtree-play-directory-apa2 ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

                                # REMOVE PATH ONLY LEAVING FILENAME
                                sed -i 's/.*\///' ${tmp_dir}/videoinfox.navtree-play-directory-apa2

                                # NUMBER THE LIST
                                sed '/./='  ${tmp_dir}/videoinfox.navtree-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null

                            
                            else #  NO LINES START WITH A SLASH /   remove empty files
                                rm ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null
                                rm ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null
                                rm ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
                                rm ${tmp_dir}/videoinfox.navtree-play-directory-apa-work 2>/dev/null    
                            fi
                            ################clear

                            if [[ -f ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list ]]; then
                                cat ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
                            else
                                echo
                                echo " No video files in the current directory . . ."
                                sleep 1.7
                            fi
                            linenumber=1

                            tail -n +"$linenumber" ${tmp_dir}/videoinfox.navtree-play-directory-apa > ${tmp_dir}/videoinfox.navtree-play-directory-apa.tmp 2>/dev/null
                            mv ${tmp_dir}/videoinfox.navtree-play-directory-apa.tmp ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

                            OLDIFS=$IFS
                            IFS=$'\n'

                            for line in $(cat "$input" 2>/dev/null); do
                                clear
                                echo
                                echo "___________________________________________________________________________________________________________________"
                                echo
                                echo " ""$der"" >>> NAVIGATE TREE >>> PLAY DIRECTORY" 
                                echo
                                echo " [PLAY]>" "$line"
                                echo "___________________________________________________________________________________________________________________"
                                echo

                                echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
                                
                                echo
                                echo
                                echo " Video Player Controls:"
                                echo                             
                                echo " - Fullscreen Toggle: f"
                                echo
                                echo " - Play/Pause Toggle: space bar"
                                echo
                                echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
                                echo
                                echo " - Quit: q"      
                                echo -e "\n"

                                ffplay -fs -autoexit "$line" 2> /dev/null

                                echo " To bypass the 3 second wait press enter with no entry"
                                echo
                                echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
                                echo 
                                read -t 3 -p " Press any key then press enter to quit : " playdir
                                    
                                    # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
                                    if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                                            break                                                   # if enter is pressed without any input the next video will play
                                    fi
                            done
                            
                            IFS=$OLDIFS

                            rm ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null
                            rm ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null
                            rm ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
                            rm ${tmp_dir}/videoinfox.navtree-play-directory-apa-work 2>/dev/null 

                        ;;
                        n)
                            ####################################################################################################################################
                            # CHANGE TREETOP (NAVIGATE TREE)  ##################################################################################################
                            ####################################################################################################################################

                            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
                            clear
                            echo
                            echo "Directory: ""$PWD"
                            echo "Clipboard: ""$pasteclip"
                            echo "___________________________________________________________________________________________________________________"
                            echo
                            echo " $ver >>> CHANGE TREETOP"
                            echo "___________________________________________________________________________________________________________________"
                            echo
                            echo " No quotations needed for paths with spaces. Case sensative."
                            echo 
                            echo " Enter directory or paste directory if in clipboard."
                            echo
                            read -r -p " " specifydir  # waiting fot user input - the directory you want to chang to 
                                
                                if [[ -z "$specifydir" ]]; then
                                    echo " Nothing was entered . . ."
                                    sleep .75
                                else
                                    if [[ -d "$specifydir" ]]; then
                                        echo
                                        grabdirfornav2="$specifydir"
                                        cd "$specifydir"   # change the directory
                                        echo " Treetop changed to: $PWD"  # <pwd>  print current working directory to the screen
                                        sleep 1.5                   
                                    else
                                        echo
                                        echo " No such directory . . ."
                                        sleep 1.5                   
                                    fi
                                fi       
                            echo
                        ;;
         
         a)
            ####################################################################################################################################
            # SHOW ALL (NAVIGATE TREE)  ########################################################################################################
            ####################################################################################################################################

            #checking for videos in the current directory.  if no videos exist,   Play Directory   won't execute
            dovideosexist=$(find_supported_files --count)
            if [[ $dovideosexist -ne 0 ]]; then RUN PLAY LINE

                ntplaynum() {

                    # WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
                    find_supported_files > "${tmp_dir}/videoinfox.nt-play-directory-apa"

                    #  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
                    atleastone=$(grep -c '^/' ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null)

                    #  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYED LIST
                    if [[ $atleastone -ne 0 ]]; then

                        #  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
                        moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfox.nt-play-directory-apa"

                        #  PLAYED LIST INPUT FOR LOOP
                        input="$moddedplayedlist"  

                        #  CREATE TEMP FILE NEEDED FOR LOOP 
                        echo > ${tmp_dir}/videoinfox.nt-play-directory-apa2

                        #  #  START WRITING
                        while read -r line; do
                            if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
                                    echo "$line" >> ${tmp_dir}/videoinfox.nt-play-directory-apa2  
                            fi        
                        done < "$input"
                        #  DONE WRITING ONLY VALID FILES

                        #  REMOVE BLANK LINES
                        squash ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null

                        #  MOVE apa2 BACK TO apa
                        mv ${tmp_dir}/videoinfox.nt-play-directory-apa2 ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                        #  CREATE FILE NEEDED FOR LOOP 
                        echo > ${tmp_dir}/videoinfox.nt-play-directory-apa2  

                        #  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
                        write_supported_list "${moddedplaylist}" "${tmp_dir}/videoinfox.nt-play-directory-apa2"

                        #  REMOVE BLANK LINES
                        squash ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null

                        #  MOVE apa2 BACK TO apa
                        cp ${tmp_dir}/videoinfox.nt-play-directory-apa2 ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                        # REMOVE PATH ONLY LEAVING FILENAME
                        sed -i 's/.*\///' ${tmp_dir}/videoinfox.nt-play-directory-apa2

                        # NUMBER THE LIST
                        sed '/./='  ${tmp_dir}/videoinfox.nt-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null

        
                    else #  NO LINES START WITH A SLASH /   remove empty files
                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null
                        rm ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa-work 2>/dev/null
                    fi
                    clear

                    if [[ -f ${tmp_dir}/videoinfox.numbered-nt-play-directory-list ]]; then
                        cat ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
                    else
                        echo
                        echo " No video files in the current directory . . ."
                    fi

                    echo
                    echo "Directory: ""$PWD"
                    echo "___________________________________________________________________________________________________________________"
                    echo  
                    echo " $der >>> NAVIGATE TREE >>> SHOW ALL"
                    echo "___________________________________________________________________________________________________________________" 
                    echo
                    echo " o - Autoplay Line     s - View Playlist                                                                  q - Quit"
                    echo " j - Play Line         k - Playlist Add"
                    echo " i - Info              z - Directory To Playlist"
                    echo
                    echo -en " Enter Option: "
                    read -r -n1 optionaplist
                }

                while true; do
                    ntplaynum
                    case $optionaplist in
                        q) # QUIT
                            rm ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
                            rm ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null
                            rm ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
                            rm ${tmp_dir}/videoinfox.nt-play-directory-apa-work 2>/dev/null 
                            break
                        ;;
                        z) # DIRECTORY TO PAYLIST

                            echo
                            echo
                            echo " If any dots are entered, they will be stripped from the playlist name."
                            echo " If a space is used as the first character, it will be stripped from the playlist name."
                            echo " Spaces can be used after the first character of the playlist name."
                            echo
                            read -r -p " Create Playlist: " createpl1  # waiting fot user input. grabbing new filename

                            # Strip out any dots from user entry
                            echo "$createpl1" > ${tmp_dir}/plremovedot.tmp
                            sed -i -e 's/\.//g' ${tmp_dir}/plremovedot.tmp
                            read createpl < ${tmp_dir}/plremovedot.tmp
                            rm ${tmp_dir}/plremovedot.tmp

                            if [[ -z "$createpl" ]]; then
                                echo
                                echo " Nothing was entered . . ."
                                sleep .75
                            else
                                if [[ -f ${base_dir}/playlists/vplaylist."$createpl" ]]; then
                                        echo
                                        echo " File already exists . . ."
                                        sleep .75
                                else

                                    plname="$HOME/.config/videoinfox/playlists/vplaylist.""$createpl"  # add user input as file extension

                                    # WRITE DIRECTORY TO ENTERED PLAYLIST
                                    cat ${tmp_dir}/videoinfox.nt-play-directory-apa > "$plname"

                                    echo > "$HOME"/.config/videoinfox/playlists/"$createpl1".last-autoplay

                                    echo
                                    echo " Playlist Created: "$plname""
                                    echo
                                    sleep 1.7

                                fi
                            fi
                        ;; 
                        i)  # INFO - <HOME>
                    
                            if [[ -f "$pasteclip" ]]; then
                                pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
                                echo
                                echo
                                echo " ""$pasteclip"
                                echo  

                                echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

                                echo
                                read -r -p " Press enter to Continue" 

                            else

                                if [[ -f ${tmp_dir}/videoinfox.nt-play-directory-apa ]]; then
                                echo
                                echo
                                read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

                                # create file moving selected line number to the top
                                tail -n +"$linenumber" ${tmp_dir}/videoinfox.nt-play-directory-apa > ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp 2>/dev/null
                                mv ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
                                # read first line of file for play
                                read playnumber < ${tmp_dir}/videoinfox.nt-play-directory-apa

                                    if [[ ! -z "$playnumber" ]]; then
                                        echo
                                        echo "$playnumber"
                                        echo
            
                                        echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$playnumber")  " Duration:" $(ffmpeg -i "$playnumber" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height & duration

                                        echo
                                        read -r -p " Press enter to Continue" 
                                        ######rm ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null

                                    fi

                                else
                                    echo
                                    echo
                                    echo " Select Show All or use Find to acess this feature . . ."
                                    sleep 1.7
                                    fi

                             fi

                        ;;
                        j)
                            ###########################################################################################################################
                            # PLAY LINE - SHOW ALL (NAVIGATE TREE)  ###################################################################################
                            ###########################################################################################################################

                            #checking for videos in the current directory.  if no videos exist,   Play Directory   won't execute
                            dovideosexist=$(find_supported_files --count)
                            if [[ $dovideosexist -ne 0 ]]; then RUN PLAY LINE

                                # WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
                                find_supported_files > "${tmp_dir}/videoinfox.nt-play-directory-apa"

                                #  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
                                atleastone=$(grep '^/' ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null | wc -l)

                                #  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYED LIST
                                if [[ $atleastone -ne 0 ]]; then

                                    #  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
                                    moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfox.nt-play-directory-apa"

                                    #  PLAYED LIST INPUT FOR LOOP
                                    input="$moddedplayedlist"  

                                    #  CREATE TEMP FILE NEEDED FOR LOOP 
                                    echo > ${tmp_dir}/videoinfox.nt-play-directory-apa2

                                    #  #  START WRITING
                                    while read -r line; do
                                        if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
                                            echo "$line" >> ${tmp_dir}/videoinfox.nt-play-directory-apa2  
                                        fi
                                    done < "$input"
                                    #  DONE WRITING ONLY VALID FILES

                                    #  REMOVE BLANK LINES
                                    squash ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null

                                    #  MOVE apa2 BACK TO apa
                                    mv ${tmp_dir}/videoinfox.nt-play-directory-apa2 ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                                    #  CREATE FILE NEEDED FOR LOOP 
                                    touch "${tmp_dir}/videoinfox.nt-play-directory-apa2"

                                    #  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
                                    write_supported_list "${moddedplaylist}" "${tmp_dir}/videoinfox.nt-play-directory-apa2"

                                    #  REMOVE BLANK LINES
                                    squash ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null

                                    #  MOVE apa2 BACK TO apa
                                    cp ${tmp_dir}/videoinfox.nt-play-directory-apa2 ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                                    # REMOVE PATH ONLY LEAVING FILENAME
                                    sed -i 's/.*\///' ${tmp_dir}/videoinfox.nt-play-directory-apa2

                                    # NUMBER THE LIST
                                    sed '/./='  ${tmp_dir}/videoinfox.nt-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null

                                
                                else #  NO LINES START WITH A SLASH /   remove empty files
                                    rm ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
                                    rm ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null
                                    rm ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
                                    rm ${tmp_dir}/videoinfox.nt-play-directory-apa-work 2>/dev/null    
                                fi
                                # clear

                                if [[ ! -f ${tmp_dir}/videoinfox.numbered-nt-play-directory-list ]]; then
                                    echo
                                    echo " No videos in the current directory . . ."
                                fi
                                # GETTING LINECOUNT
                                linecount=$(wc -l ${tmp_dir}/videoinfox.nt-play-directory-apa | cut -d' ' -f1)

                                echo
                                echo
                                read -r -p " Play Line: " linenumber  # waiting fot user input
                                if [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                                    if [[ $linenumber -gt $linecount ]]; then 
                                        echo
                                        echo " Number out of range . . ."
                                        sleep .9
                                    else

                                        tail -n +"$linenumber" ${tmp_dir}/videoinfox.nt-play-directory-apa > ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp 2>/dev/null
                                        mv ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

                                        OLDIFS=$IFS
                                        IFS=$'\n'

                                        read line < ${tmp_dir}/videoinfox.nt-play-directory-apa

                                        clear
                                        echo
                                        echo "___________________________________________________________________________________________________________________"
                                        echo
                                        echo " ""$der"" >>> NAVIGATE TREE >>> PLAY LINE" 
                                        echo
                                        echo " [PLAY]>" "$line"
                                        echo "___________________________________________________________________________________________________________________"
                                        echo

                                        echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
                                        
                                        echo
                                        echo
                                        echo " Video Player Controls:"
                                        echo                             
                                        echo " - Fullscreen Toggle: f"
                                        echo
                                        echo " - Play/Pause Toggle: space bar"
                                        echo
                                        echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
                                        echo
                                        echo " - Quit: q"      
                                        echo -e "\n"

                                        echo "$line" >> ${base_dir}/videoinfo.playedlist  # write to the played list 
                                        ffplay -fs -autoexit "$line" 2> /dev/null
                                    
                                        IFS=$OLDIFS

                                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
                                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null
                                        rm ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
                                        rm ${tmp_dir}/videoinfox.nt-play-directory-apa-work 2>/dev/null 
                                    fi
                                fi
                                ######esac
                                ######done

                            else
                                echo
                                echo " No video files in the current directory . . ."
                                sleep 1.7

                            fi

                        ;;
 ########################################################################################################################################
         k)  # SHOW ALL - PLAYLIST ADD (NAVIGATE TREE)  ############################################################################################
 ########################################################################################################################################

#checking for videos in the current directory.  if no videos exist,   playlistaddnav Directory   won't execute
dovideosexist=$(find_supported_files --count)
if [[ $dovideosexist -ne 0 ]]; then  # IF VIDEOS EXIST IN THE CURRENT DIRECTORY 

########################################################################################################################function ntplaylistaddnavnum {

# WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-playlistaddnav-directory-apa 
find_supported_files > "${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa"

#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
atleastone=$(grep '^/' ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null | wc -l)

#  IF THE NUMBER DOESN"T = 0 
if [[ $atleastone -ne 0 ]]; then

#  ASSIGN playlistaddnavED LIST TO VARIABLE: $moddedplaylistaddnavedlist 
moddedplaylistaddnavedlist="$HOME""/.config/videoinfox/tmp/videoinfox.nt-playlistaddnav-directory-apa"

#  playlistaddnavED LIST INPUT FOR LOOP
input="$moddedplaylistaddnavedlist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2

#  #  START WRITING
while read -r line; do

   if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
           echo "$line" >> ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2  
   fi        

done < "$input"
#  DONE WRITING ONLY VALID FILES
#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplaylistaddnavedlist}" "${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2

# NUMBER THE LIST
sed '/./='  ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 |
    sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null
     rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list 2>/dev/null
     rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa-work 2>/dev/null    
fi
clear

if [[ -f ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list ]]; then
        cat ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list 2>/dev/null
   else
        echo
        echo " No videos in the current directory . . ."
fi
# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplnt.tmp 
read -r whatplnt < ${tmp_dir}/whatplnt.tmp
rm ${tmp_dir}/whatplnt.tmp

echo
read -r -p "Enter line number to add video to playlist $whatplnt: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa > ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa.tmp 2>/dev/null

#####
# GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
linecount=$(wc -l ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa | cut -d' ' -f1)
#####

mv ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa.tmp ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null

if [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo "Number out of range . . ."
                  sleep .9

              else

OLDIFS=$IFS
IFS=$'\n'

read line < ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa

if [[ -z "$linenumber" ]]; then
              :

          else
              echo "$line" >> ${base_dir}/videoinfo.playlist
              echo
              echo " ""$line" 
              echo
              echo " Added to Playlist . . ."
              sleep .25
      fi

fi
fi
fi
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa 2>/dev/null
rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa2 2>/dev/null
rm ${tmp_dir}/videoinfox.numbered-nt-playlistaddnav-directory-list 2>/dev/null
rm ${tmp_dir}/videoinfox.nt-playlistaddnav-directory-apa-work 2>/dev/null 
          
else
    echo
    echo " No video files in the current directory . . ."
    sleep 1.7

fi

;;
##################################################################################################################################################
s) #######################  @PLAYLIST - SHOW ALL (NAVIGATE TREE)  ################################################################################
##################################################################################################################################################

grabdir="$PWD"  # SAVE CURRENT DIRECTORY FOR RESTORE ON EXIT

cd ${base_dir}/playlists
function menuvhome {

squash ${base_dir}/videoinfo.playlist  # remove all blank lines

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$grabclip" = "http" ]]; then
      :

  else      
      if [[ -f "$pasteclip" ]]; then
            :
        else
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      # REMOVE DUPLICATES
      cat -n ${base_dir}/videoinfo.playlist | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist.tmp
      mv ${tmp_dir}/videoinfo.playlist.tmp ${base_dir}/videoinfo.playlist

  else
      echo > ${base_dir}/videoinfo.playlist
fi

                
clear

cp ${base_dir}/videoinfo.playlist ${tmp_dir}/videoinfo.playlist-apa
#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
atleastone=$(grep '^/' ${tmp_dir}/videoinfo.playlist-apa | wc -l)

#  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYLIST
if [[ $atleastone -ne 0 ]]; then

#  ASSIGN PLAYLIST TO VARIABLE: $moddedplaylist 
moddedplaylist="$HOME""/.config/videoinfox/tmp/videoinfo.playlist-apa"

#  PLAYLIST INPUT FOR LOOP
input="$moddedplaylist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfo.playlist-apa2

#  #  START WRITING
while read -r line; do
   if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
           echo "$line" >> ${tmp_dir}/videoinfo.playlist-apa2  
   fi
done < "$input"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

# REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist-apa3

mv ${tmp_dir}/videoinfo.playlist-apa3 ${tmp_dir}/videoinfo.playlist-apa2

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfo.playlist-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplaylist}" "${tmp_dir}/videoinfox.playlist-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfo.playlist-apa2

# NUMBER THE LIST
sed '/./=' ${tmp_dir}/videoinfo.playlist-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
     rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null     
fi
clear
if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then
        cat ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        #dashit=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
        dashit=$(echo "~") #
   else
        dashit=$(echo "-") # 
        echo
        echo "Playlist Empty . . ."
fi

#cat ${base_dir}/videoinfo.playlist 

# check if directory ${base_dir}/playlists is empty.  if it is, set playlist to Default 
searchtotal=$(find "$PWD" -type f \( -iname "vplaylist.*" \) 2>/dev/null | wc -l)

if [[ "$searchtotal" = 0 ]]; then
      echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current             
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      read -r setplaylist < ${tmp_dir}/plread.tmp
      rm ${tmp_dir}/plread.tmp
      # GET CURRENT PLAYLIST
      read -r activeplaylist < ${base_dir}/videoinfo.playlist.current
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      # SAVE CURRENT PLAYLIST
      cp ${base_dir}/videoinfo.playlist "$activeplaylist"
     
  else
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      read -r setplaylist < ${tmp_dir}/plread.tmp

      rm ${tmp_dir}/plread.tmp
fi
##################################################################################################################################################

#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

#echo "Directory: ""$PWD"

if [[ "$grabpaste" = "http" ]]; then
      echo
      echo "Clipboard: ""$pasteclip"
  else
      :
fi
if [[ "$grabpaste" = "http" ]]; then
    read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
    ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

    if [[ "$ytdlpconfirm" = "" ]]; then

        echo "" | xclip -sel clip  # clearing out the clipboard
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

        # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
        #________________x________________________________________ _________________________________________________________
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " o "$dashit" Autoplay Line     l - Last Autoplay      c - Change Playlist     p - Play Clipboard                  q - Quit"
        echo " j "$dashit" Play Line"
        echo " i "$dashit" Info                                     d - Clear Playlist"
        echo           

    else 
        echo
        echo "YT-DLP Confirmed: "$ytdlpconfirm""
        echo
        echo "Download Directory: $dirsaved"  # dislpay default download directory
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
        echo " j "$dashit" Play Line"
        echo " i "$dashit" Info                                    d - Clear Playlist"
        echo                                                                                    
    fi
  else

    if [[ -f "$pasteclip" ]]; then
        echo      
        echo "Valid file in clipboard"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
        echo " j "$dashit" Play Line"
        echo " i "$dashit" Info                                    d - Clear Playlist"
        echo                                                                     

    else 

        echo "" | xclip -sel clip  # clearing out the clipboard
        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

        echo "___________________________________________________________________________________________________________________"
        echo
        echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
        echo "___________________________________________________________________________________________________________________"
        echo
        echo " j - Play Line     o - Start Autoplay      c - Change Playlist     p - Play Clipboard                     q - Quit"
        echo " i - Info          l - Resume Autoplay     r - Remove Line"
        echo "                                           d - Clear Playlist                                             h - Help"
        echo                                                             
    fi
fi

echo -en " Enter Option: "
read -r -n1 optionv
}

        while true
        do
        menuvhome
        case $optionv in
    
        q)  # QUIT
        rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
        rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
        rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        cd "$grabdir"
        break;;

       
        h)
        echo
        echo
        echo " PLAYLIST LIST >>> HELP"        
        echo
        echo " Everytime Start Autoplay is used, it will write a new file for Resume Autoplay."
        echo " Run Start Autoplay first. Then use Resume Autoplay to continue watching where you left off."
        echo " Resume Autoplay will start with the last video that was playing when the play loop was quit."
        echo
        echo " Note: If the playlist is changed with Playlist Add or Remove Line after running Start Autoplay,"
        echo "       Resume Autoplay won't get updated with the changes until Start Autoplay is run again."
        echo
        read -p " Press enter to Continue"
        ;;
        o) # AUTOPLAY LINE  (HOME >>> PLAYLIST)

# SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Start Autoplay from line: " linenumber  # waiting fot user input

# 
tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      # COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done

# WRITE 2nd PLAYLIST FOR LAST AUTOPLAY OPTION . File: ${base_dir}/playlists/$playlistname.last-autoplay
tail -n +"$i" ${tmp_dir}/videoinfo.playlist-apa > "$setplaylist".last-autoplay

IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;

########################################
r)  # REMOVE LINE  (HOME >>> PLAYLIST)
########################################

# delete a line example to remove by pattern
#sed '\?^/mnt/MEDIA1/MOVIES/identity thief.mp4?d' videoinfo.playlist
# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplpld.tmp 
read -r whatplpld < ${tmp_dir}/whatplpld.tmp
rm ${tmp_dir}/whatplpld.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      :
  else
      echo > ${base_dir}/videoinfo.playlist
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then

      clear
      cat ${tmp_dir}/videoinfo.number.play-list 2> /dev/null

      echo
      read -r -p "Enter line number to remove video from the playlist $whatplpld: " linenumber  # waiting fot user input

      # REMOVE BLANK LINES
      ######squash ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

      # GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
      linecount=$(wc -l ${tmp_dir}/videoinfo.playlist-apa 2> /dev/null | cut -d' ' -f1) # 

          if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                :

            else  # ENTRY IS A NUMBER

                if [[ -z "$linenumber" ]]; then
                      :

                  else

                      if [[ "$linenumber" = 0 ]]; then
                            :

                        else
      
                            if [[ $linenumber -gt $linecount ]]; then 
                                  echo
                                  echo "Number out of range . . ."
                                  sleep .9

                              else

                                  if [[ -z "$linenumber" ]]; then
                                        :

                                    else
                                        # DELETE LINE NUMBER
                                        sed -i "${linenumber}d" ${base_dir}/videoinfo.playlist 2> /dev/null 
                                        echo
                                        echo "Line deleted from the playlist . . ."
                                        sleep .25
                                  fi
                            fi
                      fi
               fi
         fi
fi

;;
###########################################################
l) # LAST AUTOPLAY - RESUME AUOTOPLAY (HOME >>> PLAYLIST)
###########################################################

# READ FIRST LINE TO DISPLAY VIDEO NAME BEFORE PLAY
read < $HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay resumedisplay
echo
echo
echo " Resume: ""$resumedisplay"
sleep 3

###### SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

OLDIFS=$IFS
IFS=$'\n'

input2=$HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay
for line in $(cat "$input2" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      ###### COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING FOR WRITE ON EXIT.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
tail -n +"$i" ${base_dir}/playlists/"$setplaylist".last-autoplay > ${base_dir}/playlists/pl-tmp
mv ${base_dir}/playlists/pl-tmp ${base_dir}/playlists/"$setplaylist".last-autoplay
IFS=$OLDIFS

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
        j) # PLAY LINE  (HOME >>> PLAYLIST)

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Play Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

read line < ${tmp_dir}/videoinfo.playlist-apa

if [[ -z "$line" ]

  then
      :

  else

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> PLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      echo " Screen will close after video player is quit."

      ffplay -fs -autoexit "$line" 2> /dev/null
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

fi

else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
       i)  # INFO - <PLAYLIST>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo.playlist-apa ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo.playlist-apa.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$playnumber")  " Duration:" $(ffmpeg -i "$playnumber" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height & duration

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null

                 fi

        else
            :

            fi

      fi

;;       

########################################################################################################################################################
          c)
          # CHANGE PLAYLIST
########################################################################################################################################################

function changepl {

#read -r savepl < ${base_dir}/videoinfo.playlist.current
#cp ${base_dir}/videoinfo.playlist "$savepl"

# cd ${base_dir}/playlists

# FIND PLAYLISTS
find "$PWD" -type f \( -iname "vplaylist.*" \) > ${base_dir}/videoinfo.playlist.dirlist

# SORT BACK INTO ORDER
sort -u ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist 

#  REMOVE BLANK LINES
sed '/^$/d' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist

# REMOVE PATH
sed 's/.*\///' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp

# REMOVE FILENAME AND LEAVE EXTENSION
cat ${tmp_dir}/playlist.dirlist.tmp | sed 's/.*\.//' > ${tmp_dir}/playlist.dirlist.tmp2 
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp
# CREATE NUMBERED lIST
sed '/./=' ${tmp_dir}/playlist.dirlist.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/playlist.dirlist.tmp2
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp 
clear
cat ${tmp_dir}/playlist.dirlist.tmp
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$der"" >>> CHANGE PLAYLIST >>>" "$setplaylist"        
echo "___________________________________________________________________________________________________________________"
echo
echo " c - Change Playlist     a - Create Playlist     d - Delete Playlist                                      q - Quit"
echo 
echo -en " Enter Option: "
read -r -n1 optioncpl
echo
}
while true; do
changepl
case $optioncpl in
        q)  # QUIT
        ###cd "$grabdir"
        break ;;

    
        c)  # CHANGE PLAYLIST

# GET CURRENT PLAYLIST
read -r activeplaylistm < ${base_dir}/videoinfo.playlist.current

# SAVE CURRENT PLAYLIST
cp ${base_dir}/videoinfo.playlist "$activeplaylistm" 2>/dev/null

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# LOAD A PLAYLIST
echo
read -r -p " Enter line number: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
if [[ -z "$linenumber" ]]; then
      :

  else
      if [[ $linenumber -gt $linecount ]]

        then 
            echo
            echo " Number out of range . . ."
            sleep .9

        else

            # CREATE FILE MOVING SELECTION TO THE TOP
            tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp3

            # READ FIRST LINE OF FILE
            read plselected < ${tmp_dir}/playlist.dirlist.tmp3

            # WRITE SELECTED PLAYLIST
            echo "$plselected" > ${base_dir}/videoinfo.playlist.current

            # LOAD SELECTED PLAY LIST
            cp "$plselected" ${base_dir}/videoinfo.playlist 2>/dev/null
    
   fi
      fi

fi
break

;;
         d)  # DELETE PLAYLIST

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# SELECT A PLAYLIST TO DELETE
echo
read -r -p " Enter line number to delete: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo " Number out of range . . ."
                  sleep .9

              else
                  echo
                      # CREATE FILE MOVING SELECTION TO THE TOP
                      tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.playlist.delete.tmp

                      # READ FIRST LINE OF FILE
                      read plselected < ${tmp_dir}/playlist.playlist.delete.tmp

                      function menucpl {
                  
                      clear
                      echo
                      echo
                      echo " Delete Playlist . . ."
                      echo
                      echo " $plselected"
                      echo
                      echo " y - Yes     n - No"  
                      echo 
                      echo -en " Enter Option: "
                      read -r -n1 optioncpl
                      echo
                      }

                      while true
                      do
                    menucpl
                    case $optioncpl in

                    y)  # YES

                      rm "$plselected" 2> /dev/null

                      echo "$plselected"| sed 's/.*\.//' > ${tmp_dir}/plread.tmp  # REMOVE FULL PATH ONLY LEAVING PLAYLIST NAME
                      read -r plselectedla < ${tmp_dir}/plread.tmp  # READING PLAYLIST NAME ONLY INTO VARIABLE  $pselecteda
                      rm ${tmp_dir}/plread.tmp  # remove temp file
                      rm ${base_dir}/playlists/"$plselectedla".last-autoplay  # REMOVE PLAYLIST.last.autoplay  file
 
                      echo
                      echo  " Playlist Deleted . . ."

                      if [[ "$setplaylistfull" = "$plselected" ]]; then # SET DEFAULT PLAYLIST TO ACTIVE PLAYLIST
                            echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current
                            cp ${base_dir}/playlists/vplaylist.Default ${base_dir}/videoinfo.playlist 2> /dev/null
                            setplaylist="Default"
                        else
                            :
                      fi

                      sleep 1.7  
                      break
                      ;;
                      n)  # NO
                      break;;

                      *)
        
                      esac
                      done
        
            fi
      fi
fi
            
;;        
         a)
         # CREATE PLAYLIST
echo
echo " If any dots are entered, they will be stripped from the playlist name."
echo " If a space is used as the first character, it will be stripped from the playlist name."
echo " Spaces can be used after the first character of the playlist name."
echo
read -r -p " Create Playlist: " createpl1  # waiting fot user input. grabbing new filename

# Strip out any dots from user entry
echo "$createpl1" > ${tmp_dir}/plremovedot.tmp
sed -i -e 's/\.//g' ${tmp_dir}/plremovedot.tmp
read createpl < ${tmp_dir}/plremovedot.tmp
rm ${tmp_dir}/plremovedot.tmp

if [[ -z "$createpl" ]]; then
      echo
      echo " Nothing was entered . . ."
      sleep .75

  else

      if [[ -f ${base_dir}/playlists/vplaylist."$createpl" ]]; then
            echo
            echo " File already exists . . ."
            sleep .75

        else

plname="$HOME/.config/videoinfox/playlists/vplaylist.""$createpl"  # add user input as file extension
echo > "$plname"  #  create user list with full path and filename

echo > "$HOME"/.config/videoinfox/playlists/"$createpl1".last-autoplay

echo
echo " Playlist Created: "$plname""
echo
sleep 1.7

      fi
fi
;; 
esac
done
;;
          p) 
          #  @PLAY CLIPBOARD - <PLAYLIST>        

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdirz="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload  
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            echo > ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$ytdlplast")  " Duration:" $(ffmpeg -i "$ytdlplast" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
              :
          else     
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST File  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdirz"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      echo " PLAYLIST Closed"
  
        else
            
            echo
            echo
            echo " No playable content in the clipboard . . ."
            sleep 1.2
      fi   
  fi
  ;;  
         d)  # CLEAR PLAYLIST (VIEW PLAYLIST)

        function menucpl {
        
        clear
        echo
        echo
        echo " Clear current playlist: ""$setplaylist""?"
        echo
        echo " y - Yes     n - No"  
        echo 
        echo -en " Enter Option: "
        read -r -n1 optioncpl
        echo
        }

        while true
        do
      menucpl
      case $optioncpl in

      y)  # YES
        rm ${base_dir}/videoinfo.playlist 2> /dev/null
        echo > ${base_dir}/videoinfo.playlist
        echo > ${base_dir}/playlists/"$setplaylist".last-autoplay 
        echo
        echo " ""$setplaylist"" Playlist Cleared . . ."
        sleep 1.7  
        break
        ;;
        n)  # NO
        break;;

        *)
        
        esac
        done
        ;;
*)

esac
done
;;
o) # AUTOPLAY (NAVIGATE TREE)
echo
echo
read -r -p " Autoplay Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfox.nt-play-directory-apa > ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfox.nt-play-directory-apa.tmp ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> NAVIGATE TREE >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfox.nt-play-directory-apa 2>/dev/null
rm ${tmp_dir}/videoinfox.nt-play-directory-apa2 2>/dev/null
rm ${tmp_dir}/videoinfox.numbered-nt-play-directory-list 2>/dev/null
rm ${tmp_dir}/videoinfox.nt-play-directory-apa-work 2>/dev/null 
          
esac
done
else
    echo
    echo " No video files in the current directory . . ."
    sleep 1.7

fi
;;
esac
done
;;
##################################################################################################################################################
d)  # (@PLAY DIRECTORY) HOME   ###################################################################################################################
##################################################################################################################################################

# WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
find_supported_files > "${tmp_dir}/videoinfox.home-play-directory-apa"

#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
atleastone=$(grep '^/' ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null | wc -l)

#  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYED LIST
if [[ $atleastone -ne 0 ]]; then

#  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfox.home-play-directory-apa"

#  PLAYED LIST INPUT FOR LOOP
input="$moddedplayedlist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfox.home-play-directory-apa2

#  #  START WRITING
while read -r line; do

   if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
           echo "$line" >> ${tmp_dir}/videoinfox.home-play-directory-apa2  
      else
           :
   fi        

done < "$input"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.home-play-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfox.home-play-directory-apa2 ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfox.home-play-directory-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfox.home-play-directory-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.home-play-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfox.home-play-directory-apa2 ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfox.home-play-directory-apa2

# NUMBER THE LIST
sed '/./='  ${tmp_dir}/videoinfox.home-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-home-play-directory-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null
     rm ${tmp_dir}/videoinfox.home-play-directory-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfox.numbered-home-play-directory-list 2>/dev/null
     rm ${tmp_dir}/videoinfox.home-play-directory-apa-work 2>/dev/null    
fi
##################clear

if [[ -f ${tmp_dir}/videoinfox.numbered-home-play-directory-list ]]; then
        cat ${tmp_dir}/videoinfox.numbered-home-play-directory-list 2>/dev/null
   else
        echo
        echo
        echo " No video files in the current directory . . ."
        sleep 1.7
fi
linenumber=1

tail -n +"$linenumber" ${tmp_dir}/videoinfox.home-play-directory-apa > ${tmp_dir}/videoinfox.home-play-directory-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfox.home-play-directory-apa.tmp ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> HOME >>> PLAY DIRECTORY" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfox.home-play-directory-apa 2>/dev/null
rm ${tmp_dir}/videoinfox.home-play-directory-apa2 2>/dev/null
rm ${tmp_dir}/videoinfox.numbered-home-play-directory-list 2>/dev/null
rm ${tmp_dir}/videoinfox.home-play-directory-apa-work 2>/dev/null 

;;           
#####################################################################################################################################################
l)  # PLAY LAST DOWNLOAD >>> HOME    ################################################################################################################
#####################################################################################################################################################

              grabdir="$PWD"  # storing directory to restore at the end of this function
               
              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"   # change to download directory

                 if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
                        read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt         
                        ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))
                        echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file
                        read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file

                    else
                        read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download
                        ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownloadbak*" \))
                        echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file
                        read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                 fi   

          
              clear
              echo
              echo "___________________________________________________________________________________________________________________"
              echo
              echo " ""$der"" >>> PLAY LAST DOWNLOAD"
              echo
              echo " [PLAY]> ""$ytdlplast"""
              echo "___________________________________________________________________________________________________________________"         
              echo
              
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$ytdlplast")  " Duration:" $(ffmpeg -i "$ytdlplast" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

              echo
              echo " Video Player Controls:"
              echo                             
              echo " - Fullscreen Toggle: f"
              echo
              echo " - Play/Pause Toggle: space bar"
              echo
              echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
              echo
              echo " - Quit: q"      
              echo -e "\n"
              echo " This screen will exit when the video player is closed."
              echo
         
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
                       
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to file  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
              cd "$grabdir"   # restore dir prior to entering yt-dlp menu
              ;;  
a)  # SHOW ALL VIDEOS

searchtotal=$(find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) 2>/dev/null | wc -l)    
                                                                              
                     if [[ "$searchtotal" = 0 ]  # if find returned no results goto <then>
      
                       then
                           echo
                           echo
                           echo " No video files recursively reachable from the current directory . . ."
                           sleep 1
                           #cp ${base_dir}/videoinfo.findwork3 ${base_dir}/videoinfo.findwork
                           #cp ${base_dir}/videoinfo.lastsearchtotal2  ${base_dir}/videoinfo.lastsearchtotal
                        
                       else
                           echo "*" > ${base_dir}/videoinfo.lastfindstring   # save last find string used                          
                           read -r fterm < ${base_dir}/videoinfo.lastfindstring
                           # save find results
find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) | sort -u > ${base_dir}/videoinfo.findwork
                           echo "$PWD" > ${base_dir}/videoinfo.lastfinddir  # save last directory that last find was run in 
                           # write last search total file count
                           echo "$searchtotal" > ${base_dir}/videoinfo.lastsearchtotal
                           # read last search total file count
                           read -r searchtotal < ${base_dir}/videoinfo.lastsearchtotal    
                           cp ${base_dir}/videoinfo.findwork ${base_dir}/videoinfo.findwork3
                           cp ${base_dir}/videoinfo.lastsearchtotal ${base_dir}/videoinfo.lastsearchtotal2                 

                           notify-send  "Videoinfox messsage: Find results in $PWD" "$searchtotal files found using search term: $fterm"
                         
     fi
     ;;

     1)  # CD DIRECTORY TO TV    
     cd "$dir1" 
     ;;
    
     2)  # CD DIRECTORY TO MOVIES
     cd "$dir2" 
     ;;
     3)  # CHANGE DIRECTORY TO DOWNLOADS
     cd "$dirsaved" 
     ;;
     4)  # CHANGE DIRECTORY TO EXTRA   
     cd "$dir4" 
     ;;
     5)  # CHANGE DIRECTORY TO LAST EXIT
     cd "$dir5" 
     ;;
     c)  # CLEAR FIND RESULTS
     # CREATE FIND RESULT MESSAGE THAT THERE ARE NO STORED FINDS
     echo > ${base_dir}/videoinfo.lastsearchtotal
     echo > ${base_dir}/videoinfo.lastfindstring
     echo > ${base_dir}/videoinfo.lastfinddir

     rm ${tmp_dir}/videoinfo-number-findwork.tmp 2> /dev/null
     rm ${tmp_dir}/videoinfo-findwork.tmp 2> /dev/null

     echo > ${base_dir}/videoinfo.findwork
     
     ;;
     x) 
       #CLEAR CLIPBOARD - <HOME> 
       echo "" | xclip -sel clip  # copy message in quotes to the clipboard. clearing out the clipboard
       pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
       ;;

#############################################################################################################################################    
#############################################################################################################################################
     p) 
     #  @PLAY CLIPBOARD - <HOME> !!!!!    MASTER TEMPLATE  This is the one that gets the edits then copied to other places in the code.

#############################################################################################################################################
#############################################################################################################################################
     
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdir="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"    

      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            echo > ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$ytdlplast")  " Duration:" $(ffmpeg -i "$ytdlplast" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo

      if [[ -z "$ytdlplast" ]]; then
             :
         else     
             notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
             echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List File  
             ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdir"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
     
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
      # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      
      #notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"      

      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

      echo " Played List Closed"

         else
             echo
             echo
             echo " No playable content in the clipboard . . ."
             sleep 1.2

fi
fi
;;  
      i)  # INFO - <HOME>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo-findwork.tmp ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo-findwork-playnumber.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$playnumber")  " Duration:" $(ffmpeg -i "$playnumber" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height & duration

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null

                 fi

        else
            echo
            echo
            echo " Select Show All or use Find to acess this feature . . ."
            sleep 1.7
            fi

      fi

;;
##################################################################################################################################################
v)                                  ##############################################################################################################    
     #  VIEW/PLAYED LIST - <HOME>   ##############################################################################################################
     
function menuvv {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$grabclip" = "http" ]]; then
      :

  else      
      if [[ -f "$pasteclip" ]]; then
            :
        else
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi

########################### removed sort routine #########################

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content                  
clear

#  REMOVE PLAYED LIST HEADER AND WRITE NEW FILE FOR PROCESSING: ${tmp_dir}/videoinfo.playedlist-auto-play-all
#awk 'NR>5' ${base_dir}/videoinfo.playedlist > ${tmp_dir}/videoinfo.playedlist-apa

cp ${base_dir}/videoinfo.playedlist ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

#  REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playedlist-apa | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playedlist-apa3 2>/dev/null
mv ${tmp_dir}/videoinfo.playedlist-apa3 cat -n ${tmp_dir}/videoinfo.playedlist 2>/dev/null

#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
atleastone=$(grep '^/' ${tmp_dir}/videoinfo.playedlist-apa | wc -l)

#  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYED LIST
if [[ $atleastone -ne 0 ]]; then

#  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfo.playedlist-apa"

#  PLAYED LIST INPUT FOR LOOP
input="$moddedplayedlist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfo.playedlist-apa2

#  #  START WRITING
while read -r line; do

   if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
           echo "$line" >> ${tmp_dir}/videoinfo.playedlist-apa2  
      else
           :
   fi        

done < "$input"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
###############################################################################squash ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null

# REMOVE DUPLICATES
#############cat -n ${tmp_dir}/videoinfo.playedlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playedlist-apa3
####################################################mv ${tmp_dir}/videoinfo.playedlist-apa3 ${tmp_dir}/videoinfo.playedlist-apa2

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfo.playedlist-apa2 ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfo.playedlist-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfo.playedlist-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null

#  REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playedlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playedlist-apa3 2>/dev/null
mv ${tmp_dir}/videoinfo.playedlist-apa3 ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfo.playedlist-apa2 ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfo.playedlist-apa2

# NUMBER THE LIST
sed '/./=' ${tmp_dir}/videoinfo.playedlist-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo.number.played-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
     rm ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfo.number.played-list 2>/dev/null     
fi
clear
if [[ -f ${tmp_dir}/videoinfo.number.played-list ]]; then
        cat ${tmp_dir}/videoinfo.number.played-list 2>/dev/null
        dashit=$(echo -e "~")
   else
        dashit=$(echo "-") 
        echo
        echo "Played List Empty . . ."
fi

#cat ${base_dir}/videoinfo.playedlist 

if [[ "$grabpaste" = "http" ]]; then
      echo
      echo "Clipboard: ""$pasteclip"
  else
      :
fi

######echo
######echo "Directory: ""$PWD"
######echo "Clipboard: ""$pasteclip"

##################################################################################################################################################

#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

if [[ "$grabpaste" = "http" ]]; then
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
      ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

            if [[ "$ytdlpconfirm" = "" ]]; then

                      echo "" | xclip -sel clip  # clearing out the clipboard
                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                           # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
                           #________________x________________________________________ _________________________________________________________
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYED LIST"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " o "$dashit" Autoplay Line     s - View Playlist     D - Delete Played List     p - Play Clipboard                q - Quit"
                      echo " j "$dashit" Play Line         k "$dashit" Playlist Add"
                      echo " i "$dashit" Info"
                      echo   

                  else 
                      echo
                      echo "YT-DLP Confirmed: "$ytdlpconfirm""
                      echo
                      echo "Download Directory: $dirsaved"  # dislpay default download directory
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYED LIST"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo -e " o "$dashit" Autoplay Line     s - View Playlist     D - Delete Played List     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                q - Quit"                     
                      echo " j "$dashit" Play Line         k "$dashit" Playlist Add      "
                      echo " i "$dashit" Info"
                      echo                                                                                        
            fi
  else

      if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYED LIST"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo -e " o "$dashit" Autoplay Line     s - View Playlist     D - Delete Played List     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                q - Quit"                     
            echo " j "$dashit" Play Line         k "$dashit" Playlist Add      "
            echo " i "$dashit" Info"
            echo                                                            

        else 

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYED LIST"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " o "$dashit" Autoplay Line     s - View Playlist     D - Delete Played List     p - Play Clipboard                q - Quit"
            echo " j "$dashit" Play Line         k "$dashit" Playlist Add"
            echo " i "$dashit" Info"
            echo
fi
fi

echo -en " Enter Option: "
read -r -n1 optionv
}

        while true
        do
        menuvv
        case $optionv in
    
        q)  # QUIT
        rm ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
        rm ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null
        rm ${tmp_dir}/videoinfo.number.played-list 2>/dev/null
        break;;
        o) # AUTOPLAY LINE  (PLAYED LIST)

if [[ -f ${tmp_dir}/videoinfo.number.played-list ]]; then

echo
echo
read -r -p " Autoplay Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo.playedlist-apa > ${tmp_dir}/videoinfo.playedlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playedlist-apa.tmp ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYED LIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.played-list 2>/dev/null

   else
       echo
       echo
       echo " Played List Empty . . ."
       sleep 1.7
fi

;;
        j) # PLAY LINE  (PLAYED LIST)

# GETTING LINE COUNT
linecount=$(wc -l ${tmp_dir}/videoinfo.number.played-list | cut -d' ' -f1)

if [[ -f ${tmp_dir}/videoinfo.number.played-list ]]; then
       echo
       echo
       read -r -p " Play Line: " linenumber  # waiting fot user input

if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]

              then 
                  echo
                  echo " Number out of range . . ."
                  sleep .9

              else

       tail -n +"$linenumber" ${tmp_dir}/videoinfo.playedlist-apa > ${tmp_dir}/videoinfo.playedlist-apa.tmp 2>/dev/null
       mv ${tmp_dir}/videoinfo.playedlist-apa.tmp ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

       OLDIFS=$IFS
       IFS=$'\n'

       read line < ${tmp_dir}/videoinfo.playedlist-apa
fi
      fi
            fi

        if [[ -z "$line" ]

         then
             :

         else

             clear
             echo
             echo "___________________________________________________________________________________________________________________"
             echo
             echo " ""$der"" >>> PLAYED LIST >>> PLAY LINE" 
             echo
             echo " [PLAY]>" "$line"
             echo "___________________________________________________________________________________________________________________"
             echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
             echo
             echo
             echo " Video Player Controls:"
             echo                             
             echo " - Fullscreen Toggle: f"
             echo
             echo " - Play/Pause Toggle: space bar"
             echo
             echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
             echo
             echo " - Quit: q"      
             echo -e "\n"

             echo " Screen will close after video player is quit."

             ffplay -fs -autoexit "$line" 2> /dev/null
 
             IFS=$OLDIFS

             rm ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
             rm ${tmp_dir}/videoinfo.playedlist-apa2 2>/dev/null
             rm ${tmp_dir}/videoinfo.number.played-list 2>/dev/null

        fi
    else  # FILE IS EMPTY"
        echo
        echo
        echo " Played List Empty . . ."
        sleep 1.7
fi

;;
       i)  # INFO - <PLAYED LIST>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo.playedlist-apa ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo.playedlist-apa > ${tmp_dir}/videoinfo.playedlist-apa.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo.playedlist-apa.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$playnumber")  " Duration:" $(ffmpeg -i "$playnumber" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height & duration

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo.playedlist-apa.tmp 2>/dev/null

                 fi

        else
            echo
            echo
            echo " Play List Empty . . ."
            sleep 1.7            
            fi

      fi

;;       
#####################################################################################################################################
s) # @PLAYLIST PLAYED LIST
#####################################################################################################################################

grabdir="$PWD"  # SAVE CURRENT DIRECTORY FOR RESTORE ON EXIT

cd ${base_dir}/playlists
function menuvhome {

squash ${base_dir}/videoinfo.playlist  # remove all blank lines

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$grabclip" = "http" ]]; then
      :

  else      
      if [[ -f "$pasteclip" ]]; then
            :
        else
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      # REMOVE DUPLICATES
      cat -n ${base_dir}/videoinfo.playlist | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist.tmp
      mv ${tmp_dir}/videoinfo.playlist.tmp ${base_dir}/videoinfo.playlist

  else
      echo > ${base_dir}/videoinfo.playlist
fi

                
clear

cp ${base_dir}/videoinfo.playlist ${tmp_dir}/videoinfo.playlist-apa
#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
atleastone=$(grep '^/' ${tmp_dir}/videoinfo.playlist-apa | wc -l)

#  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYLIST
if [[ $atleastone -ne 0 ]]; then

#  ASSIGN PLAYLIST TO VARIABLE: $moddedplaylist 
moddedplaylist="$HOME""/.config/videoinfox/tmp/videoinfo.playlist-apa"

#  PLAYLIST INPUT FOR LOOP
input="$moddedplaylist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfo.playlist-apa2

#  #  START WRITING
while read -r line; do

   if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
           echo "$line" >> ${tmp_dir}/videoinfo.playlist-apa2  
      else
           :
   fi        

done < "$input"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

# REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist-apa3

mv ${tmp_dir}/videoinfo.playlist-apa3 ${tmp_dir}/videoinfo.playlist-apa2

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfo.playlist-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplaylist}" "${tmp_dir}/videoinfo.playlist-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfo.playlist-apa2

# NUMBER THE LIST
sed '/./=' ${tmp_dir}/videoinfo.playlist-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
     rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null     
fi
clear
if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then
        cat ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        #dashit=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
        dashit=$(echo "~") #
   else
        dashit=$(echo "-") # 
        echo
        echo "Playlist Empty . . ."
fi

#cat ${base_dir}/videoinfo.playlist 

# check if directory ${base_dir}/playlists is empty.  if it is, set playlist to Default 
searchtotal=$(find "$PWD" -type f \( -iname "vplaylist.*" \) 2>/dev/null | wc -l)

if [[ "$searchtotal" = 0 ]]; then
      echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current             
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      read -r setplaylist < ${tmp_dir}/plread.tmp
      rm ${tmp_dir}/plread.tmp
      # GET CURRENT PLAYLIST
      read -r activeplaylist < ${base_dir}/videoinfo.playlist.current
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      # SAVE CURRENT PLAYLIST
      cp ${base_dir}/videoinfo.playlist "$activeplaylist"
     
  else
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      read -r setplaylist < ${tmp_dir}/plread.tmp

      rm ${tmp_dir}/plread.tmp
fi
##################################################################################################################################################

#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

#echo "Directory: ""$PWD"

if [[ "$grabpaste" = "http" ]]; then
      echo
      echo "Clipboard: ""$pasteclip"
  else
      :
fi
if [[ "$grabpaste" = "http" ]]; then
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
      ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

            if [[ "$ytdlpconfirm" = "" ]]; then

                      echo "" | xclip -sel clip  # clearing out the clipboard
                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                           # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
                           #________________x________________________________________ _________________________________________________________
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " o "$dashit" Autoplay Line     l - Last Autoplay      c - Change Playlist     p - Play Clipboard                  q - Quit"
                      echo " j "$dashit" Play Line"
                      echo " i "$dashit" Info                                     d - Clear Playlist"
                      echo           

                  else 
                      echo
                      echo "YT-DLP Confirmed: "$ytdlpconfirm""
                      echo
                      echo "Download Directory: $dirsaved"  # dislpay default download directory
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
                      echo " j "$dashit" Play Line"
                      echo " i "$dashit" Info                                    d - Clear Playlist"
                      echo                                                                                    
            fi
  else

      if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
            echo " j "$dashit" Play Line"
            echo " i "$dashit" Info                                    d - Clear Playlist"
            echo                                                                     

        else 

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " j - Play Line     o - Start Autoplay      c - Change Playlist     p - Play Clipboard                     q - Quit"
            echo " i - Info          l - Resume Autoplay     r - Remove Line"
            echo "                                           d - Clear Playlist                                             h - Help"
            echo                                                             
fi
fi

echo -en " Enter Option: "
read -r -n1 optionv
}

        while true
        do
        menuvhome
        case $optionv in
    
        q)  # QUIT
        rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
        rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
        rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        cd "$grabdir"
        break;;

       
        h)
        echo
        echo
        echo " PLAYLIST LIST >>> HELP"        
        echo
        echo " Everytime Start Autoplay is used, it will write a new file for Resume Autoplay."
        echo " Run Start Autoplay first. Then use Resume Autoplay to continue watching where you left off."
        echo " Resume Autoplay will start with the last video that was playing when the play loop was quit."
        echo
        echo " Note: If the playlist is changed with Playlist Add or Remove Line after running Start Autoplay,"
        echo "       Resume Autoplay won't get updated with the changes until Start Autoplay is run again."
        echo
        read -p " Press enter to Continue"
        ;;
        o) # AUTOPLAY LINE  (HOME >>> PLAYLIST)

# SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Start Autoplay from line: " linenumber  # waiting fot user input

# 
tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      # COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done

# WRITE 2nd PLAYLIST FOR LAST AUTOPLAY OPTION . File: ${base_dir}/playlists/$playlistname.last-autoplay
tail -n +"$i" ${tmp_dir}/videoinfo.playlist-apa > "$setplaylist".last-autoplay

IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;

########################################
r)  # REMOVE LINE  (HOME >>> PLAYLIST)
########################################

# delete a line example to remove by pattern
#sed '\?^/mnt/MEDIA1/MOVIES/identity thief.mp4?d' videoinfo.playlist
# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplpld.tmp 
read -r whatplpld < ${tmp_dir}/whatplpld.tmp
rm ${tmp_dir}/whatplpld.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      :
  else
      echo > ${base_dir}/videoinfo.playlist
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then

      clear
      cat ${tmp_dir}/videoinfo.number.play-list 2> /dev/null

      echo
      read -r -p "Enter line number to remove video from the playlist $whatplpld: " linenumber  # waiting fot user input

      # REMOVE BLANK LINES
      ######squash ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

      # GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
      linecount=$(wc -l ${tmp_dir}/videoinfo.playlist-apa 2> /dev/null | cut -d' ' -f1) # 

          if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                :

            else  # ENTRY IS A NUMBER

                if [[ -z "$linenumber" ]]; then
                      :

                  else

                      if [[ "$linenumber" = 0 ]]; then
                            :

                        else
      
                            if [[ $linenumber -gt $linecount ]]; then 
                                  echo
                                  echo "Number out of range . . ."
                                  sleep .9

                              else

                                  if [[ -z "$linenumber" ]]; then
                                        :

                                    else
                                        # DELETE LINE NUMBER
                                        sed -i "${linenumber}d" ${base_dir}/videoinfo.playlist 2> /dev/null 
                                        echo
                                        echo "Line deleted from the playlist . . ."
                                        sleep .25
                                  fi
                            fi
                      fi
               fi
         fi
fi

;;
###########################################################
l) # LAST AUTOPLAY - RESUME AUOTOPLAY (HOME >>> PLAYLIST)
###########################################################

# READ FIRST LINE TO DISPLAY VIDEO NAME BEFORE PLAY
read < $HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay resumedisplay
echo
echo
echo " Resume: ""$resumedisplay"
sleep 3

###### SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

OLDIFS=$IFS
IFS=$'\n'

input2=$HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay
for line in $(cat "$input2" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      ###### COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING FOR WRITE ON EXIT.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
tail -n +"$i" ${base_dir}/playlists/"$setplaylist".last-autoplay > ${base_dir}/playlists/pl-tmp
mv ${base_dir}/playlists/pl-tmp ${base_dir}/playlists/"$setplaylist".last-autoplay
IFS=$OLDIFS

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
        j) # PLAY LINE  (HOME >>> PLAYLIST)

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Play Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

read line < ${tmp_dir}/videoinfo.playlist-apa

if [[ -z "$line" ]

  then
      :

  else

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> PLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      echo " Screen will close after video player is quit."

      ffplay -fs -autoexit "$line" 2> /dev/null
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

fi

else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
       i)  # INFO - <PLAYLIST>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo.playlist-apa ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo.playlist-apa.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$playnumber")  " Duration:" $(ffmpeg -i "$playnumber" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height & duration

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null

                 fi

        else
            :

            fi

      fi

;;       

########################################################################################################################################################
          c)
          # CHANGE PLAYLIST
########################################################################################################################################################

function changepl {

#read -r savepl < ${base_dir}/videoinfo.playlist.current
#cp ${base_dir}/videoinfo.playlist "$savepl"

# cd ${base_dir}/playlists

# FIND PLAYLISTS
find "$PWD" -type f \( -iname "vplaylist.*" \) > ${base_dir}/videoinfo.playlist.dirlist

# SORT BACK INTO ORDER
sort -u ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist 

#  REMOVE BLANK LINES
sed '/^$/d' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist

# REMOVE PATH
sed 's/.*\///' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp

# REMOVE FILENAME AND LEAVE EXTENSION
cat ${tmp_dir}/playlist.dirlist.tmp | sed 's/.*\.//' > ${tmp_dir}/playlist.dirlist.tmp2 
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp
# CREATE NUMBERED lIST
sed '/./=' ${tmp_dir}/playlist.dirlist.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/playlist.dirlist.tmp2
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp 
clear
cat ${tmp_dir}/playlist.dirlist.tmp
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$der"" >>> CHANGE PLAYLIST >>>" "$setplaylist"        
echo "___________________________________________________________________________________________________________________"
echo
echo " c - Change Playlist     a - Create Playlist     d - Delete Playlist                                      q - Quit"
echo 
echo -en " Enter Option: "
read -r -n1 optioncpl
echo
}
while true; do
changepl
case $optioncpl in
        q)  # QUIT
        ###cd "$grabdir"
        break ;;

    
        c)  # CHANGE PLAYLIST

# GET CURRENT PLAYLIST
read -r activeplaylistm < ${base_dir}/videoinfo.playlist.current

# SAVE CURRENT PLAYLIST
cp ${base_dir}/videoinfo.playlist "$activeplaylistm" 2>/dev/null

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# LOAD A PLAYLIST
echo
read -r -p " Enter line number: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
if [[ -z "$linenumber" ]]; then
      :

  else
      if [[ $linenumber -gt $linecount ]]

        then 
            echo
            echo " Number out of range . . ."
            sleep .9

        else

            # CREATE FILE MOVING SELECTION TO THE TOP
            tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp3

            # READ FIRST LINE OF FILE
            read plselected < ${tmp_dir}/playlist.dirlist.tmp3

            # WRITE SELECTED PLAYLIST
            echo "$plselected" > ${base_dir}/videoinfo.playlist.current

            # LOAD SELECTED PLAY LIST
            cp "$plselected" ${base_dir}/videoinfo.playlist 2>/dev/null
    
   fi
      fi

fi
break

;;
         d)  # DELETE PLAYLIST

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# SELECT A PLAYLIST TO DELETE
echo
read -r -p " Enter line number to delete: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo " Number out of range . . ."
                  sleep .9

              else
                  echo
                      # CREATE FILE MOVING SELECTION TO THE TOP
                      tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.playlist.delete.tmp

                      # READ FIRST LINE OF FILE
                      read plselected < ${tmp_dir}/playlist.playlist.delete.tmp

                      function menucpl {
                  
                      clear
                      echo
                      echo
                      echo " Delete Playlist . . ."
                      echo
                      echo " $plselected"
                      echo
                      echo " y - Yes     n - No"  
                      echo 
                      echo -en " Enter Option: "
                      read -r -n1 optioncpl
                      echo
                      }

                      while true
                      do
                    menucpl
                    case $optioncpl in

                    y)  # YES

                      rm "$plselected" 2> /dev/null

                      echo "$plselected"| sed 's/.*\.//' > ${tmp_dir}/plread.tmp  # REMOVE FULL PATH ONLY LEAVING PLAYLIST NAME
                      read -r plselectedla < ${tmp_dir}/plread.tmp  # READING PLAYLIST NAME ONLY INTO VARIABLE  $pselecteda
                      rm ${tmp_dir}/plread.tmp  # remove temp file
                      rm ${base_dir}/playlists/"$plselectedla".last-autoplay  # REMOVE PLAYLIST.last.autoplay  file
 
                      echo
                      echo  " Playlist Deleted . . ."

                      if [[ "$setplaylistfull" = "$plselected" ]]; then # SET DEFAULT PLAYLIST TO ACTIVE PLAYLIST
                            echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current
                            cp ${base_dir}/playlists/vplaylist.Default ${base_dir}/videoinfo.playlist 2> /dev/null
                            setplaylist="Default"
                        else
                            :
                      fi

                      sleep 1.7  
                      break
                      ;;
                      n)  # NO
                      break;;

                      *)
        
                      esac
                      done
        
            fi
      fi
fi
            
;;        
         a)
         # CREATE PLAYLIST
echo
echo " If any dots are entered, they will be stripped from the playlist name."
echo " If a space is used as the first character, it will be stripped from the playlist name."
echo " Spaces can be used after the first character of the playlist name."
echo
read -r -p " Create Playlist: " createpl1  # waiting fot user input. grabbing new filename

# Strip out any dots from user entry
echo "$createpl1" > ${tmp_dir}/plremovedot.tmp
sed -i -e 's/\.//g' ${tmp_dir}/plremovedot.tmp
read createpl < ${tmp_dir}/plremovedot.tmp
rm ${tmp_dir}/plremovedot.tmp

if [[ -z "$createpl" ]]; then
      echo
      echo " Nothing was entered . . ."
      sleep .75

  else

      if [[ -f ${base_dir}/playlists/vplaylist."$createpl" ]]; then
            echo
            echo " File already exists . . ."
            sleep .75

        else

plname="$HOME/.config/videoinfox/playlists/vplaylist.""$createpl"  # add user input as file extension
echo > "$plname"  #  create user list with full path and filename

echo > "$HOME"/.config/videoinfox/playlists/"$createpl1".last-autoplay

echo
echo " Playlist Created: "$plname""
echo
sleep 1.7

      fi
fi
;; 
esac
done
;;
          p) 
          #  @PLAY CLIPBOARD - <PLAYLIST>        

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdirz="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload  
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            echo > ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$ytdlplast")  " Duration:" $(ffmpeg -i "$ytdlplast" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
              :
          else     
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST File  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdirz"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      echo " PLAYLIST Closed"
  
        else
            
            echo
            echo
            echo " No playable content in the clipboard . . ."
            sleep 1.2
      fi   
  fi
  ;;  
         d)  # CLEAR PLAYLIST (VIEW PLAYLIST)

        function menucpl {
        
        clear
        echo
        echo
        echo " Clear current playlist: ""$setplaylist""?"
        echo
        echo " y - Yes     n - No"  
        echo 
        echo -en " Enter Option: "
        read -r -n1 optioncpl
        echo
        }

        while true
        do
      menucpl
      case $optioncpl in

      y)  # YES
        rm ${base_dir}/videoinfo.playlist 2> /dev/null
        echo > ${base_dir}/videoinfo.playlist
        echo > ${base_dir}/playlists/"$setplaylist".last-autoplay 
        echo
        echo " ""$setplaylist"" Playlist Cleared . . ."
        sleep 1.7  
        break
        ;;
        n)  # NO
        break;;

        *)
        
        esac
        done
        ;;
*)

esac
done
;;
k)
##################################################################################################################################################
###########################   ADD TO PLAYLIST  k   (PLAYED LIST)  ################################################################################
##################################################################################################################################################

# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplpld.tmp 
read -r whatplpld < ${tmp_dir}/whatplpld.tmp
rm ${tmp_dir}/whatplpld.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      :
  else
      echo > ${base_dir}/videoinfo.playlist
fi
if [[ -f ${base_dir}/videoinfo.playedlist ]]; then

      clear
      cat ${tmp_dir}/videoinfo.number.played-list

      echo
      read -r -p "Enter line number to add video to playlist $whatplpld: " linenumber  # waiting fot user input

      # REMOVE BLANK LINES
      squash ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null
      # create file moving selected line number to the top
      tail -n +"$linenumber" ${tmp_dir}/videoinfo.playedlist-apa > ${tmp_dir}/videoinfo.playedlist-playnumber.tmp 2>/dev/null
# GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
linecount=$(wc -l ${tmp_dir}/videoinfo.playedlist-apa | cut -d' ' -f1)

if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER

      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo "Number out of range . . ."
                  sleep .9

              else
      # read first line of file for play
      read playnumber < ${tmp_dir}/videoinfo.playedlist-playnumber.tmp

      if [[ -z "$playnumber" ]]; then
              :

          else
              echo "$playnumber" >> ${base_dir}/videoinfo.playlist   
              echo
              echo " ""$playnumber" 
              echo
              echo " Added to Playlist . . ."
              sleep .25
      fi

fi
fi
fi
else
    echo
    echo
    echo " Select Show All or use Find to acess this feature . . ."
    sleep 1.7

fi
;;

      
          p) 
          #  @PLAY CLIPBOARD - <PLAYED LIST>        

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdir="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload  
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            echo > ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$ytdlplast")  " Duration:" $(ffmpeg -i "$ytdlplast" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
              :
          else     
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List File  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdir"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      echo " Played List Closed"
  
        else
            
            echo
            echo
            echo " No playable content in the clipboard . . ."
            sleep 1.2
      fi   
  fi
  ;;  
                D)  # DELETE PLAYED LIST - <find menu>
                rm ${base_dir}/videoinfo.playedlist
                # writing header for new Played List because new file wouldn't be created until return to main HOME
                echo > ${base_dir}/videoinfo.playedlist
                #echo "PLAYED LIST" >> ${base_dir}/videoinfo.playedlist
                #echo >> ${base_dir}/videoinfo.playedlist
                #echo "This File was Created: $(date) by" "$USER" >> ${base_dir}/videoinfo.playedlist
                #echo >> ${base_dir}/videoinfo.playedlist      
                echo
                echo
                echo " Played List DELETED . . ."
                echo
                #read -p " Press enter to Continue"    
                sleep .7
                ;;

                *)

                esac
                done
                ;; 
##################################################################################################################################################
s) #######################  @PLAYLIST - (HOME)  ################################################################################################### 
##################################################################################################################################################

grabdir="$PWD"  # SAVE CURRENT DIRECTORY FOR RESTORE ON EXIT

cd ${base_dir}/playlists
function menuvhome {

squash ${base_dir}/videoinfo.playlist  # remove all blank lines

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$grabclip" = "http" ]]; then
      :

  else      
      if [[ -f "$pasteclip" ]]; then
            :
        else
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      # REMOVE DUPLICATES
      cat -n ${base_dir}/videoinfo.playlist | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist.tmp
      mv ${tmp_dir}/videoinfo.playlist.tmp ${base_dir}/videoinfo.playlist

  else
      echo > ${base_dir}/videoinfo.playlist
fi

                
clear

cp ${base_dir}/videoinfo.playlist ${tmp_dir}/videoinfo.playlist-apa
#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
atleastone=$(grep '^/' ${tmp_dir}/videoinfo.playlist-apa | wc -l)

#  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYLIST
if [[ $atleastone -ne 0 ]]; then

#  ASSIGN PLAYLIST TO VARIABLE: $moddedplaylist 
moddedplaylist="$HOME""/.config/videoinfox/tmp/videoinfo.playlist-apa"

#  PLAYLIST INPUT FOR LOOP
input="$moddedplaylist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfo.playlist-apa2

#  #  START WRITING
while read -r line; do

   if [[ -f "$line" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
           echo "$line" >> ${tmp_dir}/videoinfo.playlist-apa2  
      else
           :
   fi        

done < "$input"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

# REMOVE DUPLICATES
cat -n ${tmp_dir}/videoinfo.playlist-apa2 | sort -uk2 | sort -n | cut -f2- > ${tmp_dir}/videoinfo.playlist-apa3

mv ${tmp_dir}/videoinfo.playlist-apa3 ${tmp_dir}/videoinfo.playlist-apa2

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfo.playlist-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplaylist}" "${tmp_dir}/videoinfo.playlist-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfo.playlist-apa2 ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfo.playlist-apa2

# NUMBER THE LIST
sed '/./=' ${tmp_dir}/videoinfo.playlist-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   
else #  NO LINES START WITH A SLASH /   remove empty files
     rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
     rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
     rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null     
fi
clear
if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then
        cat ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        #dashit=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
        dashit=$(echo "~") #
   else
        dashit=$(echo "-") # 
        echo
        echo "Playlist Empty . . ."
fi

#cat ${base_dir}/videoinfo.playlist 

# check if directory ${base_dir}/playlists is empty.  if it is, set playlist to Default 
searchtotal=$(find "$PWD" -type f \( -iname "vplaylist.*" \) 2>/dev/null | wc -l)

if [[ "$searchtotal" = 0 ]]; then
      echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current             
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      read -r setplaylist < ${tmp_dir}/plread.tmp
      rm ${tmp_dir}/plread.tmp
      # GET CURRENT PLAYLIST
      read -r activeplaylist < ${base_dir}/videoinfo.playlist.current
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      # SAVE CURRENT PLAYLIST
      cp ${base_dir}/videoinfo.playlist "$activeplaylist"
     
  else
      cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/plread.tmp 
      
      read -r setplaylistfull < ${base_dir}/videoinfo.playlist.current

      read -r setplaylist < ${tmp_dir}/plread.tmp

      rm ${tmp_dir}/plread.tmp
fi
##################################################################################################################################################

#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY

##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

#echo "Directory: ""$PWD"

if [[ "$grabpaste" = "http" ]]; then
      echo
      echo "Clipboard: ""$pasteclip"
fi
if [[ "$grabpaste" = "http" ]]; then
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
      ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

            if [[ "$ytdlpconfirm" = "" ]]; then

                      echo "" | xclip -sel clip  # clearing out the clipboard
                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                           # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
                           #________________x________________________________________ _________________________________________________________
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " o "$dashit" Autoplay Line     l - Last Autoplay      c - Change Playlist     p - Play Clipboard                  q - Quit"
                      echo " j "$dashit" Play Line"
                      echo " i "$dashit" Info                                     d - Clear Playlist"
                      echo           

                  else 
                      echo
                      echo "YT-DLP Confirmed: "$ytdlpconfirm""
                      echo
                      echo "Download Directory: $dirsaved"  # dislpay default download directory
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
                      echo " j "$dashit" Play Line"
                      echo " i "$dashit" Info                                    d - Clear Playlist"
                      echo                                                                                    
            fi
  else

      if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo -e " o "$dashit" Autoplay Line     l - Last Autoplay     c - Change Playlist     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                   q - Quit"
            echo " j "$dashit" Play Line"
            echo " i "$dashit" Info                                    d - Clear Playlist"
            echo                                                                     

        else 

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> PLAYLIST >>>" "$setplaylist"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " j - Play Line     o - Start Autoplay      c - Change Playlist     p - Play Clipboard                     q - Quit"
            echo " i - Info          l - Resume Autoplay     r - Remove Line"
            echo "                                           d - Clear Playlist                                             h - Help"
            echo                                                             
fi
fi

echo -en " Enter Option: "
read -r -n1 optionv
}

        while true
        do
        menuvhome
        case $optionv in
    
        q)  # QUIT
        rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
        rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
        rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null
        cd "$grabdir"
        break;;

       
        h)
        echo
        echo
        echo " PLAYLIST LIST >>> HELP"        
        echo
        echo " Everytime Start Autoplay is used, it will write a new file for Resume Autoplay."
        echo " Run Start Autoplay first. Then use Resume Autoplay to continue watching where you left off."
        echo " Resume Autoplay will start with the last video that was playing when the play loop was quit."
        echo
        echo " Note: If the playlist is changed with Playlist Add or Remove Line after running Start Autoplay,"
        echo "       Resume Autoplay won't get updated with the changes until Start Autoplay is run again."
        echo
        read -p " Press enter to Continue"
        ;;
        o) # AUTOPLAY LINE  (HOME >>> PLAYLIST)

# SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Start Autoplay from line: " linenumber  # waiting fot user input

# 
tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      # COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done

# WRITE 2nd PLAYLIST FOR LAST AUTOPLAY OPTION . File: ${base_dir}/playlists/$playlistname.last-autoplay
tail -n +"$i" ${tmp_dir}/videoinfo.playlist-apa > "$setplaylist".last-autoplay

IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;

########################################
r)  # REMOVE LINE  (HOME >>> PLAYLIST)
########################################

# delete a line example to remove by pattern
#sed '\?^/mnt/MEDIA1/MOVIES/identity thief.mp4?d' videoinfo.playlist
# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplpld.tmp 
read -r whatplpld < ${tmp_dir}/whatplpld.tmp
rm ${tmp_dir}/whatplpld.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
    echo > ${base_dir}/videoinfo.playlist
fi
if [[ -f ${base_dir}/videoinfo.playlist ]]; then

      clear
      cat ${tmp_dir}/videoinfo.number.play-list 2> /dev/null

      echo
      read -r -p "Enter line number to remove video from the playlist $whatplpld: " linenumber  # waiting fot user input

      # REMOVE BLANK LINES
      ######squash ${tmp_dir}/videoinfo.playedlist-apa 2>/dev/null

      # GETTING NUMBER OF VIDEO FILES IN THE PLAYED LIST
      linecount=$(wc -l ${tmp_dir}/videoinfo.playlist-apa 2> /dev/null | cut -d' ' -f1) # 

          if [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
                if [[ -z "$linenumber" ]]; then
                      :

                  else

                      if [[ "$linenumber" = 0 ]]; then
                            :

                        else
      
                            if [[ $linenumber -gt $linecount ]]; then 
                                  echo
                                  echo "Number out of range . . ."
                                  sleep .9

                              else

                                  if [[ -z "$linenumber" ]]; then
                                        :

                                    else
                                        # DELETE LINE NUMBER
                                        sed -i "${linenumber}d" ${base_dir}/videoinfo.playlist 2> /dev/null 
                                        echo
                                        echo "Line deleted from the playlist . . ."
                                        sleep .25
                                  fi
                            fi
                      fi
               fi
         fi
fi

;;
###########################################################
l) # LAST AUTOPLAY - RESUME AUOTOPLAY (HOME >>> PLAYLIST)
###########################################################

# READ FIRST LINE TO DISPLAY VIDEO NAME BEFORE PLAY
read < $HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay resumedisplay
echo
echo
echo " Resume: ""$resumedisplay"
sleep 3

###### SET COUNTER TO ZERO. $i in below play loop to get line number from last played video
i=0

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

OLDIFS=$IFS
IFS=$'\n'

input2=$HOME/.config/videoinfox/playlists/"$setplaylist".last-autoplay
for line in $(cat "$input2" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      ###### COUNTER TO KEEP TRACK OF LINE NUMBER THAT IS CURRENTLY PLAYING FOR WRITE ON EXIT.
      i=$((i+1))

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Playlist Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
tail -n +"$i" ${base_dir}/playlists/"$setplaylist".last-autoplay > ${base_dir}/playlists/pl-tmp
mv ${base_dir}/playlists/pl-tmp ${base_dir}/playlists/"$setplaylist".last-autoplay
IFS=$OLDIFS

   else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
        j) # PLAY LINE  (HOME >>> PLAYLIST)

if [[ -f ${tmp_dir}/videoinfo.number.play-list ]]; then

echo
echo
read -r -p " Play Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfo.playlist-apa.tmp ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

read line < ${tmp_dir}/videoinfo.playlist-apa

if [[ -z "$line" ]]; then
      :

  else

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAYLIST >>> PLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      echo " Screen will close after video player is quit."

      ffplay -fs -autoexit "$line" 2> /dev/null
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfo.playlist-apa 2>/dev/null
rm ${tmp_dir}/videoinfo.playlist-apa2 2>/dev/null
rm ${tmp_dir}/videoinfo.number.play-list 2>/dev/null

fi

else
       echo
       echo
       echo " Playlist Empty . . ."
       sleep 1.7
fi

;;
       i)  # INFO - <PLAYLIST>
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo.playlist-apa ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo.playlist-apa > ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo.playlist-apa.tmp

                 if [[ -z "$playnumber" ]]; then
                       :
 
                   else
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$playnumber")  " Duration:" $(ffmpeg -i "$playnumber" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height & duration

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo.playlist-apa.tmp 2>/dev/null

                 fi

        else
            :

            fi

      fi

;;       

########################################################################################################################################################
          c)
          # CHANGE PLAYLIST
########################################################################################################################################################

function changepl {

#read -r savepl < ${base_dir}/videoinfo.playlist.current
#cp ${base_dir}/videoinfo.playlist "$savepl"

# cd ${base_dir}/playlists

# FIND PLAYLISTS
find "$PWD" -type f \( -iname "vplaylist.*" \) > ${base_dir}/videoinfo.playlist.dirlist

# SORT BACK INTO ORDER
sort -u ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist 

#  REMOVE BLANK LINES
sed '/^$/d' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp
mv ${tmp_dir}/playlist.dirlist.tmp ${base_dir}/videoinfo.playlist.dirlist

# REMOVE PATH
sed 's/.*\///' ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp

# REMOVE FILENAME AND LEAVE EXTENSION
cat ${tmp_dir}/playlist.dirlist.tmp | sed 's/.*\.//' > ${tmp_dir}/playlist.dirlist.tmp2 
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp
# CREATE NUMBERED lIST
sed '/./=' ${tmp_dir}/playlist.dirlist.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/playlist.dirlist.tmp2
mv ${tmp_dir}/playlist.dirlist.tmp2 ${tmp_dir}/playlist.dirlist.tmp 
clear
cat ${tmp_dir}/playlist.dirlist.tmp
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$der"" >>> CHANGE PLAYLIST >>>" "$setplaylist"        
echo "___________________________________________________________________________________________________________________"
echo
echo " c - Change Playlist     a - Create Playlist     d - Delete Playlist                                      q - Quit"
echo 
echo -en " Enter Option: "
read -r -n1 optioncpl
echo
}
while true; do
changepl
case $optioncpl in
        q)  # QUIT
        ###cd "$grabdir"
        break ;;

    
        c)  # CHANGE PLAYLIST

# GET CURRENT PLAYLIST
read -r activeplaylistm < ${base_dir}/videoinfo.playlist.current

# SAVE CURRENT PLAYLIST
cp ${base_dir}/videoinfo.playlist "$activeplaylistm" 2>/dev/null

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# LOAD A PLAYLIST
echo
read -r -p " Enter line number: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
if [[ -z "$linenumber" ]]; then
      :

  else
      if [[ $linenumber -gt $linecount ]]

        then 
            echo
            echo " Number out of range . . ."
            sleep .9

        else

            # CREATE FILE MOVING SELECTION TO THE TOP
            tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.dirlist.tmp3

            # READ FIRST LINE OF FILE
            read plselected < ${tmp_dir}/playlist.dirlist.tmp3

            # WRITE SELECTED PLAYLIST
            echo "$plselected" > ${base_dir}/videoinfo.playlist.current

            # LOAD SELECTED PLAY LIST
            cp "$plselected" ${base_dir}/videoinfo.playlist 2>/dev/null
    
   fi
      fi

fi
break

;;
         d)  # DELETE PLAYLIST

# GETTING NUMBER OF PLAYLISTS
linecount=$(wc -l ${base_dir}/videoinfo.playlist.dirlist | cut -d' ' -f1)

# SELECT A PLAYLIST TO DELETE
echo
read -r -p " Enter line number to delete: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo " Number out of range . . ."
                  sleep .9

              else
                  echo
                      # CREATE FILE MOVING SELECTION TO THE TOP
                      tail -n +"$linenumber" ${base_dir}/videoinfo.playlist.dirlist > ${tmp_dir}/playlist.playlist.delete.tmp

                      # READ FIRST LINE OF FILE
                      read plselected < ${tmp_dir}/playlist.playlist.delete.tmp

                      function menucpl {
                  
                      clear
                      echo
                      echo
                      echo " Delete Playlist . . ."
                      echo
                      echo " $plselected"
                      echo
                      echo " y - Yes     n - No"  
                      echo 
                      echo -en " Enter Option: "
                      read -r -n1 optioncpl
                      echo
                      }

                      while true
                      do
                    menucpl
                    case $optioncpl in

                    y)  # YES

                      rm "$plselected" 2> /dev/null

                      echo "$plselected"| sed 's/.*\.//' > ${tmp_dir}/plread.tmp  # REMOVE FULL PATH ONLY LEAVING PLAYLIST NAME
                      read -r plselectedla < ${tmp_dir}/plread.tmp  # READING PLAYLIST NAME ONLY INTO VARIABLE  $pselecteda
                      rm ${tmp_dir}/plread.tmp  # remove temp file
                      rm ${base_dir}/playlists/"$plselectedla".last-autoplay  # REMOVE PLAYLIST.last.autoplay  file
 
                      echo
                      echo  " Playlist Deleted . . ."

                      if [[ "$setplaylistfull" = "$plselected" ]]; then # SET DEFAULT PLAYLIST TO ACTIVE PLAYLIST
                            echo "$HOME/.config/videoinfox/playlists/vplaylist.Default" > ${base_dir}/videoinfo.playlist.current
                            cp ${base_dir}/playlists/vplaylist.Default ${base_dir}/videoinfo.playlist 2> /dev/null
                            setplaylist="Default"
                        else
                            :
                      fi

                      sleep 1.7  
                      break
                      ;;
                      n)  # NO
                      break;;

                      *)
        
                      esac
                      done
        
            fi
      fi
fi
            
;;        
         a)
         # CREATE PLAYLIST
echo
echo " If any dots are entered, they will be stripped from the playlist name."
echo " If a space is used as the first character, it will be stripped from the playlist name."
echo " Spaces can be used after the first character of the playlist name."
echo
read -r -p " Create Playlist: " createpl1  # waiting fot user input. grabbing new filename

# Strip out any dots from user entry
echo "$createpl1" > ${tmp_dir}/plremovedot.tmp
sed -i -e 's/\.//g' ${tmp_dir}/plremovedot.tmp
read createpl < ${tmp_dir}/plremovedot.tmp
rm ${tmp_dir}/plremovedot.tmp

if [[ -z "$createpl" ]]; then
      echo
      echo " Nothing was entered . . ."
      sleep .75

  else

      if [[ -f ${base_dir}/playlists/vplaylist."$createpl" ]]; then
            echo
            echo " File already exists . . ."
            sleep .75

        else

plname="$HOME/.config/videoinfox/playlists/vplaylist.""$createpl"  # add user input as file extension
echo > "$plname"  #  create user list with full path and filename

echo > "$HOME"/.config/videoinfox/playlists/"$createpl1".last-autoplay

echo
echo " Playlist Created: "$plname""
echo
sleep 1.7

      fi
fi
;; 
esac
done
;;
          p) 
          #  @PLAY CLIPBOARD - <PLAYLIST>        

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdirz="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload  
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            echo > ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

           
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$ytdlplast")  " Duration:" $(ffmpeg -i "$ytdlplast" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
              :
          else     
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST File  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdirz"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to PLAYLIST file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      echo " PLAYLIST Closed"
  
        else
            
            echo
            echo
            echo " No playable content in the clipboard . . ."
            sleep 1.2
      fi   
  fi
  ;;  
         d)  # CLEAR PLAYLIST (VIEW PLAYLIST)

        function menucpl {
        
        clear
        echo
        echo
        echo " Clear current playlist: ""$setplaylist""?"
        echo
        echo " y - Yes     n - No"  
        echo 
        echo -en " Enter Option: "
        read -r -n1 optioncpl
        echo
        }

        while true
        do
      menucpl
      case $optioncpl in

      y)  # YES
        rm ${base_dir}/videoinfo.playlist 2> /dev/null
        echo > ${base_dir}/videoinfo.playlist
        echo > ${base_dir}/playlists/"$setplaylist".last-autoplay 
        echo
        echo " ""$setplaylist"" Playlist Cleared . . ."
        sleep 1.7  
        break
        ;;
        n)  # NO
        break;;

        *)
        
        esac
        done
        ;;
*)

esac
done
;;
k)
##################################################################################################################################################
###########################   ADD TO PLAYLIST  k   <HOME>  #######################################################################################
##################################################################################################################################################

# REMOVE EVERYTHING FROM THE BEGINNING OF THE LINE UP TO AND INCLUDING THE DOT). LEAVING ONLY PLAYLIST NAME
cat ${base_dir}/videoinfo.playlist.current | sed 's/.*\.//' > ${tmp_dir}/whatplhome.tmp 
read -r whatplhome < ${tmp_dir}/whatplhome.tmp
rm ${tmp_dir}/whatplhome.tmp
if [[ -f ${base_dir}/videoinfo.playlist ]]; then
      :
  else
      echo > ${base_dir}/videoinfo.playlist
fi
if [[ -f ${tmp_dir}/videoinfo-findwork.tmp ]]; then

      clear
      cat ${tmp_dir}/videoinfo-number-findwork.tmp

      echo
      read -r -p "Enter line number to add video to playlist $whatplhome: " linenumber  # waiting fot user input

      # create file moving selected line number to the top
      tail -n +"$linenumber" ${tmp_dir}/videoinfo-findwork.tmp > ${tmp_dir}/videoinfo-findwork-playnumber.tmp 2>/dev/null

# GETTING NUMBER OF VIDEO FILES FROM FIND RESULTS
linecount=$(wc -l ${tmp_dir}/videoinfo-findwork.tmp | cut -d' ' -f1)

if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER

      if [[ -z "$linenumber" ]]; then
            :

        else
            if [[ $linenumber -gt $linecount ]]; then 
                  echo
                  echo "Number out of range . . ."
                  sleep .9

              else
     
      # read first line of file for play
      read playnumber < ${tmp_dir}/videoinfo-findwork-playnumber.tmp

      if [[ -z "$playnumber" ]]; then
              :

          else
              echo "$playnumber" >> ${base_dir}/videoinfo.playlist
              echo
              echo " ""$playnumber" 
              echo
              echo " Added to Playlist . . ."
              sleep .25
      fi
fi
fi
fi

else
    echo
    echo
    echo " Select Show All or use Find to acess this feature . . ."
    sleep 1.7

fi
;;
##################################################################################################################################################
    f)  ################  FIND ROUTINE - <HOME>  #################################################################################################
##################################################################################################################################################

    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard Content: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$ver"" >>> Find Video File(s) - Recursive                                               wildcard * ok"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " Find a video file to play, add it to the playlist or get info.  No file extensions." 
    echo
    read -r -p " File Name: " videofind  # waiting fot user input - video file that you want to find

    searchtotal=$(find "$PWD" -type f \( -iname "$videofind.mp4" -o -iname "$videofind.mkv" -o -iname "$videofind.avi" -o -iname "$videofind.webm" -o -iname "$videofind.divx" \) 2>/dev/null | wc -l)    
                                                                                                      
    if [[ -z "$videofind" ]]; then
               echo
               echo " error: Nothing was entered."
               echo
               sleep .7        
          else
                
              if echo "$videofind" | grep "/" > /dev/null  # if any slashehes were entered goto <then>
                then
                    echo
                    echo " error: No directories only filenames."
                    echo
                    sleep .7 
                else
                                
                     if [[ "$searchtotal" = 0 ]  # if find returned no results goto <then>
      
                       then
                           #cp ${base_dir}/videoinfo.findwork3 ${base_dir}/videoinfo.findwork
                           #cp ${base_dir}/videoinfo.lastsearchtotal2  ${base_dir}/videoinfo.lastsearchtotal
                           echo
                           echo " No files found"
                           echo
                           sleep .7 
                          
                       else
                           echo "$videofind" > ${base_dir}/videoinfo.lastfindstring   # save last find string used                          
                           read -r fterm < ${base_dir}/videoinfo.lastfindstring

                           # save find results
find "$PWD" -type f \( -iname "$videofind.mp4" -o -iname "$videofind.mkv" -o -iname "$videofind.avi" -o -iname "$videofind.webm" -o -iname "$videofind.divx" \) | sort -u > ${base_dir}/videoinfo.findwork
                           echo "$PWD" > ${base_dir}/videoinfo.lastfinddir  # save last directory that last find was run in 
                           # write last search total file count
                           echo "$searchtotal" > ${base_dir}/videoinfo.lastsearchtotal
                           # read last search total file count
                           read -r searchtotal < ${base_dir}/videoinfo.lastsearchtotal    
                           cp ${base_dir}/videoinfo.findwork ${base_dir}/videoinfo.findwork3
                           cp ${base_dir}/videoinfo.lastsearchtotal ${base_dir}/videoinfo.lastsearchtotal2                 
                           echo
                           echo " Total files found: " "$searchtotal"  # number of files found
                           notify-send  "Videoinfox messsage: Find results in $PWD" "$searchtotal files found using search term: $fterm"
                           sleep 1.5
    fi
    fi              
    fi
    ;;
##################################################################################################################################################
z)  # SETTINGS - <HOME>  #########################################################################################################################
##################################################################################################################################################

function menusettings {
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
# LOAD STORED DIRECTORIES
read -r dir1 < ${base_dir}/videoinfo.tv-dir 2> /dev/null
read -r dir2 < ${base_dir}/videoinfo.movies-dir 2> /dev/null
read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null
read -r dir4 < ${base_dir}/videoinfo.parent-dir 2> /dev/null
read -r dir5 < ${base_dir}/videoinfo.dir-at-exit 2> /dev/null

clear
echo
echo "Directory:" "$PWD"
echo "Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> SETTINGS                                                  Enter - Update Clipboard Display"
echo "___________________________________________________________________________________________________________________" 
echo
echo " Set Default Directories                                                                     q - Quit"
echo
echo "                                                                                             v - Videoinfox Update"
echo " 1 - TV:" "$dir1"
echo "                                                                                             y - Yt-dlp Update"
echo " 2 - Movies:" "$dir2"
echo "                                                                                             l - Last Search"
echo " 3 - Download:" "$dirsaved"
echo "                                                                                             h - Version History"
echo " 4 - Extra:" "$dir4"
echo "                                                                                             c - Code Stats"
echo
echo "                                                                                             x - Clear Clipboard"
echo " Last Exit Dir 5:" "$dir5"
echo
echo
echo -en " Enter Option: "
read -r -n1 optionsettings
}

while true; do
menusettings
case $optionsettings in

    q)  # QUIT
    break;;
    x) #  CLEAR CLIPBOARD  <DOWNLOAD LIST> 
    echo "" | xclip -sel clip  # clearing out the clipboard
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    ;;
    c)  # CODE STATS

function codestats {

clear
echo
echo #"Directory:" "$PWD"
echo #"Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> SETTINGS >>> CODE STATS                                                           q - Quit"
echo "___________________________________________________________________________________________________________________" 
echo
echo

a=$(grep -c "^$" /usr/local/bin/videoinfox 2> /dev/null)  # NUMBER OF BLANK LINES
b=$(sed -n -e '/#/p' /usr/local/bin/videoinfox | wc -l 2> /dev/null)  # NUMBER OF COMMENT ONLY LINES
c=$(sed -n '$=' /usr/local/bin/videoinfox 2> /dev/null)  # TOTAL LINES

d=$((c - a - b))  # CODE LINES = TOTAL LINES - BLANK LINES - COMMENT ONLY LINES
# GET VIDEOINFOX FILE SIZE AND LOCATION AND WRITE TO FILE:  ${base_dir}/videoinfox.code-stats.tmp
du -h /usr/local/bin/videoinfox > ${base_dir}/videoinfox.code-stats.tmp 2> /dev/null

# READ FILE SIZE
vsize=$(sed 's:/.*::' ${base_dir}/videoinfox.code-stats.tmp)

# READ FILE LOCATION
vlocat=$(cat ${base_dir}/videoinfox.code-stats.tmp | cut -c 6-)
printf " Code Lines .......  %s\n" "$d"

echo
printf " Comment Lines ....  %s\n" "$b"

echo
printf " Blank Lines ......  %s\n" "$a"

echo " _________________________"

echo
printf " Total Lines ...... %s\n" "$c"
echo
echo
echo " File Size:" "$vsize"
echo
echo " File Location:" "$vlocat"
#echo " White Spaces ....." $(wc -w < /usr/local/bin/videoinfox 2> /dev/null)  # White Space COUNT
echo
echo
echo -en " Enter Option: "
read -r -n1 optionstats
}
while true; do
codestats
case $optionstats in

    q)  # QUIT
    break;;

*)

esac
done
;;

    
    h)  # VERSION HISTORY
    clear
    less ${base_dir}/videoinfo-ver-history
    ;;

    l)
    
     function lastsearch {
         read -r lsearch < ${base_dir}/videoinfo.lastsearch-set
         clear
         echo
         echo "___________________________________________________________________________________________________________________"
         echo
         echo " "$der"  >>> SETTINGS >>> LAST SEARCH                                               Current Setting: "$lsearch" "
         echo "___________________________________________________________________________________________________________________"
         echo
         echo
         echo " If there are search results on the the home screen on exit, the below always applies to the next run."
         echo
         echo
         echo " 1 - Always Save                                                                                          q - Quit"  
         echo
         echo " 2 - Never Save"
         echo
         echo " 3 - Ask on Exit"
         echo
         echo
         echo -en " Enter Option: "
         read -r -n1 optionz
         echo
         }
        
              
         while true
         do
         lastsearch
        case $optionz in

         q)
         break;;
  
         1)
         
         echo "1" > ${base_dir}/videoinfo.lastsearch-set
         echo
         echo " Always Save . . ."
         sleep .7
         ;;
         2)
         echo "2" > ${base_dir}/videoinfo.lastsearch-set
         echo
         echo " Never Save . . . "
         sleep .7
         ;;

        
         3)
         echo "3" > ${base_dir}/videoinfo.lastsearch-set
         echo
         echo " Ask on Exit . . ."
         sleep .7
         ;;

         *)

         esac
         done

         ;;
    1)
    # SET TV DIRECTORY
    grabdir="$PWD"  # grab working directory 
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " $ver >>> SET TV DIRECTORY"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " No quotations needed for paths with spaces. Case sensative."
    echo
    read -r -p " Enter Directory: " specifydir2  # waiting fot user input - the directory you want to chang to 
    
         if [[ -z "$specifydir2" ]]; then
                echo
                echo " error: Nothing was entered"
            else
                if [[ -d "$specifydir2" ]]; then
                      echo
                      echo "$specifydir2" > ${base_dir}/videoinfo.tv-dir
                      read -r dir1 < ${base_dir}/videoinfo.tv-dir
                      echo " TV Directory Set to:" "$dir1"                  
                      else
                      echo
                      echo " error: Directory doesn't exist"                    
                fi
          fi       
          
          #read -p "     Press enter to Continue" 
          cd "$grabdir"  # restore working directory
          sleep 1.5
          ;;
    2)
    # SET MOVIES DIRECTORY
    grabdir="$PWD"  # grab working directory 
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content 
    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo 
    echo " ""$ver"" >>> SET MOVIE DIRECTORY"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " No quotations needed for paths with spaces. Case sensative."
    echo
    read -r -p " Enter Directory: " specifydir2  # waiting fot user input - the directory you want to chang to 
    
         if [[ -z "$specifydir2" ]]; then
                echo
                echo " error: Nothing was entered"
            else
                if [[ -d "$specifydir2" ]]; then
                      echo
                      echo "$specifydir2" > ${base_dir}/videoinfo.movies-dir
                      read -r dir2 < ${base_dir}/videoinfo.movies-dir
                      echo " Movie Directory Set to:" "$dir2"                  
                      else
                      echo
                      echo " error: Directory doesn't exist"                    
                fi
          fi       
          
          #read -p "     Press enter to Continue" 
          cd "$grabdir"  # restore working directory
          sleep 1.5
          ;;
    3)
    # SET <yt-dlp> DOWNLOAD DIRECTORY
    grabdir="$PWD"  # grab working directory 
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " $ver >>> SET YT-DLP DOWNLOAD DIRECTORY"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " No quotations needed for paths with spaces. Case sensative."
    echo
    read -r -p " Enter Directory: " specifydir2  # waiting fot user input - the directory you want to chang to 
    
         if [[ -z "$specifydir2" ]]; then
                echo
                echo " error: Nothing was entered"
            else
                if [[ -d "$specifydir2" ]]; then
                      echo
                      echo "$specifydir2" > ${base_dir}/videoinfo.yt-download-dir
                      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir
                      echo " Download Directory Set to:" "$dirsaved"                  
                      else
                      echo
                      echo " error: Directory doesn't exist"                   
                fi
          fi       
          
          #read -p "     Press enter to Continue" 
          cd "$grabdir"  # restore working directory
          sleep 1.5
          ;;
 4)
    # SET PARENT DIRECTORY
    grabdir="$PWD"  # grab working directory 
    pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
    clear
    echo
    echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
    echo "Clipboard: ""$pasteclip"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " $ver >>> SET EXTRA DIRECTORY"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " No quotations needed for paths with spaces. Case sensative."
    echo
    read -r -p " Enter Directory: " specifydir2  # waiting fot user input - the directory you want to chang to 
    
         if [[ -z "$specifydir2" ]]; then
                echo
                echo " error: Nothing was entered"
            else
                if [[ -d "$specifydir2" ]]; then
                      echo
                      echo "$specifydir2" > ${base_dir}/videoinfo.parent-dir
                      read -r dir4 < ${base_dir}/videoinfo.parent-dir
                      echo " Extra Directory Set to:" "$dir4"                  
                      else
                      echo
                      echo " error: Directory doesn't exist"                    
                fi
          fi       
          
          #read -p "     Press enter to Continue" 
          cd "$grabdir"  # restore working directory
          sleep 1.5
          ;;
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    
    v)  # CHECK FOR VIDEOINFOX UPDATE
    function menuinfox {

    dirtemp="$PWD"  # save dir for restore
    cd ${tmp_dir}

    wget https://raw.githubusercontent.com/powerhousepro69/videoinfox/main/videoinfox 2>/dev/null
    chmod +x ${tmp_dir}/videoinfox 2>/dev/null
    if [[ -f ${tmp_dir}/videoinfox ]]; then
            gver=$(${tmp_dir}/videoinfox -v)

       else
            gver="Download Failure"
    fi
    clear     
    clear 
    echo
    echo
    echo
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$der"" >>> CHECK VIDEOINFOX UPDATE"
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " videoinfox Home: https://github.com/powerhousepro69/videoinfox"
    echo 
    echo " Downloaded From: https://raw.githubusercontent.com/powerhousepro69/videoinfox/main/videoinfox"
    echo
    echo
    echo " Version Check Complete"
    echo
    echo " Downloaded: ""$gver"
    echo
    echo " Installed: " "$ver" 
    echo
    echo
    echo " u - Update     d - Don't Update"  
    echo
    echo -en " Enter Option: "
    read -r -n1 optioninfox
    echo
    }
        
              
         while true
         do
         menuinfox
       case $optioninfox in
         d)
         #  QUIT
         cd "$dirtemp" # restore directory
         rm ${tmp_dir}/* 2> /dev/null
         echo
         echo " Not Updated . . ."
         sleep .6
         break;;
      
         u)
         # UPDATE VIDEOINFOX
     
         if [[ -f ${tmp_dir}/videoinfox ]]; then
                 echo
                 sudo mv ${tmp_dir}/videoinfox /usr/local/bin/videoinfox 2> /dev/null
                 rm ${tmp_dir}/* 2> /dev/null
                 echo
                 echo " Downloaded videoinfox copied to: /usr/local/bin"
                 echo   
    
                 sec=3
                 while [ $sec -ge 0 ]; do  #  This pauses the execution.  It displays and counts down the seconds set in <$sec>
                      echo -ne " UPDATED . . . $sec\033[0K\r"
                      let " sec=sec-1"
                      sleep 1
                 done         
                 clear
                 echo -e "\n"
                 echo
                 echo "___________________________________________________________________________________________________________________"  
                 echo
                 echo " $der >>> EXIT"
                 echo "___________________________________________________________________________________________________________________" 
                 echo
                 echo
                 echo " Videoinfox Updated . . ."
                 sleep 1.5
       
  
                 clear
                 echo -e "\n"
                 echo
                 echo "___________________________________________________________________________________________________________________"
                 echo  
                 echo " $der >>> EXIT >>> Updated to: "$gver"                    Restart to use updated version."
                 echo "___________________________________________________________________________________________________________________" 
                 echo -e "\n"
                
                 cd "$dirtemp"  # restore directory
                 exit
                
            else 
                 :

         fi

      
         cd "$dirtemp"  # restore directory
         ;;

          
         esac
         done
         ;;
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        
         y)  # CHECK FOR YT-DLP UPDATE

dirtemp="$PWD"  # save dir for restore after yt-dlp download      

# Yt-dlp download attempt.
clear
echo
echo 
echo 
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> Attempting to download the most recent version of Yt-dlp"
echo "___________________________________________________________________________________________________________________" 
echo
echo " If Yt-dlp can't be downloaded, the download attempt will be aborted."
echo
echo " If the download fails, it is most likely due to at least 1 of the following reasons:"
echo
echo "    - Your internet connection is down."
echo
echo "    - Github isn't reachable due to technical issues on their end."
echo
echo "    - There is no Yt-dlp release available in:  https://github.com/yt-dlp/yt-dlp/releases/latest/download"
echo
echo
echo " If this download fails, the download attempt will be tried again when you select the Yt-dlp Menu in Videoinfox."
echo
echo
echo " Note: The Yt-dlp Menu will not work until there is a copy of yt-dlp in:"
echo
echo " "$HOME"/.config/videoinfox"
echo
echo

cd ${tmp_dir}
 
wget https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp 2>/dev/null  # download yt-dlp 
if [[ -f ${tmp_dir}/yt-dlp ]]; then
        chmod a+rx ${tmp_dir}/yt-dlp  # set <yt-dlp-fetched> execute bit  
        sec=5
             
         while [ $sec -ge 0 ]; do  #  This pauses the execution.  It displays and counts down the seconds set in <$sec>
              echo -ne " Yt-dlp Downloaded . . . $sec\033[0K\r"
              let " sec=sec-1"
              sleep 1
         done

    
   
function chkytdlp {

         if [[ -f ${tmp_dir}/yt-dlp ]]; then
                 ytexist=$(${base_dir}/yt-dlp --version)
            else
                 ytexist="Not installed"
         fi

         clear 
         echo
         echo
         echo
         echo "___________________________________________________________________________________________________________________"
         echo
         echo " ""$der"" >>> CHECK YT-DLP UPDATE"
         echo "___________________________________________________________________________________________________________________"
         echo
         echo " Yt-dlp Home: https://github.com/yt-dlp/yt-dlp"
         echo
         echo " Downloaded From: https://github.com/yt-dlp/yt-dlp/releases/latest/download"
         echo
         echo
         echo " Version Check Complete"
         echo
         echo " Downloaded:" $(${tmp_dir}/yt-dlp --version)
         echo
         echo " Installed: " "$ytexist"
         echo
         echo
         echo " u - Update     d - Don't Update"  
         echo
         echo -en " Enter Option: "
         read -r -n1 optionytdlp
         echo         
}        
              
         while true
         do
         chkytdlp
       case $optionytdlp in
         d)
         #  DON'T UPDATE
         rm ${tmp_dir}/* 2>/dev/null
         cd "$dirtemp"  # restore directory
         echo
         echo " Yt-dlp Not Updated . . ."
         sleep .7
         break;;
      
         u)
         # UPDATE
         rm ${base_dir}/yt-dlp 2> /dev/null
         mv ${tmp_dir}/yt-dlp ${base_dir} 2> /dev/null       
         ${base_dir}/yt-dlp --version > ${base_dir}/videoinfo.yt-dlp.version
         rm ${tmp_dir}/* 2>/dev/null
         cd "$dirtemp"  # restore directory
         echo
                 
         sec=3
              while [ $sec -ge 0 ]; do  #  This pauses the execution.  It displays and counts down the seconds set in <$sec>
              echo -ne " Yt-dlp UPDATED . . . $sec\033[0K\r"
              let " sec=sec-1"
              sleep 1
              done         
              break;;
   
         esac
         done
   else
         rm ${tmp_dir}/* 2>/dev/null     
         cd "$dirtemp"  # restore directory
         sec=20           
         while [ $sec -ge 0 ]; do  #  This pauses the execution.  It displays and counts down the seconds set in <$sec>                       
              echo -ne " Yt-dlp Download Failure . . . $sec\033[0K\r"
              let "sec=sec-1"
              sleep 1
         done     
fi
;;         
esac
done

rm ${tmp_dir}/* 2>/dev/null
;;

##################################################################################################################################################
###########################  HOME OPTION  y  Yt-dlp Menu  ########################################################################################
##################################################################################################################################################

y)       

grabdir="$PWD"  # grab working directory
pasteclip3=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content to restore to before this function was run
if ! command -v ${base_dir}/yt-dlp &> /dev/null  # if <yt-dlp> isnt found goto then

then

# Yt-dlp download attempt.  Yt-dlp Menu won't start untl Yt-dlp is downloaded to: ${base_dir}/yt-dlp
clear
echo
echo 
echo 
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> Attempting to download the most recent version of Yt-dlp"
echo "___________________________________________________________________________________________________________________" 
echo
echo " If Yt-dlp can't be downloaded, the download attempt will be aborted."
echo
echo " If the download fails, it is most likely due to at least 1 of the following reasons:"
echo
echo "    - Your internet connection is down."
echo
echo "    - Github isn't reachable due to technical issues on their end."
echo
echo "    - There is no Yt-dlp release available in:  https://github.com/yt-dlp/yt-dlp/releases/latest/download"
echo
echo
echo " If this download fails, the download attempt will be tried again when you select the Yt-dlp Menu in Videoinfox."
echo
echo
echo " Note: The Yt-dlp Menu will not work until there is a copy of yt-dlp in:"
echo
echo " "$HOME"/.config/videoinfox"
echo
echo

dirtemp="$PWD"  # save dir for restore after ty-dlp download
cd ${base_dir}

wget https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp 2>/dev/null  # download yt-dlp 
 
if [[ -f ${base_dir}/yt-dlp ]]; then
        chmod a+rx ${base_dir}/yt-dlp  # set <yt-dlp-fetched> execute bit
        ${base_dir}/yt-dlp --version > ${base_dir}/videoinfo.yt-dlp.version # write yt-dlp ver number to file: yt-dlp.version 
        echo
        echo " Yt-dlp Downloaded . . ."
        echo
        # SAMPLE VIDEO URL BEING COPIED TO CLIPBOARD
        echo "https://www.youtube.com/watch?v=rNWPqfCJDnc" | xclip -sel clip 

        sec=5           
        while [ $sec -ge 0 ]; do  #  This pauses the execution.  It displays and counts down the seconds set in <$sec>                       
             echo -ne " $ver starting in: $sec\033[0K\r"
             let "sec=sec-1"
             sleep 1
        done

        cd "$dirtemp"  # restore directory
        rm ${base_dir}/wget-* 2> /dev/null  
   else
       
        echo
        echo " Yt-dlp Download Failure . . ."
        echo

        sec=20           
        while [ $sec -ge 0 ]; do  #  This pauses the execution.  It displays and counts down the seconds set in <$sec>                       
             echo -ne " $ver starting in: $sec\033[0K\r"
             let "sec=sec-1"
             sleep 1
        done     

        cd "$dirtemp"  # restore directory
        rm ${base_dir}/wget-* 2> /dev/null
fi
############################

else  # IF YT-DLP IS FOUND    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

###########################

read -r ytdlpver < ${base_dir}/videoinfo.yt-dlp.version

function menuy {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$grabclip" = "http" ]]; then
      :

  else      
      if [[ -f "$pasteclip" ]]; then
            :
        else
            echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi
read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir
#######################  cd "$dirsaved" 

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

clear
echo
echo "Directory: ""$PWD"
echo "Clipboard:" "$pasteclip"
##################################################################################################################################################
#=================================================================================================================================================
#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY
#=================================================================================================================================================
##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

if [[ "$grabpaste" = "http" ]]; then
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
      ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

            if [[ "$ytdlpconfirm" = "" ]]; then

                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
                      dash0=$(echo "-") # not blinking

                           # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
                           #________________x________________________________________ _________________________________________________________
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " ""$der"" >>> YT-DLP MENU         Enter - Update Clipboard Display         yt-dlp Version: $ytdlpver"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " d "$dash0" Download Default     l - Last Download     v - View Downloads     p - Play Clipboard                 q - Quit"
                      echo " c "$dash0" Download Choose"
                      echo " s "$dash0" Self Destruct        g - Download List                            x - Clear Clipboard"
                      echo
                  
                      echo "" | xclip -sel clip  # clearing out the clipboard
                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
                  else 
                      
                      dash1=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
                      
                      echo
                      echo "YT-DLP Confirmed: "$ytdlpconfirm""
                      echo
                      echo "Download Directory: $dirsaved"  # dislpay default download directory
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " ""$der"" >>> YT-DLP MENU         Enter - Update Clipboard Display         yt-dlp Version: $ytdlpver"
                      echo "___________________________________________________________________________________________________________________"
                      echo

echo -e " d "$dash1" Download Default     l - Last Download     v - View Downloads     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                 q - Quit "

                      echo " c "$dash1" Download Choose"
                      echo " s "$dash1" Self Destruct        g - Download List                            x - Clear Clipboard"
                      echo                                                                                  
            fi
  else

      if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " ""$der"" >>> YT-DLP MENU         Enter - Update Clipboard Display         yt-dlp Version: $ytdlpver"
            echo "___________________________________________________________________________________________________________________"
            echo

echo -e " d - Download Default     l - Last Download     v - View Downloads     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                 q - Quit "
                                                      
            echo " c - Download Choose"
            echo " s - Self Destruct        g - Download List                            x - Clear Clipboard"
            echo                                                             

        else 

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo
            echo " ""$der"" >>> YT-DLP MENU         Enter - Update Clipboard Display         yt-dlp Version: $ytdlpver"        
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " d - Download Default     l - Last Download     v - View Downloads     p - Play Clipboard                 q - Quit"
            echo " c - Download Choose"
            echo " s - Self Destruct        g - Download List                            x - Clear Clipboard"
            echo
fi
fi

echo -en " Enter Option: "                             
read -r -n1 optiony

}
     while true
     do
     menuy
    case $optiony in
     q)  # QUIT
     clear
     break;;
     x)  # CLEAR CLIPBOARD  (DOWNLOAD LIST)
     echo "" | xclip -sel clip  # clearing out the clipboard
     pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
     ;;
     g)  # DOWNLOAD LIST  <YT-DLP MENU>

rm ${base_dir}/videoinfox-dl-Default~ 2> /dev/null  # tmp fix

echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null) # grab clipboard content
function dwnlist {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -f "$pasteclip" ]]; then
:
else
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
fi
 
# find default download list and write to file.
find ${base_dir}/videoinfox-dl-Default > ${base_dir}/videoinfox.dowload.list.default

# find user created download lists and write to file. these results also include the log files which shouldn't be listed here
find "$PWD" -type f \( -iname "videoinfox-dl*" \) > ${base_dir}/videoinfox.dowload.list

# removing all lines that contain  .log   this removes all  */.videoinfox-dl*.log listings from results. write file: videoinfox.dowload.list  
sed -i '/.log/d' ${base_dir}/videoinfox.dowload.list 
sed -i '/videoinfox-dl-Default/d' ${base_dir}/videoinfox.dowload.list  # remove default list from user list and write file

# count lines file for message display below:  (Copy 1 above User List to the the clipboard to: Download or Set...) 
copymessage=$(sed -n '$=' ${base_dir}/videoinfox.dowload.list 2> /dev/null)  # only reading, no writing
##################################################################################
##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################## 

# DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

# DEFAULT DIR NUMBER 1 FORMAT
dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
# DEFAULT DIR NUMBER 2 FORMAT
dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
# DEFAULT DIR NUMBER 3 FORMAT
dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
# DEFAULT DIR NUMBER 4 FORMAT
dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
# DEFAULT DIR NUMBER 5 FORMAT
dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
# NO MATCH ALL LESS BOLD
dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
# FORMAT PWD NAME FOR COMPARISON
echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

# FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

# FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

# FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

# FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

# FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
# LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
# DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

if [[ "$controldir" = "$dir5display" ]]; then 

      if [[ "$dir5display" = "$dir1display" ]]; then
             dirdisp="$dirdisplay1"
      fi

      if [[ "$dir5display" = "$dir2display" ]]; then
             dirdisp="$dirdisplay2"
      fi

      if [[ "$dir5display" = "$dir3display" ]]; then
             dirdisp="$dirdisplay3"
      fi

      if [[ "$dir5display" = "$dir4display" ]]; then
             dirdisp="$dirdisplay4"
      fi
fi

# DEFAULT DIR 5 DISPLAY
if [[ "$controldir" = "$dir5display" ]]; then
       dirdisp="$dirdisplay5"  # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
        
  else
       dirdisp="$dirdisplayno" # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
fi 

# DEFAULT DIR 1  DISPLAY
if [[ "$controldir" = "$dir1display" ]]; then 
       dirdisp="$dirdisplay1"
fi

# DEFAULT DIR 2  DISPLAY
if [[ "$controldir" = "$dir2display" ]]; then 
       dirdisp="$dirdisplay2"
fi

# DEFAULT DIR 3  DISPLAY
if [[ "$controldir" = "$dir3display" ]]; then 
       dirdisp="$dirdisplay3"
fi

# DEFAULT DIR 4  DISPLAY
if [[ "$controldir" = "$dir4display" ]]; then 
       dirdisp="$dirdisplay4"  # if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
fi

################################################################################
##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################
########## blinking routine for display ##########

# blinking
downloadlist1=$(echo -e "\033[5mDOWNLOAD LIST\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking
downloadlist0=$(echo "DOWNLOAD LIST")

# blinking
dash1=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking
dash0=$(echo "-")

# if file exists goto then
if [[ -f "$pasteclip" ]]; then
      finalresult="$downloadlist1"  # if the file exists: blinking   DOWNLOAD LIST
      finalresult2="$dash1"  #                            blinking   -
  else
      finalresult="$downloadlist0"  # if the file doesn't exist: non blinking   DOWNLOAD LIST
      finalresult2="$dash0"  # if                                non blinking   -
fi

########## end blinking routine #################
#########################################################################################################################################################
# START Routine to find out if clipboard contents  =  The default download list or a user list - dash blink or not:  Set User List and Delete User List
#########################################################################################################################################################

# REFORMAT PASTECLIP VARIBLE FOR COMPARISON TO CONTROL VARIBLE
echo "$pasteclip" > ${base_dir}/videoinfox.c.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.c.tmp | tr "/" " " > ${base_dir}/videoinfox.c.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.c.tmp   # remove .c.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.c.tmp2 # remove horizontal whitespace from file an write
# REFORMATTED PASTECLIP
read -r ctmp2 < ${base_dir}/videoinfox.c.tmp2  # clipboard content with default list or user list.
                                                        # list name with full path: with slashes and spaces removed
# CONTROL VARIABLE
ctmpprefformat=""$HOME"/.config/videoinfox/videoinfox-dl-Default"
# REFORMAT CONTROL VARIABLE FOR COMPARISON TO PASTECLIP VARIBLE
echo "$ctmpprefformat" > ${base_dir}/videoinfox.dlname.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.dlname.tmp | tr "/" " " > ${base_dir}/videoinfox.dlname.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.dlname.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dlname.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE
read -r ctmp3 < ${base_dir}/videoinfox.dlname.tmp2  # default list name with full path: with slashes and spaces removed
if [[ -z "$pasteclip" ]]; then
        dashit2="$dash0"  # no blink dash for: Set User List and Delete User List

   else
   
        if [[ "$ctmp2" = "$ctmp3" ]]; then
                dashit2="$dash0"  # no blink dash for: Set User List and Delete User List

           else
                dashit2="$dash1"  #    blink dash for: Set User List and Delete User List
        fi
fi
# CONTROL VARIABLE 2  (clear Set User List filename)
read -r chkulistset < ${base_dir}/videoinfox.set-user-list
# REFORMAT CONTROL VARIABLE 2 FOR COMPARISON TO PASTECLIP VARIBLE
echo "$chkulistset" > ${base_dir}/videoinfox.chkulist.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.chkulist.tmp | tr "/" " " > ${base_dir}/videoinfox.chkulist.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.chkulist.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.chkulist.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE 2
read -r ctmp4 < ${base_dir}/videoinfox.chkulist.tmp2  # default list name with full path: with slashes and spaces removed
#  REMOVE TMP2 FILES
rm ${base_dir}/videoinfox.c.tmp2
rm ${base_dir}/videoinfox.dlname.tmp2 

#########################################################################################################################################################
# END Routine to find out if clipboard contents  =  The default download list or a user list - dash blink or not:  Set User List and Delete User List
#########################################################################################################################################################

clear
cat ${base_dir}/videoinfox.dowload.list  # display user created download lists recursively reachable fron current directory.
echo
echo "Default List:" 
cat ${base_dir}/videoinfox.dowload.list.default  # display default download list name with full path

#if [[ -z "$copymessage" ]]; then  # empty user list  (no user lists recursively reachable from the curent directory)
#       :

#  else  # at least 1 list  (1 or more user lists recursively reachable from the curent directory)        
      # echo
      # echo "Copy 1 above List to the the clipboard."
#fi

read -r ulistset < ${base_dir}/videoinfox.set-user-list  # set user list for videoinfox -u shortcut
echo
# CEAR USER SET LIST IF IT GETS DELETED OUTSIDE OF THE VIDEOINFOX INTERFACE
if [[ -f "$chkulistset" ]]; then
       :
   else  # if the user set list doesn't exist, clear the user set list.
       echo > ${base_dir}/videoinfox.set-user-list
       ctmp4=""
fi

if [[ ! -z "$ctmp4" ]]; then
         echo "User Set List:"   # display if there is at least one line
         echo "$ulistset"
         echo
fi

echo "Copy 1 above list to the the clipboard. Then press enter."
echo

echo "Directory:" "$PWD"
echo "Clipboard:" "$pasteclip"          #
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$der"" >>> DOWNLOAD LIST       Enter - Update Clipboard Display              "$dirdisp" - Default Dirs"
echo "___________________________________________________________________________________________________________________" 
echo
echo " d "$finalresult2" Download List     s "$dashit2" Set User List        k - Default List       m - Create Directory               q - Quit"
echo " v "$finalresult2" View List         c - Create User List     a "$dashit2" Add to Queue       x - Clear Clipboard"    
echo " l - View Logs         r "$dashit2" Delete User List     b - Download Queue                                        h - Help"
echo 
echo -en " Enter Option: "
read -r -n1 optiond
echo

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -z "$pasteclip" ]]; then
       echo
       echo " Clipboard is empty . . ."
       sleep .18
     
   else
       :
fi
}

while true; do
dwnlist
case $optiond in

# LOAD STORED DIRECTORIES
#read -r dir1 < ${base_dir}/videoinfo.tv-dir 2> /dev/null
#read -r dir2 < ${base_dir}/videoinfo.movies-dir 2> /dev/null
#read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null
#read -r dir4 < ${base_dir}/videoinfo.parent-dir 2> /dev/null
#read -r dir5 < ${base_dir}/videoinfo.dir-at-exit 2> /dev/null

1)
cd "$dir1"
;;
2)
cd "$dir2"
;;
3)
cd "$dirsaved"
;;

4)
cd "$dir4"
;;
5)
cd "$dir5"
;;
         
q)  # QUIT (DOWNLOAD LIST)
echo "$pasteclip3" | xclip -sel clip  # restore clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
break;;
x)  # CLEAR CLIPBOARD  (DOWNLOAD LIST)
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
;;
m)
##################################################################################################################################################
###########################   CREATE DIRECTORY  n   (DOWNLOAD LIST)   ############################################################################
##################################################################################################################################################

pasteclip2=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content   save to restore on option quit
echo "" | xclip -sel clip  # clearing the clipboard
function navtree {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -d "$pasteclip" ]]; then
      :

  else      
      echo "$pastetemp" | xclip -sel clip  # clearing out the clipboaed
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
     
fi
clear
# recursive list of directories for the user to copy one to the clipboard and press  c   to change to that directory
#### find "$PWD" -type d -iname "*" | sort -u 2>/dev/null

find "$PWD" -type d -iname "*" | sort -u > ${tmp_dir}/nt-list.tmp 2>/dev/null

# NUMBER THE LIST
sed '/./='  ${tmp_dir}/nt-list.tmp | sed '/./N; s/\n/ /' > ${tmp_dir}/nt-list-number.tmp 2>/dev/null

cat ${tmp_dir}/nt-list-number.tmp
# recursive number of directories found
ttotal=$(find  "$PWD" -type d -iname "*" 2>/dev/null | wc -l)   

notify-send "Videoinfox is done processing: Directory Tree" "Total Directories Found: "$ttotal" " # GUI Notification.

# recursive number of files found
#ttotalnum=$(find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) 2>/dev/null | wc -l)
##################################################################################
##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################## 

# DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

# DEFAULT DIR NUMBER 1 FORMAT
dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
# DEFAULT DIR NUMBER 2 FORMAT
dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
# DEFAULT DIR NUMBER 3 FORMAT
dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
# DEFAULT DIR NUMBER 4 FORMAT
dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
# DEFAULT DIR NUMBER 5 FORMAT
dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
# NO MATCH ALL LESS BOLD
dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
# FORMAT PWD NAME FOR COMPARISON
echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

# FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

# FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

# FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

# FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

# FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
# LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
# DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

if [[ "$controldir" = "$dir5display" ]]; then 

      if [[ "$dir5display" = "$dir1display" ]]; then
             dirdisp="$dirdisplay1"
      fi

      if [[ "$dir5display" = "$dir2display" ]]; then
             dirdisp="$dirdisplay2"
      fi

      if [[ "$dir5display" = "$dir3display" ]]; then
             dirdisp="$dirdisplay3"
      fi

      if [[ "$dir5display" = "$dir4display" ]]; then
             dirdisp="$dirdisplay4"
      fi
fi

# DEFAULT DIR 5 DISPLAY
if [[ "$controldir" = "$dir5display" ]]; then
       dirdisp="$dirdisplay5"  # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
        
  else
       dirdisp="$dirdisplayno" # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
fi 

# DEFAULT DIR 1  DISPLAY
if [[ "$controldir" = "$dir1display" ]]; then 
       dirdisp="$dirdisplay1"
fi

# DEFAULT DIR 2  DISPLAY
if [[ "$controldir" = "$dir2display" ]]; then 
       dirdisp="$dirdisplay2"
fi

# DEFAULT DIR 3  DISPLAY
if [[ "$controldir" = "$dir3display" ]]; then 
       dirdisp="$dirdisplay3"
fi

# DEFAULT DIR 4  DISPLAY
if [[ "$controldir" = "$dir4display" ]]; then 
       dirdisp="$dirdisplay4"  # if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
fi

################################################################################
##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################
########## blinking routines for display ##########

# not blinking Play Directory
playdir1=$(echo "Play Directory")
# blinking Play Directory
playdir2=$(echo -e "\033[5mPlay Directory\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking dash
dash0=$(echo "-")
# blinking dash
dash1=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")
# get file count of videos one directory deep for blinking   Play Directory
blinkit=$(find_supported_files --count)

# if find results are zero goto then
if [[ "$blinkit" = 0 ]]; then
      blinkit2="$playdir1"  # zero files. non bliking  Playdirectory
      bdash="$dash0"
  else
      blinkit2="$playdir2" # not zero files. blinking  Play Directory
      bdash="$dash1"
fi
# not blinking
changedir1=$(echo "Change Directory")
# blinking
changedir2=$(echo -e "\033[5mChange Directory\033m\033[0m\033[5m\033[5m\033[0m")

# if directory exists goto then
if [[ -d "$pasteclip" ]]; then
      changedir3="$changedir2"  # if the directory exists, blinking  Change Directory
  else
      changedir3="$changedir1"  # if the directory doesn't exist, non blinking  Change Directory
fi
########## end blinking routines ################## 
echo
echo "Treetop:" "$grabdirfornav2"
echo "Total Directories: "$ttotal" "
#echo "Total Video Files:" "$ttotalnum"                                                                                                            
echo
echo "Current Directory:" "$PWD"
#echo "Video Files:" "$blinkit"
#echo
#echo "Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$der"" >>> CREATE DIRECTORY                                                  "$dirdisp" - Default Dirs"
echo "___________________________________________________________________________________________________________________" 
echo
echo " c - "$changedir3"     m - Create Directory     n - Change Treetop                                     q - Quit"
echo " u - Up One Level"
echo " t - Treetop"
echo
echo -en " Enter Option: "
read -r -n1 option
echo
}
  
         while true
         do
         navtree
        case $option in
         
         q)  # QUIT
    ##############################     cd "$grabdirfornav2" &>/dev/null   # restore directory
         echo "" | xclip -sel clip  # clearing the clipboard
         pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
         break
         ;;
         1)  # CD DIRECTORY TO TV    
         cd "$dir1" 
         grabdirfornav2="$dir1"
         ;;
    
         2)  # CD DIRECTORY TO MOVIES
         grabdirfornav2="$dir2"
         cd "$dir2" 
         ;;

         3)  # CHANGE DIRECTORY TO DOWNLOADS
         grabdirfornav2="$dirsaved"
         cd "$dirsaved" 
         ;;
   
         4)  # CHANGE DIRECTORY TO EXTRA   
         grabdirfornav2="$dir4"
         cd "$dir4" 
         ;;

         5)  # CHANGE DIRECTORY TO LAST EXIT
         grabdirfornav2="$dir5"
         cd "$dir5" 
         ;;
       
       
         u)  # UP ONE LEVEL 
         if [[ "$grabdirfornav2" = "$PWD" ]]; then
               echo
               echo " At treetop. Can't go any higher . . ."
               sleep .50

           else
               cd .. &>/dev/null
         fi 
         ;;
         t)  # TREE TOP
         cd "$grabdirfornav2" &>/dev/null
         ;;          
         c)  # CHANGE DIRECTORY
# GETTING LINECOUNT
linecount=$(wc -l ${tmp_dir}/nt-list.tmp | cut -d' ' -f1)

echo
read -r -p " Enter line number to change directory: " linenumber  # waiting fot user input
if ! [[ "$linenumber" -eq "$linenumber" ]]; then  # IF ENTRY IS NOT A NUMBER
      :

  else  # ENTRY IS A NUMBER
if [[ $linenumber -gt $linecount ]]; then 
      echo
      echo " Number out of range . . ."
      sleep .9
  else

tail -n +"$linenumber" ${tmp_dir}/nt-list.tmp > ${tmp_dir}/nt-list.tmp2 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

read line < ${tmp_dir}/nt-list.tmp2

      cd "$line" 2> /dev/null
 
      IFS=$OLDIFS
  
      fi
      fi
;;        

 
         m)  # CREATE DIRECTORY  (CREATE DIRECTORY)
         echo
         echo " Enter name for new directory or enter with no entry to cancel . . ."
         echo
         read -r -p " Create Directory: " newdir  # waiting fot user input.

         direxist4="$PWD""/""$newdir"

         if [[ -z "$newdir" ]]; then
               echo
               echo " Nothing was entered . . ."
               sleep 1.2

           else
               if [[ -d "$direxist4" ]]; then
                     echo
                     echo " Directory already exists . . ."
                     sleep 1.2

                 else
                     mkdir "$newdir" 2> /dev/null
                     echo
                     echo " Directory Created:" "$PWD""/""$newdir"
                     sleep 1.2
           fi
         fi

         ;;

         
         ########################################################################################################################################
         n)  # CHANGE TREETOP (CREATE DIRECTORY)  ###############################################################################################
         ########################################################################################################################################

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo
echo " $ver >>> CHANGE TREETOP"
echo "___________________________________________________________________________________________________________________"
echo
echo " No quotations needed for paths with spaces. Case sensative."
echo 
echo " Enter directory or paste directory if in clipboard."
echo
read -r -p " " specifydir  # waiting fot user input - the directory you want to chang to 
    
    if [[ -z "$specifydir" ]]; then
               echo
               echo " Nothing was entered . . ."
               sleep .75
          else
              if [[ -d "$specifydir" ]]; then
                     echo
                     grabdirfornav2="$specifydir"
                     cd "$specifydir"   # change the directory
                     echo " Treetop changed to: $PWD"  # <pwd>  print current working directory to the screen
                     sleep 1.5                   
                else
                     echo
                     echo " No such directory . . ."
                     sleep 1.5                   
          fi
    fi       
echo

;;

         esac
         done
         ;;

a)  # ADD TO QUEUE (DOWNLOAD LIST)
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

ddlist=${base_dir}/videoinfox-dl-Default

if [[ -f "$pasteclip" ]]; then
      if [[ "$pasteclip" == "$ddlist" ]]; then
            :
        else
            echo "$pasteclip" >> ${base_dir}/videoinfox-download.queue
            echo
            echo " ""$pasteclip"
            echo
            echo " Download list added to queue . . ."
            echo "" | xclip -sel clip  # clearing out the clipboard
            sleep 1.7
      fi

  else
      :
fi

;;
    b)   # DOWNLOAD QUEUE  (DOWNLOAD LIST)

# SAVE CURRENT DIRECTORY FOR RESTORE ON FUNCTION
savethedir="$PWD"

function dwnque {

clear

if [[ -f ${base_dir}/videoinfox-download.queue ]]; then
      # REMOVE DUPLICATES
      cat -n ${base_dir}/videoinfox-download.queue | sort -uk2 | sort -n | cut -f2- > ${base_dir}/videoinfox-download.queue.tmp
      mv ${base_dir}/videoinfox-download.queue.tmp ${base_dir}/videoinfox-download.queue
      
      # REMOVE BLANK LINES
      squash ${base_dir}/videoinfox-download.queue
      
      cat ${base_dir}/videoinfox-download.queue

  else
      echo
      echo " Download queue empty . . ."
      echo
fi
      
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$der"" >>> DOWNLOAD QUEUE"        
echo "___________________________________________________________________________________________________________________"
echo
echo " b - Download Queue     d - Delete Queue                                                                  q - Quit"
echo 
echo -en " Enter Option: "
read -r -n1 optiondq
echo
}
while true; do
dwnque
case $optiondq in
        q)  # QUIT   (DOWNLOAD QUEUE)
        break ;;

      
        d)  # DELETE QUEUE LIST  (DOWNLOAD QUEUE)
        function menudelq {
   
        echo
        echo " Delete Download Queue?"
        echo
        echo " y - Yes     n - No"  
        echo 
        echo -en " Enter Option: "
        read -r -n1 optiondelq
        echo
        }

        while true
        do
      menudelq
      case $optiondelq in

      y)  # YES
        if [[ -f ${base_dir}/videoinfox-download.queue ]]; then
              rm ${base_dir}/videoinfox-download.queue 2> /dev/null
              echo
              echo " Download Queue Deleted . . ."
              sleep 1.7
          else
              echo
              echo " Download Queue Was Already Deleted . . ."
              sleep 1.7
        fi
        break
        ;;
        n)  # NO
        break;;

        *)
        
        esac
        done
        ;;
        b)  # DOWNLOAD QUEUE  (DOWNLOAD QUEUE)

# READ USER SET LIST FOR REMOVAL IF IT IS IN THE DOWNLOAD QUEUE
read usersetlist < ${base_dir}/videoinfox.set-user-list

#################################################
##########  START DOWNLOAD QUEUE LOOP  ########## 
#################################################

if [[ -f ${base_dir}/videoinfox-download.queue ]]; then

clear

# DOWNLOAD QUEUE FILE
input1=${base_dir}/videoinfox-download.queue
# LOOP 1 READ LINE BY LINE DOWNLOAD QUEUE LIST
while read -r line; do

input2="$line"

echo
echo 
echo -e "Processing Download List:" "\033[5m"$line"\033m\033[0m"

# REMOVE BLANK LINES IN CURRENT DOWNLOAD LIST
squash "$line"

# WRITE LINE TO TEMP FILE.  DOWNLOAD LIST WITH FULL PATH
echo "$line" > ${tmp_dir}/videoinfox-queue.tmp

# REMOVE FILE NAME FROM PATH AND WRITE FILE
sed -i 's%/[^/]*$%%' ${tmp_dir}/videoinfox-queue.tmp 

# READ FILE WHICH IS PATH ONLY
read -r abc < ${tmp_dir}/videoinfox-queue.tmp

# CHANGE TO READ PATH
cd "$abc"

# CREATE LOG FILE FOE CURRENT DOWNLOAD LIST 
logfile="$line".log  # tag  .log  onto the users Download List  */.videoinfox-dl*.log 
echo ""$ver" >>> DOWNLOAD LIST >>> Logfile:" "$line"".log" > "$logfile"  # create file
echo >> "$logfile"

# IF DOWNLOAD LIST = SET USER LIST THEN REMOVE
if [[ "$line" == "$usersetlist" ]]; then
      echo > ${base_dir}/videoinfox.set-user-list
  else
      :
fi
# LOOP 2 READ LINE BY LINE FROM CURRENT DOWNLOAD LIST
    while read -r line  
    do

    echo

    ${base_dir}/yt-dlp "$line"  # download url

    echo
    echo "Logging URL and Filename to:" "$logfile"

    # logging yt-dlp output
    echo "$line" >> "$logfile" 
    ${base_dir}/yt-dlp "$line" | tee >> "$logfile"
    echo >> "$logfile" 

    ############  REMOVE UNWANTED LOG INFO  ############# 
    sed -i '/\[youtube\]/d' "$logfile" &> /dev/null  # removing lines that start with  [youtube]
    sed -i '/\[info\]/d' "$logfile" &> /dev/null  # removing lines that start with  [info]
    sed -i 's/\[download\]//' "$logfile" &> /dev/null  # remove   [download]   from the end of the line.
    sed -i 's/has already been downloaded//' "$logfile" &> /dev/null  # remove   has already been downloaded   from the end of the line.
    sed -i -e 's/^[ \t]*//' "$logfile" &> /dev/null  # remove spaces at beginning of line.
    #####################################################    

    done < "$input2"

done < "$input1"

###############################################
##########  END DOWNLOAD QUEUE LOOP  ########## 
###############################################

echo
echo
echo -e "$der" "\033[5mdone processing download queue . . .\033m\033[0m"
echo
echo "Press enter to exit this screen"

notify-send "Videoinfox messsage: Done Processing Download Queue . . ."

read -p ""
echo "" | xclip -sel clip  # clearing out the clipboard

cd "$savethedir"  # RESTORE DIRECTORY
else
    :
fi
;;

esac
done
;;
c)  # CREATE USER LIST  <DOWNLOAD LIST>
echo
echo " If the name starts with any spaces they will be ignored. Spaces are fine after the first character."
echo
echo " The first character for the filename can be:  a dash -  or  an underscore _   or  a dot ."
echo
read -r -p " Create New List: " createulist  # waiting fot user input. grabbing new filename

if [[ -z "$createulist" ]]; then
      echo
      echo " Nothing was entered . . ."
      sleep .7

  else

      if [[ -f "videoinfox-dl""$createulist" ]]; then
            echo
            echo " File already exists . . ."
            sleep .75

        else

ulistname="$PWD/videoinfox-dl"$createulist""  # add user input to end of:  current directory/videoinfox-dl
echo > "$ulistname"  #  create user list with full path and filename
echo
echo " User List Created: "$ulistname""
echo
echo
sleep .75

      fi
fi
;; 
s)  # SET USER LIST  <DOWNLOAD LIST>
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

###########################################################################################################################################################
# START Routine to find out if clipboard contents  =  The default download list or a user list.  only a user list can:  Set User List and Delete User List
###########################################################################################################################################################

# REFORMAT PASTECLIP VARIBLE FOR COMPARISON TO CONTROL VARIBLE
echo "$pasteclip" > ${base_dir}/videoinfox.c.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.c.tmp | tr "/" " " > ${base_dir}/videoinfox.c.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.c.tmp   # remove .c.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.c.tmp2 # remove horizontal whitespace from file an write
# REFORMATTED PASTECLIP
read -r ctmp2 < ${base_dir}/videoinfox.c.tmp2  # clipboard content with default list or user list.
                                                        # list name with full path: with slashes and spaces removed
# CONTROL VARIABLE
ctmpprefformat=""$HOME"/.config/videoinfox/videoinfox-dl-Default"
# REFORMAT CONTROL VARIABLE FOR COMPARISON TO PASTECLIP VARIBLE
echo "$ctmpprefformat" > ${base_dir}/videoinfox.dlname.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.dlname.tmp | tr "/" " " > ${base_dir}/videoinfox.dlname.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.dlname.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dlname.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE
read -r ctmp3 < ${base_dir}/videoinfox.dlname.tmp2  # default list name with full path: with slashes and spaces removed
if [[ -z "$pasteclip" ]]; then
        :

   else
   
        if [[ "$ctmp2" = "$ctmp3" ]]; then
               echo 
               echo " The Default List can't be a User Set List. Only user created lists . . ."
               echo
               read -p " Press enter to Continue"

           else  # clipbaord = User List
                echo "$pasteclip" > ${base_dir}/videoinfox.set-user-list
                
                echo
                echo " ""$pasteclip"
                echo
                echo " User List Set for option: videoinfox -l"
                echo
                notify-send "Videoinfox Message: User List Set for option: videoinfox -l" ""$pasteclip"" # GUI Notification.

                read -p " Press enter to Continue"

                echo "" | xclip -sel clip  # clearing out the clipboard
                pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content 
   
        fi
fi
#  REMOVE TMP2 FILES
rm ${base_dir}/videoinfox.c.tmp2
rm ${base_dir}/videoinfox.dlname.tmp2

##########################################################################################################################################################
# END Routine to find out if clipboard contents  =  The default download list or a user list.  only a user list can:  Set User List and Delete User List
##########################################################################################################################################################

;;
r)  # DELETE USER LIST  <DOWNLOAD LIST>
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

###########################################################################################################################################################
# START Routine to find out if clipboard contents  =  The default download list or a user list.  only a user list can:  Set User List and Delete User List
###########################################################################################################################################################
# Also, check if the User List in the clipboard  =  Set User List  if it is, the set user list will be set to null
###########################################################################################################################################################

# REFORMAT PASTECLIP VARIBLE FOR COMPARISON TO CONTROL VARIBLE
echo "$pasteclip" > ${base_dir}/videoinfox.c.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.c.tmp | tr "/" " " > ${base_dir}/videoinfox.c.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.c.tmp   # remove .c.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.c.tmp2 # remove horizontal whitespace from file an write
# REFORMATTED PASTECLIP
read -r ctmp2 < ${base_dir}/videoinfox.c.tmp2  # clipboard content with default list or user list.
                                                        # list name with full path: with slashes and spaces removed
# CONTROL VARIABLE
ctmpprefformat=""$HOME"/.config/videoinfox/videoinfox-dl-Default"
# REFORMAT CONTROL VARIABLE FOR COMPARISON TO PASTECLIP VARIBLE
echo "$ctmpprefformat" > ${base_dir}/videoinfox.dlname.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.dlname.tmp | tr "/" " " > ${base_dir}/videoinfox.dlname.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.dlname.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dlname.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE
read -r ctmp3 < ${base_dir}/videoinfox.dlname.tmp2  # default list name with full path: with slashes and spaces removed

# CONTROL VARIABLE 2  (clear Set User List filename)
read -r chkulistset < ${base_dir}/videoinfox.set-user-list
# REFORMAT CONTROL VARIABLE 2 FOR COMPARISON TO PASTECLIP VARIBLE
echo "$chkulistset" > ${base_dir}/videoinfox.chkulist.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.chkulist.tmp | tr "/" " " > ${base_dir}/videoinfox.chkulist.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.chkulist.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.chkulist.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE 2
read -r ctmp4 < ${base_dir}/videoinfox.chkulist.tmp2  # default list name with full path: with slashes and spaces removed
if [[ -z "$pasteclip" ]]; then
        :

   else
   
        if [[ "$ctmp2" = "$ctmp3" ]]; then
                :

           else  # clipbaord = User List

                function menudul {
                clear
                echo
                echo " Delete User List:" "$pasteclip"
                echo
                echo " y - Yes     n - No"  
                echo 
                echo -en " Enter Option: "
                read -r -n1 option
                echo
                }

                while true
                do
              menudul
              case $option in

    
                y)  # YES
  
                if [[ "$ctmp2" = "$ctmp4" ]]; then
                        echo > ${base_dir}/videoinfox.set-user-list
                        echo "" | xclip -sel clip  # clearing out the clipboard
                        pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                   else
                        :
                fi                
                rm "$pasteclip" 2>/dev/null
                rm "$pasteclip".log 2>/dev/null

                echo
                echo " User List DELETED . . ."
                echo 
                sleep .75
                break;; 

        
                n)  # NO 
                echo
                echo " User List SAVED . . ."
                echo   
                sleep .75
                break;;
      
                *)
                
                
                esac
                done     
                   
        fi
fi
#  REMOVE TMP2 FILES
rm ${base_dir}/videoinfox.c.tmp2
rm ${base_dir}/videoinfox.dlname.tmp2
rm ${base_dir}/videoinfox.chkulist.tmp2

##########################################################################################################################################################
# END Routine to find out if clipboard contents  =  The default download list or a user list.  only a user list can:  Set User List and Delete User List
##########################################################################################################################################################
;;

k)  # DEFAULT LIST  <DOWNLOAD LIST>

echo "" | xclip -sel clip  # clearing out the clipboard

function ddefault {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
########## start blinking and error correcting routine #################

# blinking
addtodefault1=$(echo -e "\033[5mAdd to Default List\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking
addtodefault0=$(echo "Add to Default List")
checktheclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$checktheclip" = "http" ]]; then
      atd="$addtodefault1"
      
  else      
      atd="$addtodefault0"
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content      

fi

########## end blinking and error correcting routine #################

# # DEFAULT LIST - REMOVE DUPLICATES, BLANK LINES and ANY LINES NOT STARTING WITH HTTP
cat -n ${base_dir}/videoinfox-dl-Default | sort -uk2 | sort -n | cut -f2- > ${base_dir}/videoinfox-dl-Default.tmp
mv ${base_dir}/videoinfox-dl-Default.tmp ${base_dir}/videoinfox-dl-Default

squash ${base_dir}/videoinfox-dl-Default 2>/dev/null  # remove any blank lines in the list
sed -i '/http/!d' ${base_dir}/videoinfox-dl-Default  # remove all lines not starting with  http

clear
cat ${base_dir}/videoinfox-dl-Default  # display default download list
echo
echo "Copy 1 url to the clipboard then Add to Default List to add the url."
echo
echo "Directory:" "$PWD"
echo "Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$der"" >>> DEFAULT DOWNLOAD LIST                                     Enter - Update Clipboard Display"
echo "___________________________________________________________________________________________________________________" 
echo
echo " a - "$atd"     r - Remove Last Entry     c - Clear Default List     x - Clear Clipboard     q - Quit"
echo
echo -en " Enter Option: "
read -r -n1 optiondd
echo
}

while true; do
ddefault
case $optiondd in
         
q)  # QUIT  <DEFAULT LIST>
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
break;;
x) #  CLEAR CLIPBOARD  <DEFAULT LIST> 
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
;;
c)  # CLEAR DEFAULT LIST   <DEFAULT LIST>  
function yesorno {
echo
echo " Clear the Default List?"
echo
echo " y - Yes     n - No"  
echo 
echo -en " Enter Option: "
read -r -n1 optionyn
echo
}

while true; do
    yesorno
    case $optionyn in
    
    y) 
    # CREATING EMPTY DEFAULT DOWNLOAD LIST WITH LIST EMPTY MESSAGE
    echo > ${base_dir}/videoinfox-dl-Default
    echo "Default Download List Empty" >> ${base_dir}/videoinfox-dl-Default
 
    rm ${base_dir}/videoinfox-dl-Default.log 2> /dev/null    
 
    echo
    echo " Default List CLEARED . . ."
    echo 
    sleep .75
    break;; 
 
       
    n) 
    echo
    echo " Default List SAVED . . ."
    echo     
    sleep .75

    break;;

*)
          
esac
done
;;

a)  # ADD TO DEFAULT LIST  <DEFAULT LIST>

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
echo "$pasteclip" >> ${base_dir}/videoinfox-dl-Default
# notify-send "Videoinfox Message: Added to Default Download List." ""$pasteclip"" # GUI Notification.
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
;;
r)  # REMOVE LAST LINE IN THE DEFAULT DOWNLOAD LIST <DEFAULT LIST>

sed -i '$d' ${base_dir}/videoinfox-dl-Default
;;
*)

esac
done
;;
d)  # DOWNLOAD THE URL LIST <DOWNLOAD LIST>
clear

dirclip="$PWD"

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -f "$pasteclip" ]]; then

# check if   $pasteclip   contains   Default List   or   User Created list 
find ${base_dir}/videoinfox-dl-Default > ${base_dir}/videoinfox.default2
checkclip=$(cat ${base_dir}/videoinfox.default2)
# PROCESSING DEFAULT LIST
if [[ "$checkclip" = "$pasteclip" ]]; then 

read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null
cd "$dirsaved" # Change directory to default download directory

# DEFAULT LIST - REMOVE DUPLICATES, BLANK LINES and ANY LINES NOT STARTING WITH HTTP
cat -n ${base_dir}/videoinfox-dl-Default | sort -uk2 | sort -n | cut -f2- > ${base_dir}/videoinfox-dl-Default.tmp
mv ${base_dir}/videoinfox-dl-Default.tmp ${base_dir}/videoinfox-dl-Default
squash ${base_dir}/videoinfox-dl-Default 2>/dev/null  # remove any blank lines in the list
sed -i '/http/!d' ${base_dir}/videoinfox-dl-Default  # remove all lines not starting with  http
else # PROCESSING USER CREATED LIST

echo "$pasteclip" | sed 's|\(.*\)/.*|\1|' > ${base_dir}/videoinfox.userlist-tmp # remove last slash and filenname leaving only path
read -r grablistdir < ${base_dir}/videoinfox.userlist-tmp 2> /dev/null
cd "$grablistdir"  # change directory to list location

# USER CREATED LIST - REMOVE DUPLICATES, BLANK LINES and ANY LINES NOT STARTING WITH HTTP
cat -n "$pasteclip" | sort -uk2 | sort -n | cut -f2- > ${base_dir}/videoinfox-dl-userlist.tmp  # remove duplicates
mv ${base_dir}/videoinfox-dl-userlist.tmp "$pasteclip"
squash "$pasteclip" 2>/dev/null  # remove any blank lines in the list
sed -i '/http/!d' "$pasteclip" 2>/dev/null  # remove all lines not starting with  http
#########################################################################################################################################################
# START Routine to find out if clipboard content  =  set user list filename  if it does, the file will be cleared from the screen after list download
#########################################################################################################################################################

# REFORMAT PASTECLIP VARIBLE FOR COMPARISON TO CONTROL VARIBLE
echo "$pasteclip" > ${base_dir}/videoinfox.c.tmp  # write clipboard contents to to file
cat ${base_dir}/videoinfox.c.tmp | tr "/" " " > ${base_dir}/videoinfox.c.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.c.tmp   # remove .c.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.c.tmp2 # remove horizontal whitespace from file an write
# REFORMATTED PASTECLIP
read -r ctmp2 < ${base_dir}/videoinfox.c.tmp2  # filename in clipboard with full path: with slashes and spaces removed
              
# CONTROL VARIABLE
read -r getuserlist < ${base_dir}/videoinfox.set-user-list
# REFORMAT CONTROL VARIABLE FOR COMPARISON TO PASTECLIP VARIBLE
echo "$getuserlist" > ${base_dir}/videoinfox.checku.tmp  # write filename to file: ${base_dir}/videoinfox.checku.tmp 
cat ${base_dir}/videoinfox.checku.tmp | tr "/" " " > ${base_dir}/videoinfox.checku.tmp2  # remove all froward slashes / and write file
rm ${base_dir}/videoinfox.checku.tmp   # remove .dlname.tmp file
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.checku.tmp2  # remove horizontal whitespace from file an write
# REFORMATTED CONTROL VARIABLE
read -r ctmp5 < ${base_dir}/videoinfox.checku.tmp2  # set user list filename with full path: with slashes and spaces removed
if [[ "$ctmp2" = "$ctmp5" ]]; then
                echo > ${base_dir}/videoinfox.set-user-list
           
           else
                :
fi 
#  REMOVE TMP2 FILES
rm ${base_dir}/videoinfox.c.tmp2
rm ${base_dir}/videoinfox.checku.tmp2

fi
#########################################################################################################################################################
# END Routine to find out if clipboard content  =  set user list filename  if it does, the file will be cleared from the screen after list download
#########################################################################################################################################################
rm videoinfox-dl*~ &> /dev/null  # duplicate lists were showing up with   ~   added onto the filename

logfile="$pasteclip".log  # tag  .log  onto the users Download List  */.videoinfox-dl*.log 
echo ""$ver" >>> DOWNLOAD LIST >>> Logfile:" "$pasteclip"".log" > "$logfile"  # create file
echo >> "$logfile"

#justfile=$(echo "$pasteclip" | sed 's|.*/||')  # ended up not using. grabs filename minus path

input="$pasteclip"  # input file for download loop (clipboard contents)
################  DOWNLOAD LOOP START  ###################################################################################################################

while read -r line; do

echo

${base_dir}/yt-dlp "$line"  # download url
echo
echo "Logging URL and Filename to:" "$logfile" 
# logging yt-dlp output
echo "$line" >> "$logfile" 
${base_dir}/yt-dlp "$line" | tee >> "$logfile"
echo >> "$logfile" 

done < "$input"

################  DOWNLOAD LOOP END  #####################################################################################################################
############  REMOVE UNWANTED LOG INFO  ############# 

sed -i '/\[youtube\]/d' "$pasteclip".log &> /dev/null  # removing lines that start with  [youtube]
sed -i '/\[info\]/d' "$pasteclip".log &> /dev/null  # removing lines that start with  [info]
sed -i 's/\[download\]//' "$pasteclip".log &> /dev/null  # remove   [download]   from the end of the line.
sed -i 's/has already been downloaded//' "$pasteclip".log &> /dev/null  # remove   has already been downloaded   from the end of the line.
sed -i -e 's/^[ \t]*//' "$pasteclip".log &> /dev/null  # remove spaces at beginning of line.

#####################################################
echo
echo
echo -e "$der" "\033[5mdone processing download list . . .\033m\033[0m"
echo
echo "List:" "$pasteclip"  # display list filename with full path
echo "Log :" "$logfile"  # display log filename with full path
echo
echo "Press enter to exit this screen"

notify-send "Videoinfox messsage: Done Processing Download List . . ." "$pasteclip"

read -p ""
echo "" | xclip -sel clip  # clearing out the clipboard
else  # File didn't exist. clipboard cleared

echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
fi
cd "$dirclip"  # restore directory to before  Download List
;;
v)  # VIEW A DOWNLOAD LIST

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ -f "$pasteclip" ]]; then

clear
cat "$pasteclip" 2>/dev/null
echo
read -p "Up/Down arrows or mouse to scroll.  Press enter to quit"

else  # File didn't exist. clipboard cleared

echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
fi
;;
l)  # VIEW LOGS

echo "" | xclip -sel clip  # clearing out the clipboard clipboard

function viewlogs {

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
########## blinking routine for display ##########

# blinking
viewlog1=$(echo -e "\033[5mView Log\033m\033[0m\033[5m\033[5m\033[0m")

# not blinking
viewlog0=$(echo "View Log")

# if file exists goto then
if [[ -f "$pasteclip" ]]; then
      finalresult="$viewlog1"  # if the file exists, blinking   View Log

  else
      finalresult="$viewlog0"  # if the file doesn't exist, non blinking   View Log
fi
########## end blinking routine #################
clear
# find default download list and write to file.
find ${base_dir}/videoinfox-dl-Default.log > ${base_dir}/videoinfox.dowload.list.default.log 2> /dev/null

# find user created list logs 
find "$PWD" -type f \( -iname "videoinfox-dl*.log" \)  # find log files  */.videoinfox-dl*log
echo

cat ${base_dir}/videoinfox.dowload.list.default.log 

echo
echo "Copy 1 above log to the clipboard to view"
echo
echo "Directory:" "$PWD"
echo "Clipboard:" "$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " "$der" >>> DOWNLOAD LIST >>> VIEW LOGS                               Enter - Update Clipboard Display"
echo "___________________________________________________________________________________________________________________" 
echo
echo " l - "$finalresult"                                                                                             q - Quit"
echo
echo -en " Enter Option: "
read -r -n1 optionvl
echo
}

while true; do
viewlogs
case $optionvl in
         
q)  # QUIT
echo "$pastecliptemp" | xclip -sel clip  # restoring clipboard clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
break;;
l)  # VIEW LOG
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard contentclear

if [[ -f "$pasteclip" ]]; then

clear
cat "$pasteclip" 2>/dev/null
read -p "Up/Down arrows or mouse to scroll.  Press enter to quit"
echo "" | xclip -sel clip  # clearing out the clipboard clipboard

else
echo "" | xclip -sel clip  # clearing out the clipboard
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
fi

esac
done
;;
h) # DOWNLOAD LIST HELP
less ${base_dir}/videoinfox.download-list-help
;;

*)
;;

esac
done
;;
#######################################################################################################################################
########################   (PLAY ClIPBOARD) YT-DLP MENU   #############################################################################
#######################################################################################################################################

     p) 
     #  @PLAY CLIPBOARD - <VIEW DOWNLOADS>
          
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
     ################# grabdir="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi

   
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            echo > ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
                else
                    read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$ytdlplast")  " Duration:" $(ffmpeg -i "$ytdlplast" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
             :
         else     
             notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
             echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List File  
             ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdir"   # restore dir prior to entering yt-dlp menu              

  else

      if [[ -f "$pasteclip" ]]; then
      
      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard

      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

      echo " Played List Closed"
      
       else
            
           echo
           echo
           echo " No playable content in the clipboard . . ."
           sleep 1.2
       fi
fi

cd "$grabdir"
;;

  
#####################################################################################
     v)  # VIEW DOWNLOADS
##################################################################################### 

clipsave=$(xclip -o -selection clipboard 2> /dev/null)  # save clipboard content         

keepdir="$PWD"  # save dir for exit      
      function menuyt {  # LIST ALL VIDEO FILES RECURSIVELY IN THE DEFAULT DOWNLOAD DIRECTORY 
cd "$dirsaved"

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

grabclip=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

if [[ "$grabclip" = "http" ]]; then
      :

  else      
      if [[ -f "$pasteclip" ]]; then
            :
        else
            echo "" | xclip -sel clip  # clearing out the clipboaed
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      fi
fi

# below was the method i used for this functions before switching to find   
# echo " " > ${base_dir}/videoinfo.viewdownloads
# ls "$PWD/"*.mp4 >> ${base_dir}/videoinfo.viewdownloads
# ls "$PWD/"*.mkv >> ${base_dir}/videoinfo.viewdownloads
# ls "$PWD/"*.avi >> ${base_dir}/videoinfo.
# ls "$PWD/"*.webm >> ${base_dir}/videoinfo.viewdownloads
# ls "$PWD/"*.divx >> ${base_dir}/videoinfo.viewdownloads
# sed -i '/ls: cannot access/d' ${base_dir}/videoinfo.viewdownloads  # removing file type(s) not found errors (remove beinnging of line pattern)

# Find video files.
find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) > ${base_dir}/videoinfo.view-downloads

# CHECK FOR FILES FOR BLINKING DASH
istherefiles=$(find "$PWD" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) | wc -l)

# not blinking dash
vdash0=$(echo "-")
# blinking dash
vdash1=$(echo -e "\033[5m-\033m\033[0m\033[5m\033[5m\033[0m")

if [[ "$istherefiles" = 0 ]]; then
      vdash="$vdash0"
  
  else
      vdash="$vdash1"

fi

#tac ${base_dir}/videoinfo.viewdownloads >  ${base_dir}/videoinfo.viewdownloads.tmp
#mv ${base_dir}/videoinfo.viewdownloads.tmp ${base_dir}/videoinfo.viewdownloads

pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content                  
clear
#cat ${base_dir}/videoinfo.view-downloads

# SORT BACK INTO ORDER
sort -u ${base_dir}/videoinfo.view-downloads > ${base_dir}/videoinfo.view-downloads.tmp
mv ${base_dir}/videoinfo.view-downloads.tmp ${base_dir}/videoinfo.view-downloads 

#  REMOVE BLANK LINES
sed '/^$/d' ${base_dir}/videoinfo.view-downloads > ${tmp_dir}/videoinfo-view-downloads.tmp 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed 's/.*\///' ${tmp_dir}/videoinfo-view-downloads.tmp > ${tmp_dir}/videoinfo-number-view-downloads.tmp2 2>/dev/null

# CREATE NUMBERED lIST
sed '/./=' ${tmp_dir}/videoinfo-number-view-downloads.tmp2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfo-number-view-downloads.tmp 2>/dev/null
rm ${tmp_dir}/videoinfo-number-view-downloads.tmp2 2>/dev/null

cat ${tmp_dir}/videoinfo-number-view-downloads.tmp  # display numbered find results 
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
##################################################################################################################################################
#=================================================================================================================================================
#                           @CHECK TO SEE IF THE CLIPBOARD CONTENTS CONTAIN A URL OR A FILE AND ACT UPON THAT DISPLAY
#=================================================================================================================================================
##################################################################################################################################################

# the 2 lines of below code are creating two new variables for the following loop.
# 1st variable <$grabpaste>   <cut> is used to cut all characters after the 4th character from the variable. Only 4 chatacters are needed to look for <http>
# 2nd variable <$grabpaste2>  <cut> is used to cut all characters after the 1st character from the variable. Only 1 character is needed to look for </>  

# for main if loop - to look for <http>
grabpaste=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

# for nested if loop - to look for </>
grabpaste2=$(echo "$pasteclip" | cut -c-1)  # cut everything after the 1st character

# the following code checks to see if the clipbooard has a url in it by lookin for <http> from <$grabpaste>  
# If it is <http>, YT-DLP will get the clipboard. yt-dlp will check if its a valid link by trying to extract the name of the video file.
# If it isn't <http>  the ytdlp loop will be skipped

if [[ "$grabpaste" = "http" ]]; then
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir 2> /dev/null  # reding default download directory
      ytdlpconfirm=$(${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" 2> /dev/null)

            if [[ "$ytdlpconfirm" = "" ]]; then

                      echo "" | xclip -sel clip  # clearing out the clipboard
                      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

                           # Videoinfox v2.00________________________________________ Videoinfox v2.00_________________________________________
                           #________________x________________________________________ _________________________________________________________
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> VIEW DOWNLOADS"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " o "$vdash" Autoplay Line     d "$vdash" Play Directory    p - Play Clipboard                                           q - Quit"
                      echo " j "$vdash" Play Line"
                      echo " i "$vdash" Info"     
                      echo            

                  else 
                      echo
                      echo "YT-DLP Confirmed: "$ytdlpconfirm""
                      echo
                      echo "Download Directory: $dirsaved"  # dislpay default download directory
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo " "$der" >>> VIEW DOWNLOADS"
                      echo "___________________________________________________________________________________________________________________"
                      echo
                      echo -e " o "$vdash" Autoplay Line     d "$vdash" Play Directory     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                                          q - Quit"
                      echo " j "$vdash" Play Line"
                      echo " i "$vdash" Info"     
                      echo                                                                                  
            fi
  else

      if [[ -f "$pasteclip" ]]; then
            echo      
            echo "Valid file in clipboard"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> VIEW DOWNLOADS"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo -e " o "$vdash" Autoplay Line     d "$vdash" Play Directory     p - \033[5mPlay Clipboard\033m\033[0m\033[5m\033[5m\033[0m                                          q - Quit"
            echo " j "$vdash" Play Line"
            echo " i "$vdash" Info"
            echo                                                             

        else 

            echo "" | xclip -sel clip  # clearing out the clipboard
            pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

            echo "___________________________________________________________________________________________________________________"
            echo
            echo " "$der" >>> VIEW DOWNLOADS"
            echo "___________________________________________________________________________________________________________________"
            echo
            echo " o "$vdash" Autoplay Line     d "$vdash" Play Directory    p - Play Clipboard                                           q - Quit"
            echo " j "$vdash" Play Line"
            echo " i "$vdash" Info"     
            echo                                          
fi
fi

echo -en " Enter Option: "
read -r -n1 optionyt

}
        
              while true
              do
              menuyt
             case $optionyt in
              q)  # QUIT        
              cd "$keepdir"
              rm ${tmp_dir}/videoinfo-number-view-downloads.tmp 2> /dev/null
              rm ${tmp_dir}/videoinfo-view-downloads.tmp 2> /dev/null

              break;;

                            
              p)
 
          #  @PLAY CLIPBOARD - <VIEW DOWNLOADS>
          
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

if [[ "$grabpaste" = "http" ]]; then
      #  DOWNLOAD AND PLAY FILE if <$grabpaste> ONLY IF IT =  http        
   
      grabdir="$PWD"  # storing directory to restore at the end of this function
        
      #  DOWNLOAD LINK AND PLAY
      
      read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
      cd "$dirsaved"   # change to download directory
 
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      clear
    
      # make a backup copy of:   ${base_dir}/videoinfo.lastdownload   to restore on Play Clipboard with invalid url
      cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
   
      ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
      ${base_dir}/yt-dlp "$pasteclip"     
      
      # remove first dot and everything after it in filename. this was done because file names with dots before the extension were breking find results
      sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

      # remove first [ and everything after it in filename. this was done because file names with [ 
      sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

      # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
      mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
      
      if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
             # make a backup copy of:   ${base_dir}/videoinfo.lastdownload to restore on Play Clipboard with invalid url
             cp ${base_dir}/videoinfo.lastdownload ${base_dir}/videoinfo.lastdownload.bak
         else
             :
      fi
      read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt
      read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download 
             
      ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))  # finding the file to play

      echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file

   
      # IF THERE ARE IDENTICAL FILENAMES WITH DIFFERENT FILE EXTENSIONS FIND WILL PRODUCE MORE THAN ONE RESULT      
      correcterror=$(wc -l ${base_dir}/videoinfo.find-last-download | cut -d' ' -f1)  # getting line count.
          
             if [[ "$correcterror" -gt 1 ]]; then                
                     if [[ "$lastdownload" == "$lastdownloadbak" ]]; then
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                     
                        else
                            echo > ${base_dir}/videoinfo.find-last-download
                            read -r ytdlplast < ${base_dir}/videoinfo.find-last-download
                     fi
                               
             else
                  read -r ytdlplast < ${base_dir}/videoinfo.find-last-download      
                                     
             fi      

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY LAST DOWNLOAD"
      echo
      echo " [PLAY]> "$ytdlplast""
      echo "___________________________________________________________________________________________________________________"         
      echo
              
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$ytdlplast")  " Duration:" $(ffmpeg -i "$ytdlplast" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      if [[ -z "$ytdlplast" ]]; then
             :
         else     
             notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
             echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List File  
             ffplay -fs -autoexit &> /dev/null "$ytdlplast"  
      fi 
      
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
      
      cd "$grabdir"   # restore dir prior to entering yt-dlp menu              

  else
      
      if [[ -f "$pasteclip" ]]; then

      #  PLAY FILE if <$grabpaste> WAS ANYTHING BUT <HTTP> 
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> PLAY CLIPBOARD" 
      echo
      echo " [PLAY]> "$pasteclip" "
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      #read -p " Press enter to Continue"
      
       # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$pasteclip" |  awk -F '/' '{print $NF}')  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"
     
      echo "$pasteclip" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$pasteclip" 2>/dev/null  # play video in clipboard
      echo "" | xclip -sel clip  # clearing out the clipboard
      pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

      echo " Played List Closed"
 
        else
            
           echo
           echo
           echo " No playable content in the clipboard . . ."
           sleep 1.2
      fi 
fi

cd "$grabdir"
;;  
              i)  # INFO - <VIEW DOWNLOADS>
if [[ "$istherefiles" = 0 ]]; then
      echo
      echo
      echo " No video files in the current directory . . ."
      sleep 1

  else
 
      if [[ -f "$pasteclip" ]]; then
            pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
            echo
            echo
            echo " ""$pasteclip"
            echo  

echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip")  " Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

            echo
            read -r -p " Press enter to Continue" 

        else
            if [[ -f ${tmp_dir}/videoinfo-view-downloads.tmp ]]; then
              echo
              echo
              read -r -p " Enter line number to get info: " linenumber  # waiting fot user input

             # create file moving selected line number to the top
             tail -n +"$linenumber" ${tmp_dir}/videoinfo-view-downloads.tmp > ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp 2>/dev/null
      
             # read first line of file for play
             read playnumber < ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp

                 if ! [[ -z "$playnumber" ]]; then
                       #echo
                       echo
                       echo "$playnumber"
                       echo
           
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$playnumber")  " Duration:" $(ffmpeg -i "$playnumber" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height & duration

                       echo
                       read -r -p " Press enter to Continue" 
                       rm ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp 2>/dev/null

                 fi

            fi

      fi

  fi
;;
###### Check this area.  pulled possible misplaced code. test playclipboard
         ########################################################################################################################################
         d)  # (@PLAY DIRECTORY) VIEW DOWNLOADS  ################################################################################################
         ########################################################################################################################################

# WRITING VIDEO FILE LIST TO FILE: /.config/videoinfox/tmp/videoinfo.nt-play-directory-apa 
find_supported_files > ${tmp_dir}/videoinfox.navtree-play-directory-apa

#  CHECK FOR AT LEAST ONE LINE THAT STARTS WITH A SLASH /
atleastone=$(grep '^/' ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null | wc -l)

#  IF THE NUMBER DOESN"T = 0  THEN PROCESS AUTO PLAY OF PLAYED LIST
if (( atleastone == 0 )); then
    rm ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null
    rm ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null
    rm ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
    rm ${tmp_dir}/videoinfox.navtree-play-directory-apa-work 2>/dev/null    
fi

#  ASSIGN PLAYED LIST TO VARIABLE: $moddedplayedlist 
moddedplayedlist="$HOME""/.config/videoinfox/tmp/videoinfox.navtree-play-directory-apa"

#  PLAYED LIST INPUT FOR LOOP
input="$moddedplayedlist"  

#  CREATE TEMP FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfox.navtree-play-directory-apa2

#  #  START WRITING
while read -r line; do
    if [[ -f "${line}" ]]; then # ONLY WRITE LINE TO FILE IF IT IS A VALID PATH AND FILE
            printf -- '%s\n' "$line" >> "${tmp_dir}/videoinfox.navtree-play-directory-apa2"
    fi
done < "${moddedplayedlist}"
#  DONE WRITING ONLY VALID FILES

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
mv ${tmp_dir}/videoinfox.navtree-play-directory-apa2 ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

#  CREATE FILE NEEDED FOR LOOP 
echo > ${tmp_dir}/videoinfox.navtree-play-directory-apa2  

#  START WRITING FILENAMES TO LIST THAT END IN:  .mp4  .webm  .mkv  .avi  .divx
write_supported_list "${moddedplayedlist}" "${tmp_dir}/videoinfox.navtree-play-directory-apa2"

#  REMOVE BLANK LINES
squash ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null

#  MOVE apa2 BACK TO apa
cp ${tmp_dir}/videoinfox.navtree-play-directory-apa2 ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

# REMOVE PATH ONLY LEAVING FILENAME
sed -i 's/.*\///' ${tmp_dir}/videoinfox.navtree-play-directory-apa2

# NUMBER THE LIST
sed '/./='  ${tmp_dir}/videoinfox.navtree-play-directory-apa2 | sed '/./N; s/\n/ /' > ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null


################clear

if [[ -f ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list ]]; then
        cat ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
   else
       echo
       echo
       echo " No video files in the current directory . . ."
       sleep 1.7
fi
linenumber=1

tail -n +"$linenumber" ${tmp_dir}/videoinfox.navtree-play-directory-apa > ${tmp_dir}/videoinfox.navtree-play-directory-apa.tmp 2>/dev/null
mv ${tmp_dir}/videoinfox.navtree-play-directory-apa.tmp ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null); do
    clear
    echo
    echo "___________________________________________________________________________________________________________________"
    echo
    echo " ""$der"" >>> VIEW DOWNLOADS >>> PLAY DIRECTORY" 
    echo
    echo " [PLAY]>" "$line"
    echo "___________________________________________________________________________________________________________________"
    echo

    echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
    
    echo
    echo
    echo " Video Player Controls:"
    echo                             
    echo " - Fullscreen Toggle: f"
    echo
    echo " - Play/Pause Toggle: space bar"
    echo
    echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
    echo
    echo " - Quit: q"      
    echo -e "\n"

    ffplay -fs -autoexit "$line" 2> /dev/null

    echo " To bypass the 3 second wait press enter with no entry"
    echo
    echo -e "\033[5m 3 seconds remaining to quit Played List Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
    echo 
    read -t 3 -p " Press any key then press enter to quit : " playdir
           
    # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
    if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
            break                                                   # if enter is pressed without any input the next video will play
    fi
done
 
IFS=$OLDIFS

rm ${tmp_dir}/videoinfox.navtree-play-directory-apa 2>/dev/null
rm ${tmp_dir}/videoinfox.navtree-play-directory-apa2 2>/dev/null
rm ${tmp_dir}/videoinfox.numbered-navtree-play-directory-list 2>/dev/null
rm ${tmp_dir}/videoinfox.navtree-play-directory-apa-work 2>/dev/null 

;;           
              o)
##################################################################################################################################################
###########################   AUTOPLAY LINE  o   <VIEW DOWNLOADS>  ###############################################################################
##################################################################################################################################################
if [[ "$istherefiles" = 0 ]]; then
      echo
      echo
      echo " No video files in the current directory . . ."
      sleep 1

  else
if [[ -f ${tmp_dir}/videoinfo-view-downloads.tmp ]]; then

echo
echo
read -r -p " Autoplay Line: " linenumber  # waiting fot user input

tail -n +"$linenumber" ${tmp_dir}/videoinfo-view-downloads.tmp > ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp 2>/dev/null
input="$HOME""/.config/videoinfox/tmp/videoinfo-view-downloads-autoplay.tmp"

OLDIFS=$IFS
IFS=$'\n'

for line in $(cat "$input" 2>/dev/null)
 do
      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> SEARCH RESULTS >>> AUTOPLAY LINE" 
      echo
      echo " [PLAY]>" "$line"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$line")  " Duration:" $(ffmpeg -i "$line" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
      
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"

      ffplay -fs -autoexit "$line" 2> /dev/null

      echo " To bypass the 3 second wait press enter with no entry"
      echo
      echo -e "\033[5m 3 seconds remaining to quit Autoplay\033m\033[0m\033[5m\033[5m\033[0m"      
      echo 
      read -t 3 -p " Press any key then press enter to quit : " playdir
           
           # option te escape loop everytime ffplay closes               # read will timeout for 3 seconds    
           if [[ $playdir ]]; then                                                        # if no input is entered within 3 seconds the next video will play
                 break                                                   # if enter is pressed without any input the next video will play
           fi
done
 
rm ${tmp_dir}/videoinfo-view-downloads-autoplay.tmp 2> /dev/null
IFS=$OLDIFS

else
    echo
    echo
    echo " Select Show All or use Find to acess this feature . . ."
    sleep 1.7
fi

fi

;;
              j)
##################################################################################################################################################
###########################   PLAY LINE  j   <VIEW DOWNLOADS>  ###################################################################################
##################################################################################################################################################

if [[ "$istherefiles" = 0 ]]; then
      echo
      echo
      echo " No video files in the current directory . . ."
      sleep 1

  else
if [[ -f ${tmp_dir}/videoinfo-view-downloads.tmp ]]; then
      echo
      echo
      read -r -p " Play Line: " linenumber  # waiting fot user input

      # create file moving selected line number to the top
      tail -n +"$linenumber" ${tmp_dir}/videoinfo-view-downloads.tmp > ${tmp_dir}/videoinfo-view-downloads-playnumber.tmp 2>/dev/null
      
      # read first line of file for play
      read playnumber < ${tmp_dir}/videoinfo-view-downloads-playnumber.tmp

      if [[ -z "$playnumber" ]]; then
              :

          else

      clear
      echo
      echo "___________________________________________________________________________________________________________________"
      echo
      echo " ""$der"" >>> SEARCH RESULTS >>> PLAY LINE" 
      echo
      echo " [PLAY]>" "$playnumber"
      echo "___________________________________________________________________________________________________________________"
      echo

      echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$playnumber")  " Duration:" $(ffmpeg -i "$playnumber" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height & duration
      echo
      echo
      echo " Video Player Controls:"
      echo                             
      echo " - Fullscreen Toggle: f"
      echo
      echo " - Play/Pause Toggle: space bar"
      echo
      echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
      echo
      echo " - Quit: q"      
      echo -e "\n"
      echo " This screen will exit when the video player is closed."
      echo
      
      # video filename with full path <$pasteclip> strip from the bgininning of line to the last slash leaving only the filename <$getfilenameonly>
      getfilenameonly=$(echo "$playnumber" |  awk -F '/' '{print $NF}')  
  
      notify-send "Videoinfox messsage: Playing . . ." "$getfilenameonly"      

      echo "$playnumber" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to Played List file
      ffplay -fs -autoexit "$playnumber" 2>/dev/null  # play video
      rm ${tmp_dir}/videoinfo-view-downloads-playnumber.tmp 2>/dev/null

     fi

else
    echo
    echo
    echo " Select Show All or use Find to acess this feature . . ."
    sleep 1.7

fi

fi

;;
                *)

                esac
                done  
                
              ;;
              s)  # DOWNLOAD VIDEO PLAY, THEN DELETE ON VIDEO PLAYER CLOSE 
              
              grabdir="$PWD"

              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"   # change to download directory              

              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
              
              grabpaste3=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

              if [[ "$grabpaste3" = "http" ]]; then
         
              clear
              ${base_dir}/yt-dlp "$pasteclip" -o "$dirsaved"/download.tmp  # downloading temporary video
              notify-send "Videoinfox messsage: YT-DLP is done downloading . . ." "$pasteclip" 

              clear
              echo
              echo "___________________________________________________________________________________________________________________"
              echo
              echo " ""$der"" >>> YT-DLP MENU >>> Play Video >>> Self Destruct"
              echo
              echo " [PLAY]> ""$pasteclip"""
              echo "___________________________________________________________________________________________________________________"         
              echo
              echo
              echo " Video Player Controls:"
              echo                             
              echo " - Fullscreen Toggle: f"
              echo
              echo " - Play/Pause Toggle: space bar"
              echo
              echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
              echo
              echo " - Quit: q"      
              echo -e "\n"
              echo " This screen will exit when the video player is closed."
              echo
              
              ffplay -fs -autoexit &> /dev/null "$dirsaved"/download.tmp*  # play temporary video
              rm "$dirsaved"/download.tmp*  # on player close, delete temporary video
              echo "" | xclip -sel clip  # clearing out the clipboard
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
             
              else 
                    echo
                    echo
                    echo " Clipboard is empty or contained invalid video url . . ."
                    sleep 1
              fi

              cd "$grabdir" # restore dir
              ;; 
              l)  # play last download
               
              grabdir="$PWD"  # storing directory to restore at the end of this function
               
              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"   # change to download directory

                 if [[ -s ${base_dir}/videoinfo.lastdownload ]]; then
                        read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download attempt         
                        ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownload*" \))
                        echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file
                        read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file

                    else
                        read -r lastdownloadbak < ${base_dir}/videoinfo.lastdownload.bak  # reading last successful download
                        ylast=$(find "$PWD" -maxdepth 1 -type f \( -iname "$lastdownloadbak*" \))
                        echo "$ylast" > ${base_dir}/videoinfo.find-last-download  # write find result to file
                        read -r ytdlplast < ${base_dir}/videoinfo.find-last-download  # read first find result from file
                 fi   
              clear
              echo
              echo "___________________________________________________________________________________________________________________"
              echo
              echo " ""$der"" >>> PLAY LAST DOWNLOAD"
              echo
              echo " [PLAY]> ""$ytdlplast"""
              echo "___________________________________________________________________________________________________________________"         
              echo
              
echo " "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$ytdlplast")  " Duration:" $(ffmpeg -i "$ytdlplast" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration

              echo
              echo " Video Player Controls:"
              echo                             
              echo " - Fullscreen Toggle: f"
              echo
              echo " - Play/Pause Toggle: space bar"
              echo
              echo " - Back/Fwd: Left/Right Arrows (tap or hold down)"
              echo
              echo " - Quit: q"      
              echo -e "\n"
              echo " This screen will exit when the video player is closed."
              echo
         
              notify-send "Videoinfox messsage: Playing last yt-dlp download . . ." "Play: $lastdownload"
                       
              echo "$ytdlplast" >> ${base_dir}/videoinfo.playedlist  # write clipboard content to file  
              ffplay -fs -autoexit &> /dev/null "$ytdlplast"
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
              cd "$grabdir"   # restore dir prior to entering yt-dlp menu
              ;;  
              d)  # DOWNLOAD DEFAULT
              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"  # change to download directory
 
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content              
#!!!
              grabpaste3=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

              if [[ "$grabpaste3" = "http" ]]; then
                  
              clear
      
              ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload 
              ${base_dir}/yt-dlp "$pasteclip"     
      
              # remove first dot and everything after it in filename. file names with dots before the extension were breking find results
              sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

              # remove first [ and everything after it in filename. this was done because file names with [ 
              sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

              # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
              mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
      
              read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download video file
              
              notify-send "Videoinfox messsage: YT-DLP done downloading . . ." "$lastdownload"
              
              echo "" | xclip -sel clip  # clearing out the clipboard
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

              
                else 
                    echo
                    echo
                    echo " Clipboard is empty or contained invalid video url . . ."
                    sleep 1
              fi
              
              cd "$grabdir"
              ;;
              c)  # DOWNLOAD CHOOSE
              read -r dirsaved < ${base_dir}/videoinfo.yt-download-dir  # reading download directory 
              cd "$dirsaved"   # change to download directory

              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content

              grabpaste3=$(echo "$pasteclip" | cut -c-4)   # cut everything after the 4th character

              if [[ "$grabpaste3" = "http" ]]; then
              
              clear
              echo
              echo
              
              # <yt-dlp> gets the filename minus the extension. this is done becuase the user can pick different video file types to download.
              ${base_dir}/yt-dlp --get-filename -o "%(title)s" "$pasteclip" > ${base_dir}/videoinfo.lastdownload
 
              # <yt-dlp> giving options for quality and file type to download
              ${base_dir}/yt-dlp -F "$pasteclip"
              
              echo
              echo
              echo "Find what video quality and format you want. (Code on far left)"
              read -r -p "Enter that Code and Press enter : " svrcode
              echo
              clear
              ${base_dir}/yt-dlp -f "$svrcode" "$pasteclip"

              # remove first dot and everything after it in filename. file names with dots before the extension were breking find results
              sed "s/\..*//" ${base_dir}/videoinfo.lastdownload > ${base_dir}/videoinfo.lastdownload.work

              # remove first [ and everything after it in filename. this was done because file names with [ 
              sed -i "s/\[.*//" ${base_dir}/videoinfo.lastdownload.work

              # rename videoinfo.lastdownload.work to videoinfox/videoinfo.lastdownload
              mv ${base_dir}/videoinfo.lastdownload.work ${base_dir}/videoinfo.lastdownload
              
              read -r lastdownload < ${base_dir}/videoinfo.lastdownload  # reading last download video file
              notify-send "Videoinfox messsage: YT-DLP done downloading . . ." "$lastdownload"              
              
              echo "" | xclip -sel clip  # clearing out the clipboard
              pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
              
              else 
                    echo
                    echo
                    echo " Clipboard is empty or contained invalid video url . . ."
                    sleep 1
              fi
              
              cd "$grabdir"
              ;; 

*)

 esac
 done

fi
################################################## cd "$grabdir"   # restore dir prior to entering yt-dlp menu
;; 

##################################################################################################################################################
m)  # MORE OPTIONS   #############################################################################################################################
##################################################################################################################################################

menu() {

##################################################################################
##########  START   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################## 

# DIRECTORY SELECTED IS NORMAL TEXT AND THE OTHER 4 ARE LESS BOLD. 

# DEFAULT DIR NUMBER 1 FORMAT
dirdisplay1=$(echo -e "1\033[2m 2 3 4 5\033[0m")
# DEFAULT DIR NUMBER 2 FORMAT
dirdisplay2=$(echo -e "\033[2m1 \033[0m2 \033[2m3 4 5\033[0m") 
# DEFAULT DIR NUMBER 3 FORMAT
dirdisplay3=$(echo -e "\033[2m1 2 \033[0m3 \033[2m4 5\033[0m")
# DEFAULT DIR NUMBER 4 FORMAT
dirdisplay4=$(echo -e "\033[2m1 2 3 \033[0m4 \033[2m5\033[0m")
# DEFAULT DIR NUMBER 5 FORMAT
dirdisplay5=$(echo -e "\033[2m1 2 3 4 \033[0m5\033[0m")
# NO MATCH ALL LESS BOLD
dirdisplayno=$(echo -e "\033[2m1 2 3 4 5\033[0m")
# FORMAT PWD NAME FOR COMPARISON
echo "$PWD" > ${base_dir}/videoinfox.pwd.tmp  # write PWD to a tmp file: videoinfox.pwd.tmp
cat ${base_dir}/videoinfox.pwd.tmp | tr "/" " " > ${base_dir}/videoinfox.pwd  # remove all froward slashes / write file: videoinfox.pwd
rm  ${base_dir}/videoinfox.pwd.tmp  # remove tmp file: videoinfox.pwd.tmp
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.pwd  # remove horizontal whitespace write file: videoinfox.pwd

# FORMAT DEFAULT DIR 1 NAME FOR COMPARISON
echo "$dir1" > ${base_dir}/videoinfox.dir1.tmp  # write dir 1 to a tmp file: videoinfox.dir1.tmp
cat ${base_dir}/videoinfox.dir1.tmp | tr "/" " " > ${base_dir}/videoinfox.dir1  # remove all froward slashes / write file: videoinfox.dir1
rm ${base_dir}/videoinfox.dir1.tmp  # remove tmp file: videoinfox.dir1.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir1  # remove horizontal whitespace write file: videoinfox.dir1

# FORMAT DEFAULT DIR 2 NAME FOR COMPARISON
echo "$dir2" > ${base_dir}/videoinfox.dir2.tmp  # write dir 2 to a tmp file: videoinfox.dir2.tmp
cat ${base_dir}/videoinfox.dir2.tmp | tr "/" " " > ${base_dir}/videoinfox.dir2  # remove all froward slashes / write file: videoinfox.dir2
rm ${base_dir}/videoinfox.dir2.tmp   # remove tmp file: videoinfox.dir2.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir2 # remove horizontal whitespace write file: videoinfox.dir2

# FORMAT DEFAULT DIR 3 NAME FOR COMPARISON
echo "$dirsaved" > ${base_dir}/videoinfox.dir3.tmp  # write dir 3 to a tmp file: videoinfox.dir3.tmp
cat ${base_dir}/videoinfox.dir3.tmp | tr "/" " " > ${base_dir}/videoinfox.dir3  # remove all froward slashes / write file: videoinfox.dir3
rm ${base_dir}/videoinfox.dir3.tmp   # remove tmp file: videoinfox.dir3.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir3 # remove horizontal whitespace write file: videoinfox.dir3

# FORMAT DEFAULT DIR 4 NAME FOR COMPARISON
echo "$dir4" > ${base_dir}/videoinfox.dir4.tmp  # write dir 4 to a tmp file: videoinfox.dir4.tmp
cat ${base_dir}/videoinfox.dir4.tmp | tr "/" " " > ${base_dir}/videoinfox.dir4  # remove all froward slashes / write file: videoinfox.dir4
rm ${base_dir}/videoinfox.dir4.tmp   # remove tmp file: videoinfox.dir4.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir4 # remove horizontal whitespace write file: videoinfox.dir4

# FORMAT DEFAULT DIR 5 NAME FOR COMPARISON
echo "$dir5" > ${base_dir}/videoinfox.dir5.tmp  # write dir 5 to a tmp file: videoinfox.dir5.tmp
cat ${base_dir}/videoinfox.dir5.tmp | tr "/" " " > ${base_dir}/videoinfox.dir5  # remove all froward slashes / write file: videoinfox.dir5
rm ${base_dir}/videoinfox.dir5.tmp   # remove tmp file: videoinfox.dir5.tmp 
sed -i 's/[[:blank:]]//g' ${base_dir}/videoinfox.dir5 # remove horizontal whitespace write file: videoinfox.dir5
# LOAD EDITED PWD AND DEFAULT DIRECTORY NAMES FOR BELOW  IF LOOPS   (all frorward slashes / and white spaces removed from the below directory names)

read -r controldir < ${base_dir}/videoinfox.pwd    # load reformatted current directory name 
read -r dir1display < ${base_dir}/videoinfox.dir1  # load reformatted default directory 1 name
read -r dir2display < ${base_dir}/videoinfox.dir2  # load reformatted default directory 2 name
read -r dir3display < ${base_dir}/videoinfox.dir3  # load reformatted default directory 3 name
read -r dir4display < ${base_dir}/videoinfox.dir4  # load reformatted default directory 4 name
read -r dir5display < ${base_dir}/videoinfox.dir5  # load reformatted default directory 5 name
# DEFAULT DIR 5  DISPLAY     IF DIRECTORY ON EXIT  =  DEFAULT DIRECTORIES 1-4 then Display that directory number.

if [[ "$controldir" = "$dir5display" ]]; then 

      if [[ "$dir5display" = "$dir1display" ]]; then
             dirdisp="$dirdisplay1"
      fi

      if [[ "$dir5display" = "$dir2display" ]]; then
             dirdisp="$dirdisplay2"
      fi

      if [[ "$dir5display" = "$dir3display" ]]; then
             dirdisp="$dirdisplay3"
      fi

      if [[ "$dir5display" = "$dir4display" ]]; then
             dirdisp="$dirdisplay4"
      fi
fi

# DEFAULT DIR 5 DISPLAY
if [[ "$controldir" = "$dir5display" ]]; then
       dirdisp="$dirdisplay5"  # if directory is changed to  Default Dir 5 :  The number 5 is normal text and the other 4 are less bold.
  else
       dirdisp="$dirdisplayno" # if directory doesn't match  Default Dirs 1-5 : All 5 numbers are less bold.  
fi 

# DEFAULT DIR 1  DISPLAY
if [[ "$controldir" = "$dir1display" ]]; then 
       dirdisp="$dirdisplay1"
fi

# DEFAULT DIR 2  DISPLAY
if [[ "$controldir" = "$dir2display" ]]; then 
       dirdisp="$dirdisplay2"
fi

# DEFAULT DIR 3  DISPLAY
if [[ "$controldir" = "$dir3display" ]]; then 
       dirdisp="$dirdisplay3"
fi

# DEFAULT DIR 4  DISPLAY
if [[ "$controldir" = "$dir4display" ]]; then 
       dirdisp="$dirdisplay4"  # if directory is changed to  Default Dir 4 :  The number 4 is normal text and the other 4 are less bold.
fi

################################################################################
##########  END   1 2 3 4 5 - DEFAULT DIRS   DISPLAY ROUTINE  ##################
################################################################################
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"                                                                 #
echo "___________________________________________________________________________________________________________________"
echo
echo " $der >>> MORE OPTIONS                                                      "$dirdisp" - Default Dirs"
echo "___________________________________________________________________________________________________________________"
echo
echo " c - Change Directory     n - Video Count        v - Video Info                                           q - Quit"                     
echo " f - Find Directory       d - Video Duration"
echo " l - List Directory"
echo
echo -en " Enter Option: "
read -r -n1 option
}

  
while true; do
    menu
    case $option in
q)  # QUIT - <HOME> 
break ;;

1) # CD DIRECTORY TO TV    
cd "$dir1" 
;;

    
2)  # CD DIRECTORY TO MOVIES
cd "$dir2" 
;;
3)  # CHANGE DIRECTORY TO DOWNLOADS
cd "$dirsaved" 
;;
4)  # CHANGE DIRECTORY TO EXTRA   
cd "$dir4" 
;;
5)  # CHANGE DIRECTORY TO LAST EXIT
cd "$dir5" 
;;

l)  # LIST DIRECTORY
##################################################################################################################################################
###########################   MORE OPTIONS l  LIST DIRECTORY  ####################################################################################
##################################################################################################################################################

#   The Line below gives a total count of all mp4, mkv, avi, & divx in Current Directory.
currentdirfilecount=$(find_supported_files --count)
    

if [[ -f "videoinfo.List-Directory" ]]; then
#     >>>>>>>>>>>>>>>>>>>>>>>>>> DISPLAY LAST DIRECTORY LISTING >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 

      less videoinfo.List-Directory  # display in <less>
  
  else

#     >>>>>>>>>>>>>>>>>>>>>>>>>> CREATE NEW DIRECTORY LISTING FILE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   

# The group of echo's below write a header to file <videoinfo.List-Directory> 
# echo > videoinfo.List-Directory
echo "$ver                                                                                  LIST DIRECTORY" >> videoinfo.List-Directory
echo >> videoinfo.List-Directory
echo "This File was Created $(date) by" "$USER" >> videoinfo.List-Directory
echo >> videoinfo.List-Directory  # Every line ending in  ' >> videoinfo.List-Directory '  is writing that line to text file <videoinfo.List-Directory>)
echo "SAVED RESULTS LOADED FROM FILE: videoinfo.List-Directory" >> videoinfo.List-Directory
echo  >> videoinfo.List-Directory
echo "Working Directory: ""$PWD" >> videoinfo.List-Directory
echo  >> videoinfo.List-Directory 
echo "___________________________________________________________________________________________________________________" >> videoinfo.List-Directory
echo  >> videoinfo.List-Directory 
echo " Up & Down Arrows or Mouse wheel - scroll                                                            Home - top" >> videoinfo.List-Directory
echo " q - quit                                                                                            End - bottom" >> videoinfo.List-Directory
echo "___________________________________________________________________________________________________________________" >> videoinfo.List-Directory       
echo >> videoinfo.List-Directory
echo  >> videoinfo.List-Directory

# Display & Write <videoinfo.List-Directory>  The Results of:  - ffprobe for Codec & Resolution <$codecres>
#                                                              - ffmpeg for Duration in (hrs:min)
clear

for i in *.mp4; do 
  echo "$i";  # display <mp4> filename
  echo "$i" >> videoinfo.List-Directory  
  $codecres "$i"  # display <mp4> Codec & Resolution
  $codecres "$i" >> videoinfo.List-Directory
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//  # grep out duration, cut everything after "," then remove the ","
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,// >> videoinfo.List-Directory  # writing the same thing to a file
  echo
  echo >> videoinfo.List-Directory
done

for i in *.mkv; do 
  echo "$i"  # display <mkv> filename
  echo "$i" >> videoinfo.List-Directory
  $codecres "$i"  # display <mkv> Codec & Resolution$
  $codecres "$i" >> videoinfo.List-Directory
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//  # grep out duration, cut everything after "," then remove the ","
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,// >> videoinfo.List-Directory  # writing the same thing to a file
  echo
  echo
  echo >> videoinfo.List-Directory
  done

for i in *.avi; do 
  echo "$i"  # display <avi> filename
  echo "$i" >> videoinfo.List-Directory
  $codecres "$i"  # display <avi> Codec & Resolution
  $codecres "$i" >> videoinfo.List-Directory  
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//  # grep out duration, cut everything after "," then remove the ","
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,// >> videoinfo.List-Directory  # writing the same thing to a file
  echo
  echo >> videoinfo.List-Directory
done
for i in *.webm; do 
  echo "$i"  # display <avi> filename
  echo "$i" >> videoinfo.List-Directory
  $codecres "$i"  # display <avi> Codec & Resolution
  $codecres "$i" >> videoinfo.List-Directory  
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//  # grep out duration, cut everything after "," then remove the ","
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,// >> videoinfo.List-Directory  # writing the same thing to a file
  echo
  echo >> videoinfo.List-Directory
done
for i in *.divx; do 
  echo "$i"  # display <divx> filename
  echo "$i" >> videoinfo.List-Directory
  $codecres "$i"  # display <divx> Codec & Resolution
  $codecres "$i" >> videoinfo.List-Directory
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//  # grep out duration, cut everything after "," then remove the ","
  ffmpeg -i "$i" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,// >> videoinfo.List-Directory  # writing the same thing to a file
  echo
  echo >> videoinfo.List-Directory
done
     
# echo >> videoinfo.List-Directory
echo "Total Video Files:" "$currentdirfilecount"
echo >> videoinfo.List-Directory
echo "Total Video Files:" "$currentdirfilecount" >> videoinfo.List-Directory
echo
echo
echo >> videoinfo.List-Directory
echo ">>> Listing is not recursive <<<"
echo ">>> Listing is not recursive <<<" >> videoinfo.List-Directory
echo
echo >> videoinfo.List-Directory
echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen   
echo "Working Directory: ""$PWD" >> videoinfo.List-Directory
echo
if [[ "$currentdirfilecount" != 0 ]]; then
      echo "$rer"
      echo
      echo -e "\033[5mProbing $currentdirfilecount \033[5mVideo Files for Duration\033[0m"  #  file count of find results
      echo
      echo "This can take a while if there are a lot of video files to process."
      echo "You will get a GUI Notification when this process is complete."
      echo
     
      #  This is where the file <${base_dir}/videoinfo.duration.tmp> is created to store duration in seconds with the format being  (x.xxxxxx)
      #  Video files are found in current directory and processed with ffprobe and written to <${base_dir}/videoinfo.duration.tmp>. 
find . -maxdepth 1 -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) -exec ffprobe -show_entries format=duration -v quiet -of csv="p=0" {} \; > ${base_dir}/videoinfo.duration.tmp 2>/dev/null

      #  ffprobe outputs video duration in seconds 6 places past the decimal point.
      #  bash can't do floating point math.  So  <bc>  is needed first to get sum of   <${base_dir}/videoinfo.duration.tmp>
      #  The  <paste -sd+ ${base_dir}/videoinfo.duration.tmp>  puts a +  between each line of the file and  <bc>  gives you the sum. 
      floatingseconds=$(paste -sd+ ${base_dir}/videoinfo.duration.tmp | bc)
         
      #  The total in seconds <$floatingseconds> is taken from line above and the format needs changed from  (x.xxxxxx) to (x)
      #  Below, <awk> is stripping 7 characters in from the right of the sum of  <$floatingseconds>
      #  In this case, the decimal point and the 6 trailing numbers are stripped from the string.
      totalseconds=$(echo "$floatingseconds" | awk '{ print substr( $0, 1, length($0)-7 ) }')
        
      #  Calculation of  <$totalseconds>  into different formats.
      secs=$(echo "$totalseconds")  # $totalseconds variable stored in $secs variable
      totalminutes=$(($(($totalseconds/60))))  # total minutes calculation

      echo >> videoinfo.List-Directory
      echo >> videoinfo.List-Directory
      echo "Seconds"
      echo "Seconds" >> videoinfo.List-Directory
      echo "$totalseconds"  # display total seconds
      echo "$totalseconds" >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory 
      echo "Minutes"
      echo "Minutes" >> videoinfo.List-Directory
      echo "$totalminutes"  # display total minutes
      echo "$totalminutes" >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory
      echo "Hrs:Mi:Sec"
      echo "Hrs:Mi:Sec" >> videoinfo.List-Directory
      printf '%d:%d:%d\n' $((secs/3600)) $((secs%3600/60)) $((secs%60))  # calculation to display hours, minutes and seconds
      printf '%d:%d:%d\n' $((secs/3600)) $((secs%3600/60)) $((secs%60)) >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory
      echo "Days     Hrs:Min:Sec"
      echo "Days     Hrs:Min:Sec" >> videoinfo.List-Directory
      printf '%d        %d:%d:%d\n' $(($secs/86400)) $(($secs%86400/3600)) $(($secs%3600/60)) $(($secs%60))  # same as above except Days are added
      printf '%d        %d:%d:%d\n' $(($secs/86400)) $(($secs%86400/3600)) $(($secs%3600/60)) $(($secs%60)) >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory
      echo -e "\033[5mNEW RESULTS LOADED \033[5m \033[0m(use Mouse Wheel to Scroll)"
      echo "EXISTING RESULTS LOADED FROM FILE videoinfo.List-Directory " $(stat -c %y "videoinfo.List-Directory") >> videoinfo.List-Directory
      echo >> videoinfo.List-Directory
      echo
      echo >> videoinfo.List-Directory
      notify-send "Videoinfox is done processing: List Directory" "$PWD"  # GUI Notification is displayed when this function <option 1> has completed.
      # The file  <${base_dir}/videoinfo.duration.tmp>  was created for <ffprobe> to store video duration in seconds of all find results.
      # The math was already performed on this file and it is no longer needed.  So it is being removed.  
      rm ${base_dir}/videoinfo.duration.tmp
   fi
fi
# Everytime You Save.  The File <videoinfo.List-Directory> is saved to the directory that option 1 was run in.
function menu1 {

clear
less videoinfo.List-Directory  # view results from file
echo
echo " Directory: ""$PWD"
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$der"" >>> LIST DIRECTORY"                                                  
echo "___________________________________________________________________________________________________________________"
echo
echo " Save or Delete Directory Listing"
echo
echo " s - Save     d - Delete"  
echo 
echo -en " Enter Option: "
read -r -n1 option1
echo
}

while true; do
    menu1
    case $option1 in
    
    s) 
    echo
    echo " Results SAVED . . ."
    echo 
    #read -p "Press enter to Continue"
    sleep .75
    break;; 
        
    d) 
    rm videoinfo.List-Directory
    echo
    echo " Results DELETED . . ."
    echo 
    #read -p "Press enter to Continue"    
    sleep .75
    break;;
      
        *)
    
        esac
        done
        ;;
c)
##################################################################################################################################################
###########################   MORE OPTIONS c  CHANGE DIRECTORY  ##################################################################################
##################################################################################################################################################
 
pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo
echo " $ver >>> CHANGE DIRECTORY"
echo "___________________________________________________________________________________________________________________"
echo
echo " No quotations needed for paths with spaces. Case sensative."
echo 
read -r -p " Enter Directory: " specifydir  # waiting fot user input - the directory you want to chang to 
    
    if [[ -z "$specifydir" ]]; then
               echo
               echo " error: Nothing was entered"
               sleep .75
          else
              if [[ -d "$specifydir" ]]; then
                     echo
                     cd "$specifydir"   # change the directory
                     echo " Working Driectory changed to: $PWD"  # <pwd>  print current working directory to the screen
                     sleep 1.5                   
                else
                     echo
                     echo " error:  No such file or directory"
                     sleep 1.5                   
          fi
    fi       
echo
#read -p "     Press enter to Continue" 
;;
    

f)     
##################################################################################################################################################
###########################   MORE OPTIONS f  FIND DIRECTORY  ####################################################################################
##################################################################################################################################################

pasteclip=$(xclip -o -selection clipboard > /dev/null)  # grab clipboard content
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$ver"" >>> FIND DIRECTORY                                                               wildcard * ok"
echo "___________________________________________________________________________________________________________________" 
echo
read -r -p " Directory Name: " dirfind  # waiting fot user input - dierectory that you want to find
findmeadir=$(find . -type d -iname "$dirfind" 2>/dev/null | wc -l)   # number of files found
       
                                                                                       
    if [[ -z "$dirfind" ]]; then
               echo
               echo " error: Nothing was entered"  
               sleep .75  # EXIT THIS LOOP
          else
               
               
               if echo "$dirfind" | grep "/" > /dev/null 2>/dev/null  # if any slashes were entered goto <then>
                 then
                      echo
                      echo " error: No slashes directory name only"
                      sleep .75  # EXIT THIS LOOP  
                 else
                      echo
                     find . -type d -iname "$dirfind" | sort -u 2>/dev/null  # directory(s) found   
                      echo
                      echo " Total Directories Found:" "$findmeadir"  # number of files found
      
                  
                 if [[ "$findmeadir" = 0 ]]; then
                       sleep .75
                        :  # the colon can be used in place of a command to 'Do Nothing'  Exit this nested loop
                   else                         
                        pastetemp=$(xclip -o -selection clipboard 2>/dev/null)  # perserve clipboard content prioir to runnin this function
                        notify-send "Videoinfox is done processing: Find Directory" "Total Directories Found: $findmeadir" # GUI Notification.
                        echo       
                       echo " Chang the directory: Copy 1 line (including the dot) to the Clipboard then press enter"
                        echo                             
                        echo " Stay in current directory: enter without copy."
                      read -r -p " "
                      pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
                        cd "$pasteclip" 2>/dev/null 
                        echo " Working Driectory: ""$PWD"""  # <pwd>  print current working directory to the screen 
                        echo "$pastetemp" | xclip -sel clip 2>/dev/null  #  reload clipboard content prior to running this function
                        pasteclip=$(xclip -o -selection clipboard 2>/dev/null)  # grab clipboard content
                        sleep 1.5            
        fi
        fi
        fi              
echo

#read -p "Press enter to Continue"              

;;
n)
##################################################################################################################################################
###########################   MORE OPTIONS  4  VIDEO COUNT  ######################################################################################
##################################################################################################################################################
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo  
echo " $der >>> VIDEO COUNT - Recursive"
echo "___________________________________________________________________________________________________________________" 
echo
echo " RECURSIVE COUNT OF VIDEO FILES"
echo
mp4count=$(find . -type f \( -iname "*.mp4" \) 2>/dev/null | wc -l)  # total number of <mp4> files found
echo " MP4   = " "$mp4count"
mkvcount=$(find . -type f \( -iname "*.mkv" \) 2>/dev/null | wc -l)  # total number of <mkv> files found
echo " MKV   = " "$mkvcount"
avicount=$(find . -type f \( -iname "*.avi" \) 2>/dev/null | wc -l)  # total number of <avi> files found
echo " AVI   = " "$avicount"
webmcount=$(find . -type f \( -iname "*.webm" \) 2>/dev/null | wc -l) # total number of <webm files found
echo " WEBM  = " "$webmcount"
divxcount=$(find . -type f \( -iname "*.divx" \) 2>/dev/null | wc -l) # total number of <divx> files found
echo " DIVX  = " "$divxcount"
echo "------------------"
totalcount=$(($mp4count + $mkvcount + $avicount + $webmcount + $divxcount))  # calcutation for Sum of All 4 file types
echo " TOTAL = " $totalcount  # display Sum
# GUI Notification is displayed when this function <option 6> has completed. 
notify-send  "Videoinfox is done processing Video File Count " "Total Video Files located in $PWD : $totalcount"
echo
read -r -p " Press enter to Continue" 
;;
    

d)
##################################################################################################################################################
###########################  MORE OPTIONS  d  VIDEO DURATION  ####################################################################################
##################################################################################################################################################

if [[ -f "videoinfo.Video-Duration" ]]; then
#     >>>>>>>>>>>>>>>>>>>>>>>>>> DISPLAY Saved RESULTS >>>>>>>>>>>>>>>>>>>>>>>>>> 
      cat videoinfo.Video-Duration
  else
#     >>>>>>>>>>>>>>>>>>>>>>>>>> CREATE NEW RESULTS >>>>>>>>>>>>>>>>>>>>>>>>>>
#   The Line below gives a total count of all mp4, mkv, avi, & divx Recursively.
alldirfilecount=$(find . -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -name "*.webm" -o -iname "*.divx" \) 2>/dev/null | wc -l)

#  The group of echo's below write a header to file <videoinfo.Video-Duration> 
echo > videoinfo.Video-Duration
echo "$ver                                                                                              VIDEO DURATION" >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration
echo "This File was Created $(date) by" "$USER" >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration  # Every line ending in  ' >> videoinfo.Video-Duration '  is writing that line to text file <videoinfo.Video-Duration>

#  The rest of this function Writes the Results to the Screen and File <videoinfo.Video-Duration>
clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"  
echo
echo " ""$der"" >>> VIDEO DURATION - Recursive"
echo "___________________________________________________________________________________________________________________" 
echo
echo "Working Directory: ""$PWD" >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration
echo "RECURSIVE DURATION OF VIDEO FILES"
echo "RECURSIVE DURATION OF $alldirfilecount VIDEO FILES" >> videoinfo.Video-Duration
echo
echo "This can take a while if there are a lot of video files to process."
echo "You will get a GUI Notification when this process is complete."
echo
echo -e "\033[5mProbing $alldirfilecount \033[5mVideo Files for Duration\033[0m"  #  file count of find results
echo -e "\n"
echo >> videoinfo.Video-Duration
#  This is where the file <${base_dir}/videoinfo.duration.tmp> is created to store duration in seconds with the format being  (x.xxxxxx)
#  Video files are found recursively and processed with ffprobe and written to <${base_dir}/videoinfo.duration.tmp>. 
find . -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm" -o -iname "*.divx" \) -exec ffprobe -show_entries format=duration -v quiet -of csv="p=0" {} \; > ${base_dir}/videoinfo.duration.tmp 2>/dev/null
#  ffprobe outputs video duration in seconds 6 places past the decimal point.
#  bash can't do floating point math.  So  <bc>  is needed first to get sum of  <${base_dir}/videoinfo.duration.tmp>
#  The  <paste -sd+ ${base_dir}/videoinfo.duration.tmp>  puts a +  between each line of the file and  <bc>  gives you the sum. 
floatingseconds=$(paste -sd+  ${base_dir}/videoinfo.duration.tmp | bc)
#  The total in seconds is taken from line above and the format needs changed from  (x.xxxxxx) to (x)
#  Below, <awk> is stripping 7 characters in from the right of the sum of  <$floatingseconds>
#  In this case, the decimal point and the 6 trailing numbers are stripped from the string.
totalseconds=$(echo "$floatingseconds" | awk '{ print substr( $0, 1, length($0)-7 ) }')

clear
echo "Working Directory: ""$PWD"  # <pwd>  print current working directory to the screen 
echo
echo "$der"
echo
echo "RECURSIVE DURATION OF VIDEO FILES"
echo
echo "DONE Probing ""$alldirfilecount"" Video Files for Duration"  #  file count of find results
echo
#  Calculation of  <$totalseconds>  into different formats.
secs=$(echo "$totalseconds")
totalminutes=$(($(($totalseconds/60))))  # convert seconds into minutes

echo "Seconds"
echo "Seconds" >> videoinfo.Video-Duration
echo "$totalseconds"  # display total seconds
echo "$totalseconds" >> videoinfo.Video-Duration  
echo
echo >> videoinfo.Video-Duration
echo "Minutes"
echo "Minutes" >> videoinfo.Video-Duration
echo $totalminutes  # display total minutes
echo $totalminutes >> videoinfo.Video-Duration  
echo
echo >> videoinfo.Video-Duration
echo "Hrs:Mi:Sec"
echo "Hrs:Mi:Sec" >> videoinfo.Video-Duration
printf '%d:%d:%d\n' $((secs/3600)) $((secs%3600/60)) $((secs%60))  # calculation to display hours, minutes and seconds
printf '%d:%d:%d\n' $((secs/3600)) $((secs%3600/60)) $((secs%60)) >> videoinfo.Video-Duration  
echo
echo >> videoinfo.Video-Duration
echo "Days     Hrs:Min:Sec" 
echo "Days     Hrs:Min:Sec" >> videoinfo.Video-Duration
printf '%d        %d:%d:%d\n' $(($secs/86400)) $(($secs%86400/3600)) $(($secs%3600/60)) $(($secs%60)) # same as above + Days
printf '%d        %d:%d:%d\n' $(($secs/86400)) $(($secs%86400/3600)) $(($secs%3600/60)) $(($secs%60)) >> videoinfo.Video-Duration  
echo
echo >> videoinfo.Video-Duration
echo
echo -e "\033[5mNEW RESULTS LOADED \033[5m \033[0m"
echo "SAVED RESULTS LOADED FROM FILE: videoinfo.Video-Duration" $(stat -c %y "videoinfo.Video-Duration") >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration
#echo
#echo "     q  to quit" >> videoinfo.Video-Duration
echo >> videoinfo.Video-Duration
notify-send  "Videoinfox is done processing: Video Duration" "$PWD"  # GUI Notification is displayed when this function has completed.
# The file  <${base_dir}/videoinfo.duration.tmp>  was created for <ffprobe> to store video duration in seconds of all find results.
# The math was already performed on this file and it is no longer needed.  So it is being removed.  
#rm ${base_dir}/videoinfo.duration.tmp
fi
function menu5 {
clear
cat videoinfo.Video-Duration
echo
echo "___________________________________________________________________________________________________________________" 
echo
echo " ""$der"" >>> VIDEO DURATION - Recursive"
echo "___________________________________________________________________________________________________________________" 
echo
echo " s - Save     d - Delete"  
echo 
echo -en " Enter Option: "
read -r -n1 option5
echo
}

while true; do
    menu5
    case $option5 in
    
    s) 
    echo
    echo " Results SAVED . . ."
    echo 
    #read -p "Press enter to Continue"
     .75
    break;; 
        
    d) 
    rm videoinfo.Video-Duration
    echo
    echo " Results DELETED . . ."
    echo 
    #read -p "Press enter to Continue"    
    sleep .75
    break;;

         *)

         esac
         done
         ;;
v)
##################################################################################################################################################
###########################   MORE OPTIONS v  ENTER VIDEO FILE  ##################################################################################
##################################################################################################################################################

clear
echo
echo "Directory: ""$PWD"
echo "Clipboard: ""$pasteclip"
echo "___________________________________________________________________________________________________________________"
echo
echo " ""$ver"" >>> ENTER VIDEO FILE - For Info"
echo "___________________________________________________________________________________________________________________"
echo
echo " Full path needed. No quotations needed for paths or files with spaces. Case Sensative."
echo
read -r -p " Video File: " specifyfile  # waiting fot user input - video file to display
echo

        if [[ -z "$specifyfile" ]]; then
              echo " error: Nothing was entered"
              sleep .7
          else  
               if [[ -f "$specifyfile" ]]; then
                       echo "$specifyfile"  | xclip -sel clip  # copy valid file to the cilpboard for play
                       pasteclip=$(xclip -o -selection clipboard 2> /dev/null)  # grab clipboard content
                       
echo " Video Info: "$(ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 "$pasteclip") "Duration:" $(ffmpeg -i "$pasteclip" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//)  # codec, width, height and duration
                       echo
                       echo " Filename copied to clipboard for play"
                       echo
                       read -r -p " Press enter to Continue" 
                else
                       echo " error: No such file or directory"
                       sleep .7
          fi      
          fi

    echo
    ;;
    esac
    done
    ;;
esac    
done

##################################################################################################################################################
###########################  END MAIN LOOP  ######################################################################################################
##################################################################################################################################################
#  EXIT MESSAGE
clear
echo -e "\n"
echo
echo "___________________________________________________________________________________________________________________"
echo  
echo " ""$ver"" >>> EXIT"
echo "___________________________________________________________________________________________________________________" 
echo -e "\n"
# Error: target STRING not available is an xclip error
#   FYI :

#   The Line Below performs a Recursive Search and outputs ffprobe's Duration of every find in seconds format (x.xxxxxx).
#   find . -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname ".avi" -o -iname "*.webm -o -iname "*.divx"\) -exec ffprobe -show_entries format=duration -v quiet -of csv="p=0" {} \;

#   The Line Below performs a Recursive Search and outputs Video File Count.
#   find . -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.webm -o -iname "*.divx" \) | wc -l

#   The Line Below gets the Codec & Resolution from a video file.
#   NOTE : Do NOT include  <  >   around the filename. 
#   ffprobe -v error -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -select_streams v:0 -show_entries stream=width,height -of default=nw=1 <filename>

#   The Line Below gets the Duration from video file and dsiplays in  <Days:Hours:Minutes:Seconds>
#   NOTE :  Save Double Quotes around the filename. 
#   ffmpeg -i "filename" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//
#

main() {
    # Run our initialisation tasks
    init
    # Parse our given args
    while getopts ":adhlu:v" opts; do
        case "${opts}" in
            (a)     write_default_list ;;
            (d)     play_directory ;;
            (h)     print_help ;;
            (l)     write_user_set_list ;;
            (u)     use_custom_list "${OPTARG}" ;;
            (v)     print_version ;;
            (\?)    printf -- '%s\n' "ERROR: Invalid option: ${OPTARG}." >&2; exit 1 ;;
            (:)     printf -- '%s\n' "Option '-${OPTARG}' requires an argument, e.g. '-${OPTARG} 5'." >&2; exit 1 ;;
        esac
    done
}

main "${@}"
